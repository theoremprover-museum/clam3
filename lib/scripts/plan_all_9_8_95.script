% loading file /home/dream3/air/clam/clam.v3.2/make/clam.v3.2.1.qui
%  foreign file /disk/local/src/quintus3/generic/qplib3.1.4/library/sun4-4/libpl.so loaded
% clam.v3.2.1.qui loaded in module user, 0.617 sec 659,440 bytes

CLaM Proof Planner Version 3.2.1 (9/8/95 12:02)

% compiling file /home/dream3/air/clam/clam.v3.2/lib/needs.pl
% needs.pl compiled in module user, 0.600 sec 112 bytes
Quintus Prolog Release 3.1.4 (Sun-4, SunOS 4.1)
Copyright (C) 1993, Quintus Corporation.  All rights reserved.
2100 Geng Road, Palo Alto, California U.S.A. (415) 813-3800
CLaM Proof Planner Version 3.2.1 (libraries only) (9/8/95 11:55)
CLaM Proof Planner Version 3.2.1 (9/8/95 12:02)

| ?- plan_all.
% compiling file /home/dream3/air/clam/clam.v3.2/lib/examples.pl
% examples.pl compiled in module user, 0.116 sec 2,280 bytes
loading def(double)...done
loading eqn(double1)...done
loading eqn(double2)...done
 adding wave-rules for double1:..done
 adding wave-rules for double2:..............done
 adding defeqn-record for double1...done 
 adding defeqn-record for double2...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(doubleplus)...done
doubleplus([])
==>x:pnat=>double(x)=plus(x,x)in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|doubleplus([2])
|x:pnat
|v0:ih(double(x)=plus(x,x)in pnat)
|==>double(``s({x})''<out>)=plus(``s({x})''<out>,``s({x})''<out>)in pnat
|SELECTED METHOD at depth 1: wave([1,1],[double2,equ(left)])
||doubleplus([1,2])
||x:pnat
||v0:ih(double(x)=plus(x,x)in pnat)
||==>``s({``s({double(x)})''<out>})''<out> =plus(``s({x})''<out>,``s({x})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([2,1],[plus2,equ(left)])
|||doubleplus([1,1,2])
|||x:pnat
|||v0:ih(double(x)=plus(x,x)in pnat)
|||==>``s({``s({double(x)})''<out>})''<out> =``s({plus(x,``s({x})''<out>)})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=s(plus(v0,x))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat
SELECTED METHOD at depth 0: induction([s(v0)],[v0:pnat])
|lemma1([2])
|v0:pnat
|v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(plus(``s({v0})''<out>,\x/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||v0:pnat
||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(``s({plus(v0,\x/)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =s(``s({plus(v0,\x/)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =``s({s(plus(v0,\x/))})''<out>in pnat
|||SELECTED METHOD at depth 3: fertilize(weak(v1))
||||lemma1([1,1,1,2])
||||v0:pnat
||||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||||==>s(plus(v0,s(x)))=s(plus(v0,s(x)))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
|lemma1([1])
|v0:pnat
|==>x:pnat=>plus(0,s(x))=s(plus(0,x))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],plus1)
||lemma1([1,1])
||v0:pnat
||==>x:pnat=>s(x)=s(plus(0,x))in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],plus1)
|||lemma1([1,1,1])
|||v0:pnat
|||==>x:pnat=>s(x)=s(x)in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
 adding wave-rules for lemma1:.................done
|||doubleplus([1,1,2])
|||x:pnat
|||v0:ih(double(x)=plus(x,x)in pnat)
|||==>``s({``s({double(x)})''<out>})''<out> =``s({plus(x,``s({x})''<out>)})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[lemma1,equ(left)])
||||doubleplus([1,1,1,2])
||||x:pnat
||||v0:ih(double(x)=plus(x,x)in pnat)
||||==>``s({``s({double(x)})''<out>})''<out> =``s({``s({plus(x,x)})''<out>})''<out>in pnat
||||SELECTED METHOD at depth 4: fertilize(weak(v0))
|||||doubleplus([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(double(x)=plus(x,x)in pnat)
|||||==>s(s(double(x)))=s(s(double(x)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
|doubleplus([1])
|x:pnat
|==>double(0)=plus(0,0)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],plus1)
||doubleplus([1,1])
||x:pnat
||==>double(0)=0 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1],double1)
|||doubleplus([1,1,1])
|||x:pnat
|||==>0=0 in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for doubleplus

------------------------------------------------------------
doubleplus:

[x:pnat]

|- double(x)=plus(x,x)in pnat

induction([s(x)],[x:pnat]) then 
  [eval_def([2,1],plus1) then 
     eval_def([1,1],double1) then 
       elementary(...),
   wave([1,1],[double2,equ(left)]) then 
     wave([2,1],[plus2,equ(left)]) then 
       wave([1,2,1],[lemma1,equ(left)]) then 
         fertilize(weak(v0)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=s(plus(v0,x))in pnat

induction([s(v0)],[v0:pnat]) then 
  [eval_def([1,1],plus1) then 
     eval_def([1,2,1],plus1) then 
       elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1],[plus2,equ(left)]) then 
       fertilize(weak(v1)) then 
         elementary(...)
  ]


PLANNING for doubleplus COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(double) not present, so cannot be deleted
deleting def(double)...done
deleting theorem record for double1...done
deleting wave record for double1...done
deleting wave record for double1...done
deleting func_defeqn record for double1...done
deleting wave(double1)...done
deleting theorem record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting func_defeqn record for double2...done
deleting wave(double2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for doubleplus...done
deleting thm(doubleplus)...done
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(lenapp)...done
lenapp([])
==>a:int list=>b:int list=>length(app(a,b))=length(app(b,a))in pnat
SELECTED METHOD at depth 0: induction([v0::b],[b:int list])
|lenapp([2])
|v0:int
|b:int list
|v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
|==>a:int list=>length(app(\a/,``v0::{b}''<out>))=length(app(``v0::{b}''<out>,\a/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[app2,equ(left)])
||lenapp([1,2])
||v0:int
||b:int list
||v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
||==>a:int list=>length(app(\a/,``v0::{b}''<out>))=length(``v0::{app(b,\a/)}''<out>)in pnat
||SELECTED METHOD at depth 2: wave([2,1],[length2,equ(left)])
|||lenapp([1,1,2])
|||v0:int
|||b:int list
|||v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
|||==>a:int list=>length(app(\a/,``v0::{b}''<out>))=``s({length(app(b,\a/))})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[a:int list,b:int list,v0:int]

|- length(app(a,v0::b))=s(length(app(a,b)))in pnat

saving thm(lemma1)...done
lemma1([])
==>a:int list=>b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat
SELECTED METHOD at depth 0: induction([v1::a],[a:int list])
|lemma1([2])
|v1:int
|a:int list
|v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
|==>b:int list=>v0:int=>length(app(``v1::{a}''<out>,\v0/ ::\b/))=s(length(app(``v1::{a}''<out>,\b/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v1:int
||a:int list
||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
||==>b:int list=>v0:int=>length(app(``v1::{a}''<out>,\v0/ ::\b/))=s(length(``v1::{app(a,\b/)}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v1:int
|||a:int list
|||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
|||==>b:int list=>v0:int=>length(app(``v1::{a}''<out>,\v0/ ::\b/))=s(``s({length(app(a,\b/))})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v1:int
||||a:int list
||||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
||||==>b:int list=>v0:int=>length(``v1::{app(a,\v0/ ::\b/)}''<out>)=s(``s({length(app(a,\b/))})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v1:int
|||||a:int list
|||||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
|||||==>b:int list=>v0:int=>``s({length(app(a,\v0/ ::\b/))})''<out> =s(``s({length(app(a,\b/))})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||||lemma1([1,1,1,1,2])
|||||v1:int
|||||a:int list
|||||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
|||||==>b:int list=>v0:int=>``s({length(app(a,\v0/ ::\b/))})''<out> =``s({s(length(app(a,\b/)))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v2))
||||||lemma1([1,1,1,1,1,2])
||||||v1:int
||||||a:int list
||||||v2:ih(b:int list=>v0:int=>length(app(a,v0::b))=s(length(app(a,b)))in pnat)
||||||==>s(length(app(a,v0::b)))=s(length(app(a,_186966::b)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|a:int list
|==>b:int list=>v0:int=>length(app(nil,v0::b))=s(length(app(nil,b)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||lemma1([1,1])
||a:int list
||==>b:int list=>v0:int=>length(app(nil,v0::b))=s(length(b))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||a:int list
|||==>b:int list=>v0:int=>length(v0::b)=s(length(b))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||a:int list
||||==>b:int list=>v0:int=>s(length(b))=s(length(b))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma1:................................done
|||lenapp([1,1,2])
|||v0:int
|||b:int list
|||v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
|||==>a:int list=>length(app(\a/,``v0::{b}''<out>))=``s({length(app(b,\a/))})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||lenapp([1,1,1,2])
||||v0:int
||||b:int list
||||v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
||||==>a:int list=>``s({length(app(\a/,b))})''<out> =``s({length(app(b,\a/))})''<out>in pnat
||||SELECTED METHOD at depth 4: fertilize(weak(v1))
|||||lenapp([1,1,1,1,2])
|||||v0:int
|||||b:int list
|||||v1:ih(a:int list=>length(app(a,b))=length(app(b,a))in pnat)
|||||==>s(length(app(a,b)))=s(length(app(a,b)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
|lenapp([1])
|b:int list
|==>a:int list=>length(app(a,nil))=length(app(nil,a))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],app1)
||lenapp([1,1])
||b:int list
||==>a:int list=>length(app(a,nil))=length(a)in pnat
||SELECTED METHOD at depth 2: induction([v0::a],[a:int list])
|||lenapp([2,1,1])
|||v0:int
|||a:int list
|||v1:ih(length(app(a,nil))=length(a)in pnat)
|||b:int list
|||==>length(app(``v0::{a}''<out>,nil))=length(``v0::{a}''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[length2,equ(left)])
||||lenapp([1,2,1,1])
||||v0:int
||||a:int list
||||v1:ih(length(app(a,nil))=length(a)in pnat)
||||b:int list
||||==>length(app(``v0::{a}''<out>,nil))=``s({length(a)})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[app2,equ(left)])
|||||lenapp([1,1,2,1,1])
|||||v0:int
|||||a:int list
|||||v1:ih(length(app(a,nil))=length(a)in pnat)
|||||b:int list
|||||==>length(``v0::{app(a,nil)}''<out>)=``s({length(a)})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[length2,equ(left)])
||||||lenapp([1,1,1,2,1,1])
||||||v0:int
||||||a:int list
||||||v1:ih(length(app(a,nil))=length(a)in pnat)
||||||b:int list
||||||==>``s({length(app(a,nil))})''<out> =``s({length(a)})''<out>in pnat
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||lenapp([1,1,1,1,2,1,1])
|||||||v0:int
|||||||a:int list
|||||||v1:ih(length(app(a,nil))=length(a)in pnat)
|||||||b:int list
|||||||==>s(length(app(a,nil)))=s(length(app(a,nil)))in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||lenapp([1,1,1])
|||a:int list
|||b:int list
|||==>length(app(nil,nil))=length(nil)in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1],length1)
||||lenapp([1,1,1,1])
||||a:int list
||||b:int list
||||==>length(app(nil,nil))=0 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],app1)
|||||lenapp([1,1,1,1,1])
|||||a:int list
|||||b:int list
|||||==>length(nil)=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],length1)
||||||lenapp([1,1,1,1,1,1])
||||||a:int list
||||||b:int list
||||||==>0=0 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for lenapp

------------------------------------------------------------
lenapp:

[a:int list,b:int list]

|- length(app(a,b))=length(app(b,a))in pnat

induction([v0::b],[b:int list]) then 
  [eval_def([1,2,1],app1) then 
     induction([v0::a],[a:int list]) then 
       [eval_def([2,1],length1) then 
          eval_def([1,1,1],app1) then 
            eval_def([1,1],length1) then 
              elementary(...),
        wave([2,1],[length2,equ(left)]) then 
          wave([1,1,1],[app2,equ(left)]) then 
            wave([1,1],[length2,equ(left)]) then 
              fertilize(weak(v1)) then 
                elementary(...)
       ],
   wave([1,2,1],[app2,equ(left)]) then 
     wave([2,1],[length2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         fertilize(weak(v1)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[a:int list,b:int list,v0:int]

|- length(app(a,v0::b))=s(length(app(a,b)))in pnat

induction([v1::a],[a:int list]) then 
  [eval_def([1,1,2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         elementary(...),
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([1,2,1],[length2,equ(left)]) then 
       wave([1,1,1],[app2,equ(left)]) then 
         wave([1,1],[length2,equ(left)]) then 
           fertilize(weak(v2)) then 
             elementary(...)
  ]


PLANNING for lenapp COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for lenapp...done
deleting thm(lenapp)...done
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(lenplus)...done
lenplus([])
==>x:pnat list=>y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|lenplus([2])
|v0:pnat
|x:pnat list
|v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
|==>y:pnat list=>length(app(``v0::{x}''<out>,\y/))=plus(length(\y/),length(``v0::{x}''<out>))in pnat
|SELECTED METHOD at depth 1: wave([2,2,1],[length2,equ(left)])
||lenplus([1,2])
||v0:pnat
||x:pnat list
||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
||==>y:pnat list=>length(app(``v0::{x}''<out>,\y/))=plus(length(\y/),``s({length(x)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lenplus([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
|||==>y:pnat list=>length(``v0::{app(x,\y/)}''<out>)=plus(length(\y/),``s({length(x)})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[length2,equ(left)])
||||lenplus([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
||||==>y:pnat list=>``s({length(app(x,\y/))})''<out> =plus(length(\y/),``s({length(x)})''<out>)in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat]

|- plus(v0,s(v1))=s(plus(v0,v1))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat
SELECTED METHOD at depth 0: induction([s(v0)],[v0:pnat])
|lemma1([2])
|v0:pnat
|v2:ih(v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat)
|==>v1:pnat=>plus(``s({v0})''<out>,s(\v1/))=s(plus(``s({v0})''<out>,\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||v0:pnat
||v2:ih(v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat)
||==>v1:pnat=>plus(``s({v0})''<out>,s(\v1/))=s(``s({plus(v0,\v1/)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||v2:ih(v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat)
|||==>v1:pnat=>``s({plus(v0,s(\v1/))})''<out> =s(``s({plus(v0,\v1/)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||lemma1([1,1,2])
|||v0:pnat
|||v2:ih(v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat)
|||==>v1:pnat=>``s({plus(v0,s(\v1/))})''<out> =``s({s(plus(v0,\v1/))})''<out>in pnat
|||SELECTED METHOD at depth 3: fertilize(weak(v2))
||||lemma1([1,1,1,2])
||||v0:pnat
||||v2:ih(v1:pnat=>plus(v0,s(v1))=s(plus(v0,v1))in pnat)
||||==>s(plus(v0,s(v1)))=s(plus(v0,s(v1)))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
|lemma1([1])
|v0:pnat
|==>v1:pnat=>plus(0,s(v1))=s(plus(0,v1))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],plus1)
||lemma1([1,1])
||v0:pnat
||==>v1:pnat=>s(v1)=s(plus(0,v1))in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],plus1)
|||lemma1([1,1,1])
|||v0:pnat
|||==>v1:pnat=>s(v1)=s(v1)in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
 adding wave-rules for lemma1:.................done
||||lenplus([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
||||==>y:pnat list=>``s({length(app(x,\y/))})''<out> =plus(length(\y/),``s({length(x)})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[lemma1,equ(left)])
|||||lenplus([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
|||||==>y:pnat list=>``s({length(app(x,\y/))})''<out> =``s({plus(length(\y/),length(x))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v1))
||||||lenplus([1,1,1,1,1,2])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(y:pnat list=>length(app(x,y))=plus(length(y),length(x))in pnat)
||||||==>s(length(app(x,y)))=s(length(app(x,y)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lenplus([1])
|x:pnat list
|==>y:pnat list=>length(app(nil,y))=plus(length(y),length(nil))in pnat
|SELECTED METHOD at depth 1: eval_def([2,2,1],length1)
||lenplus([1,1])
||x:pnat list
||==>y:pnat list=>length(app(nil,y))=plus(length(y),0)in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lenplus([1,1,1])
|||x:pnat list
|||==>y:pnat list=>length(y)=plus(length(y),0)in pnat
|||SELECTED METHOD at depth 3: generalise(length(y),v0:pnat)
||||lenplus([1,1,1,1])
||||x:pnat list
||||==>v0:pnat=>y:pnat list=>v0=plus(v0,0)in pnat
||||SELECTED METHOD at depth 4: induction([s(v0)],[v0:pnat])
|||||lenplus([2,1,1,1,1])
|||||v0:pnat
|||||v1:ih(y:pnat list=>v0=plus(v0,0)in pnat)
|||||x:pnat list
|||||==>y:pnat list=>``s({v0})''<out> =plus(``s({v0})''<out>,0)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1],[plus2,equ(left)])
||||||lenplus([1,2,1,1,1,1])
||||||v0:pnat
||||||v1:ih(y:pnat list=>v0=plus(v0,0)in pnat)
||||||x:pnat list
||||||==>y:pnat list=>``s({v0})''<out> =``s({plus(v0,0)})''<out>in pnat
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||lenplus([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||v1:ih(y:pnat list=>v0=plus(v0,0)in pnat)
|||||||x:pnat list
|||||||==>s(v0)=s(v0)in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||||lenplus([1,1,1,1,1])
|||||v0:pnat
|||||x:pnat list
|||||==>y:pnat list=>0=plus(0,0)in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1],plus1)
||||||lenplus([1,1,1,1,1,1])
||||||v0:pnat
||||||x:pnat list
||||||==>y:pnat list=>0=0 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for lenplus

------------------------------------------------------------
lenplus:

[x:pnat list,y:pnat list]

|- length(app(x,y))=plus(length(y),length(x))in pnat

induction([v0::x],[x:pnat list]) then 
  [eval_def([2,2,1],length1) then 
     eval_def([1,1,1],app1) then 
       generalise(length(y),v0:pnat) then 
         induction([s(v0)],[v0:pnat]) then 
           [eval_def([2,1],plus1) then 
              elementary(...),
            wave([2,1],[plus2,equ(left)]) then 
              fertilize(weak(v1)) then 
                elementary(...)
           ],
   wave([2,2,1],[length2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([1,1],[length2,equ(left)]) then 
         wave([2,1],[lemma1,equ(left)]) then 
           fertilize(weak(v1)) then 
             elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat]

|- plus(v0,s(v1))=s(plus(v0,v1))in pnat

induction([s(v0)],[v0:pnat]) then 
  [eval_def([1,1],plus1) then 
     eval_def([1,2,1],plus1) then 
       elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1],[plus2,equ(left)]) then 
       fertilize(weak(v2)) then 
         elementary(...)
  ]


PLANNING for lenplus COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for lenplus...done
deleting thm(lenplus)...done
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(double)...done
loading eqn(double1)...done
loading eqn(double2)...done
 adding wave-rules for double1:..done
 adding wave-rules for double2:..............done
 adding defeqn-record for double1...done 
 adding defeqn-record for double2...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(lendouble)...done
lendouble([])
==>x:pnat list=>length(app(x,x))=double(length(x))in pnat list
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|lendouble([2])
|v0:pnat
|x:pnat list
|v1:ih(length(app(x,x))=double(length(x))in pnat list)
|==>length(app(``v0::{x}''<out>,``v0::{x}''<out>))=double(length(``v0::{x}''<out>))in pnat list
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lendouble([1,2])
||v0:pnat
||x:pnat list
||v1:ih(length(app(x,x))=double(length(x))in pnat list)
||==>length(app(``v0::{x}''<out>,``v0::{x}''<out>))=double(``s({length(x)})''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[double2,equ(left)])
|||lendouble([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(length(app(x,x))=double(length(x))in pnat list)
|||==>length(app(``v0::{x}''<out>,``v0::{x}''<out>))=``s({``s({double(length(x))})''<out>})''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[app2,equ(left)])
||||lendouble([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(length(app(x,x))=double(length(x))in pnat list)
||||==>length(``v0::{app(x,``v0::{x}''<out>)}''<out>)=``s({``s({double(length(x))})''<out>})''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[length2,equ(left)])
|||||lendouble([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(length(app(x,x))=double(length(x))in pnat list)
|||||==>``s({length(app(x,``v0::{x}''<out>))})''<out> =``s({``s({double(length(x))})''<out>})''<out>in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat list,v0:pnat,x:pnat list]

|- length(app(v1,v0::x))=s(length(app(v1,x)))in pnat

saving thm(lemma1)...done
lemma1([])
==>v1:pnat list=>v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
|==>v0:pnat=>x:pnat list=>length(app(``v2::{v1}''<out>,\v0/ ::\x/))=s(length(app(``v2::{v1}''<out>,\x/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
||==>v0:pnat=>x:pnat list=>length(app(``v2::{v1}''<out>,\v0/ ::\x/))=s(length(``v2::{app(v1,\x/)}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
|||==>v0:pnat=>x:pnat list=>length(app(``v2::{v1}''<out>,\v0/ ::\x/))=s(``s({length(app(v1,\x/))})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
||||==>v0:pnat=>x:pnat list=>length(``v2::{app(v1,\v0/ ::\x/)}''<out>)=s(``s({length(app(v1,\x/))})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
|||||==>v0:pnat=>x:pnat list=>``s({length(app(v1,\v0/ ::\x/))})''<out> =s(``s({length(app(v1,\x/))})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
|||||==>v0:pnat=>x:pnat list=>``s({length(app(v1,\v0/ ::\x/))})''<out> =``s({s(length(app(v1,\x/)))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||v1:pnat list
||||||v3:ih(v0:pnat=>x:pnat list=>length(app(v1,v0::x))=s(length(app(v1,x)))in pnat)
||||||==>s(length(app(v1,v0::x)))=s(length(app(v1,_191264::x)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>x:pnat list=>length(app(nil,v0::x))=s(length(app(nil,x)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>x:pnat list=>length(app(nil,v0::x))=s(length(x))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>x:pnat list=>length(v0::x)=s(length(x))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>x:pnat list=>s(length(x))=s(length(x))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma1:................................done
|||||lendouble([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(length(app(x,x))=double(length(x))in pnat list)
|||||==>``s({length(app(x,``v0::{x}''<out>))})''<out> =``s({``s({double(length(x))})''<out>})''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,1],[lemma1,equ(left)])
||||||lendouble([1,1,1,1,1,2])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(length(app(x,x))=double(length(x))in pnat list)
||||||==>``s({``s({length(app(x,x))})''<out>})''<out> =``s({``s({double(length(x))})''<out>})''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||lendouble([1,1,1,1,1,1,2])
|||||||v0:pnat
|||||||x:pnat list
|||||||v1:ih(length(app(x,x))=double(length(x))in pnat list)
|||||||==>s(s(length(app(x,x))))=s(s(length(app(x,x))))in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|lendouble([1])
|x:pnat list
|==>length(app(nil,nil))=double(length(nil))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lendouble([1,1])
||x:pnat list
||==>length(app(nil,nil))=double(0)in pnat list
||SELECTED METHOD at depth 2: eval_def([2,1],double1)
|||lendouble([1,1,1])
|||x:pnat list
|||==>length(app(nil,nil))=0 in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1,1],app1)
||||lendouble([1,1,1,1])
||||x:pnat list
||||==>length(nil)=0 in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1],length1)
|||||lendouble([1,1,1,1,1])
|||||x:pnat list
|||||==>0=0 in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
Planning complete for lendouble

------------------------------------------------------------
lendouble:

[x:pnat list]

|- length(app(x,x))=double(length(x))in pnat list

induction([v0::x],[x:pnat list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([2,1],double1) then 
       eval_def([1,1,1],app1) then 
         eval_def([1,1],length1) then 
           elementary(...),
   wave([1,2,1],[length2,equ(left)]) then 
     wave([2,1],[double2,equ(left)]) then 
       wave([1,1,1],[app2,equ(left)]) then 
         wave([1,1],[length2,equ(left)]) then 
           wave([1,1,1],[lemma1,equ(left)]) then 
             fertilize(weak(v1)) then 
               elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v1:pnat list,v0:pnat,x:pnat list]

|- length(app(v1,v0::x))=s(length(app(v1,x)))in pnat

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         elementary(...),
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([1,2,1],[length2,equ(left)]) then 
       wave([1,1,1],[app2,equ(left)]) then 
         wave([1,1],[length2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
  ]


PLANNING for lendouble COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(double) not present, so cannot be deleted
deleting def(double)...done
deleting theorem record for double1...done
deleting wave record for double1...done
deleting wave record for double1...done
deleting func_defeqn record for double1...done
deleting wave(double1)...done
deleting theorem record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting wave record for double2...done
deleting func_defeqn record for double2...done
deleting wave(double2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for lendouble...done
deleting thm(lendouble)...done
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(lenrev)...done
lenrev([])
==>x:pnat list=>length(rev(x))=length(x)in pnat list
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|lenrev([2])
|v0:pnat
|x:pnat list
|v1:ih(length(rev(x))=length(x)in pnat list)
|==>length(rev(``v0::{x}''<out>))=length(``v0::{x}''<out>)in pnat list
|SELECTED METHOD at depth 1: wave([2,1],[length2,equ(left)])
||lenrev([1,2])
||v0:pnat
||x:pnat list
||v1:ih(length(rev(x))=length(x)in pnat list)
||==>length(rev(``v0::{x}''<out>))=``s({length(x)})''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[rev2,equ(left)])
|||lenrev([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(length(rev(x))=length(x)in pnat list)
|||==>length(``app({rev(x)},v0::nil)''<out>)=``s({length(x)})''<out>in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- length(app(v1,v0::nil))=s(length(v1))in pnat list

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>length(app(v1,v0::nil))=s(length(v1))in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
|==>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::nil))=s(length(``v2::{v1}''<out>))in pnat list
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
||==>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::nil))=s(``s({length(v1)})''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
|||==>v0:pnat=>length(``v2::{app(v1,\v0/ ::nil)}''<out>)=s(``s({length(v1)})''<out>)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[length2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
||||==>v0:pnat=>``s({length(app(v1,\v0/ ::nil))})''<out> =s(``s({length(v1)})''<out>)in pnat list

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
||||==>v0:pnat=>``s({length(app(v1,\v0/ ::nil))})''<out> =``s({s(length(v1))})''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v3))
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat list)
|||||==>s(length(app(v1,v0::nil)))=s(length(app(v1,_185956::nil)))in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>length(app(nil,v0::nil))=s(length(nil))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>length(app(nil,v0::nil))=s(0)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>length(v0::nil)=s(0)in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>s(length(nil))=s(0)in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1],length1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>s(0)=s(0)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.......done
|||lenrev([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(length(rev(x))=length(x)in pnat list)
|||==>length(``app({rev(x)},v0::nil)''<out>)=``s({length(x)})''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||lenrev([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(length(rev(x))=length(x)in pnat list)
||||==>``s({length(rev(x))})''<out> =``s({length(x)})''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v1))
|||||lenrev([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(length(rev(x))=length(x)in pnat list)
|||||==>s(length(rev(x)))=s(length(rev(x)))in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lenrev([1])
|x:pnat list
|==>length(rev(nil))=length(nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],length1)
||lenrev([1,1])
||x:pnat list
||==>length(rev(nil))=0 in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],rev1)
|||lenrev([1,1,1])
|||x:pnat list
|||==>length(nil)=0 in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],length1)
||||lenrev([1,1,1,1])
||||x:pnat list
||||==>0=0 in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for lenrev

------------------------------------------------------------
lenrev:

[x:pnat list]

|- length(rev(x))=length(x)in pnat list

induction([v0::x],[x:pnat list]) then 
  [eval_def([2,1],length1) then 
     eval_def([1,1,1],rev1) then 
       eval_def([1,1],length1) then 
         elementary(...),
   wave([2,1],[length2,equ(left)]) then 
     wave([1,1,1],[rev2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         fertilize(weak(v1)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- length(app(v1,v0::nil))=s(length(v1))in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         eval_def([1,1,1],length1) then 
           elementary(...),
   wave([1,2,1],[length2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([1,1],[length2,equ(left)]) then 
         fertilize(weak(v3)) then 
           elementary(...)
  ]


PLANNING for lenrev COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for lenrev...done
deleting thm(lenrev)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(lenrevapp)...done
lenrevapp([])
==>x:pnat list=>y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|lenrevapp([2])
|v0:pnat
|x:pnat list
|v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
|==>y:pnat list=>length(rev(app(``v0::{x}''<out>,\y/)))=plus(length(``v0::{x}''<out>),length(\y/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lenrevapp([1,2])
||v0:pnat
||x:pnat list
||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
||==>y:pnat list=>length(rev(app(``v0::{x}''<out>,\y/)))=plus(``s({length(x)})''<out>,length(\y/))in pnat
||SELECTED METHOD at depth 2: wave([1,1,1,1],[app2,equ(left)])
|||lenrevapp([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
|||==>y:pnat list=>length(rev(``v0::{app(x,\y/)}''<out>))=plus(``s({length(x)})''<out>,length(\y/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[plus2,equ(left)])
||||lenrevapp([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
||||==>y:pnat list=>length(rev(``v0::{app(x,\y/)}''<out>))=``s({plus(length(x),length(\y/))})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[rev2,equ(left)])
|||||lenrevapp([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
|||||==>y:pnat list=>length(``app({rev(app(x,\y/))},v0::nil)''<out>)=``s({plus(length(x),length(\y/))})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- length(app(v1,v0::nil))=s(length(v1))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>length(app(v1,v0::nil))=s(length(v1))in pnat
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
|==>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::nil))=s(length(``v2::{v1}''<out>))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
||==>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::nil))=s(``s({length(v1)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
|||==>v0:pnat=>length(``v2::{app(v1,\v0/ ::nil)}''<out>)=s(``s({length(v1)})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[length2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
||||==>v0:pnat=>``s({length(app(v1,\v0/ ::nil))})''<out> =s(``s({length(v1)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
||||==>v0:pnat=>``s({length(app(v1,\v0/ ::nil))})''<out> =``s({s(length(v1))})''<out>in pnat
||||SELECTED METHOD at depth 4: fertilize(weak(v3))
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>length(app(v1,v0::nil))=s(length(v1))in pnat)
|||||==>s(length(app(v1,v0::nil)))=s(length(app(v1,_188023::nil)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>length(app(nil,v0::nil))=s(length(nil))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>length(app(nil,v0::nil))=s(0)in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>length(v0::nil)=s(0)in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>s(length(nil))=s(0)in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],length1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>s(0)=s(0)in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.......done
|||||lenrevapp([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
|||||==>y:pnat list=>length(``app({rev(app(x,\y/))},v0::nil)''<out>)=``s({plus(length(x),length(\y/))})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[lemma1,equ(left)])
||||||lenrevapp([1,1,1,1,1,2])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
||||||==>y:pnat list=>``s({length(rev(app(x,\y/)))})''<out> =``s({plus(length(x),length(\y/))})''<out>in pnat
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||lenrevapp([1,1,1,1,1,1,2])
|||||||v0:pnat
|||||||x:pnat list
|||||||v1:ih(y:pnat list=>length(rev(app(x,y)))=plus(length(x),length(y))in pnat)
|||||||==>s(length(rev(app(x,y))))=s(length(rev(app(x,y))))in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|lenrevapp([1])
|x:pnat list
|==>y:pnat list=>length(rev(app(nil,y)))=plus(length(nil),length(y))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lenrevapp([1,1])
||x:pnat list
||==>y:pnat list=>length(rev(app(nil,y)))=plus(0,length(y))in pnat
||SELECTED METHOD at depth 2: eval_def([2,1],plus1)
|||lenrevapp([1,1,1])
|||x:pnat list
|||==>y:pnat list=>length(rev(app(nil,y)))=length(y)in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1,1,1],app1)
||||lenrevapp([1,1,1,1])
||||x:pnat list
||||==>y:pnat list=>length(rev(y))=length(y)in pnat
||||SELECTED METHOD at depth 4: induction([v0::y],[y:pnat list])
|||||lenrevapp([2,1,1,1,1])
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(length(rev(y))=length(y)in pnat)
|||||x:pnat list
|||||==>length(rev(``v0::{y}''<out>))=length(``v0::{y}''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1],[length2,equ(left)])
||||||lenrevapp([1,2,1,1,1,1])
||||||v0:pnat
||||||y:pnat list
||||||v1:ih(length(rev(y))=length(y)in pnat)
||||||x:pnat list
||||||==>length(rev(``v0::{y}''<out>))=``s({length(y)})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1],[rev2,equ(left)])
|||||||lenrevapp([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||y:pnat list
|||||||v1:ih(length(rev(y))=length(y)in pnat)
|||||||x:pnat list
|||||||==>length(``app({rev(y)},v0::nil)''<out>)=``s({length(y)})''<out>in pnat
|||||||SELECTED METHOD at depth 7: wave([1,1],[lemma1,equ(left)])
||||||||lenrevapp([1,1,1,2,1,1,1,1])
||||||||v0:pnat
||||||||y:pnat list
||||||||v1:ih(length(rev(y))=length(y)in pnat)
||||||||x:pnat list
||||||||==>``s({length(rev(y))})''<out> =``s({length(y)})''<out>in pnat
||||||||SELECTED METHOD at depth 8: fertilize(weak(v1))
|||||||||lenrevapp([1,1,1,1,2,1,1,1,1])
|||||||||v0:pnat
|||||||||y:pnat list
|||||||||v1:ih(length(rev(y))=length(y)in pnat)
|||||||||x:pnat list
|||||||||==>s(length(rev(y)))=s(length(rev(y)))in pnat
|||||||||TERMINATING METHOD at depth 9: elementary(...)
|||||lenrevapp([1,1,1,1,1])
|||||y:pnat list
|||||x:pnat list
|||||==>length(rev(nil))=length(nil)in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1],length1)
||||||lenrevapp([1,1,1,1,1,1])
||||||y:pnat list
||||||x:pnat list
||||||==>length(rev(nil))=0 in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],rev1)
|||||||lenrevapp([1,1,1,1,1,1,1])
|||||||y:pnat list
|||||||x:pnat list
|||||||==>length(nil)=0 in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1],length1)
||||||||lenrevapp([1,1,1,1,1,1,1,1])
||||||||y:pnat list
||||||||x:pnat list
||||||||==>0=0 in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning complete for lenrevapp

------------------------------------------------------------
lenrevapp:

[x:pnat list,y:pnat list]

|- length(rev(app(x,y)))=plus(length(x),length(y))in pnat

induction([v0::x],[x:pnat list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([2,1],plus1) then 
       eval_def([1,1,1,1],app1) then 
         induction([v0::y],[y:pnat list]) then 
           [eval_def([2,1],length1) then 
              eval_def([1,1,1],rev1) then 
                eval_def([1,1],length1) then 
                  elementary(...),
            wave([2,1],[length2,equ(left)]) then 
              wave([1,1,1],[rev2,equ(left)]) then 
                wave([1,1],[lemma1,equ(left)]) then 
                  fertilize(weak(v1)) then 
                    elementary(...)
           ],
   wave([1,2,1],[length2,equ(left)]) then 
     wave([1,1,1,1],[app2,equ(left)]) then 
       wave([2,1],[plus2,equ(left)]) then 
         wave([1,1,1],[rev2,equ(left)]) then 
           wave([1,1],[lemma1,equ(left)]) then 
             fertilize(weak(v1)) then 
               elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- length(app(v1,v0::nil))=s(length(v1))in pnat

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         eval_def([1,1,1],length1) then 
           elementary(...),
   wave([1,2,1],[length2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([1,1],[length2,equ(left)]) then 
         fertilize(weak(v3)) then 
           elementary(...)
  ]


PLANNING for lenrevapp COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for lenrevapp...done
deleting thm(lenrevapp)...done
loading synth(qrev)...done
loading def(qrev)...done
loading eqn(qrev1)...done
loading eqn(qrev2)...done
 adding wave-rules for qrev1:..done
 adding wave-rules for qrev2:..done
 adding defeqn-record for qrev1...done 
 adding defeqn-record for qrev2...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(lenqrevapp)...done
lenqrevapp([])
==>x:pnat list=>y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|lenqrevapp([2])
|v0:pnat
|x:pnat list
|v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
|==>y:pnat list=>length(qrev(``v0::{x}''<out>,\y/))=plus(length(``v0::{x}''<out>),length(\y/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lenqrevapp([1,2])
||v0:pnat
||x:pnat list
||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
||==>y:pnat list=>length(qrev(``v0::{x}''<out>,\y/))=plus(``s({length(x)})''<out>,length(\y/))in pnat
||SELECTED METHOD at depth 2: wave([2,1],[plus2,equ(left)])
|||lenqrevapp([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
|||==>y:pnat list=>length(qrev(``v0::{x}''<out>,\y/))=``s({plus(length(x),length(\y/))})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[qrev2,equ(left)])
||||lenqrevapp([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
||||==>y:pnat list=>length(qrev(x,\``v0::{y}''<in>/))=``s({plus(length(x),length(\y/))})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat,y:pnat list]

|- s(plus(v1,length(y)))=plus(v1,length(v0::y))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat=>y:pnat list=>s(plus(v1,length(y)))=plus(v1,length(v0::y))in pnat
SELECTED METHOD at depth 0: eval_def([2,2,1],length2)
|lemma1([1])
|==>v0:pnat=>v1:pnat=>y:pnat list=>s(plus(v1,length(y)))=plus(v1,s(length(y)))in pnat
|SELECTED METHOD at depth 1: generalise(length(y),v2:pnat)
||lemma1([1,1])
||==>v2:pnat=>v0:pnat=>v1:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat
||SELECTED METHOD at depth 2: induction([s(v1)],[v1:pnat])
|||lemma1([2,1,1])
|||v1:pnat
|||v3:ih(v2:pnat=>v0:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat)
|||==>v2:pnat=>v0:pnat=>y:pnat list=>s(plus(``s({v1})''<out>,\v2/))=plus(``s({v1})''<out>,s(\v2/))in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[plus2,equ(left)])
||||lemma1([1,2,1,1])
||||v1:pnat
||||v3:ih(v2:pnat=>v0:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat)
||||==>v2:pnat=>v0:pnat=>y:pnat list=>s(``s({plus(v1,\v2/)})''<out>)=plus(``s({v1})''<out>,s(\v2/))in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[plus2,equ(left)])
|||||lemma1([1,1,2,1,1])
|||||v1:pnat
|||||v3:ih(v2:pnat=>v0:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat)
|||||==>v2:pnat=>v0:pnat=>y:pnat list=>s(``s({plus(v1,\v2/)})''<out>)=``s({plus(v1,s(\v2/))})''<out>in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||||lemma1([1,1,2,1,1])
|||||v1:pnat
|||||v3:ih(v2:pnat=>v0:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat)
|||||==>v2:pnat=>v0:pnat=>y:pnat list=>``s({s(plus(v1,\v2/))})''<out> =``s({plus(v1,s(\v2/))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,2,1,1])
||||||v1:pnat
||||||v3:ih(v2:pnat=>v0:pnat=>y:pnat list=>s(plus(v1,v2))=plus(v1,s(v2))in pnat)
||||||==>s(s(plus(v1,v2)))=s(s(plus(v1,v2)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|||lemma1([1,1,1])
|||v1:pnat
|||==>v2:pnat=>v0:pnat=>y:pnat list=>s(plus(0,v2))=plus(0,s(v2))in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1],plus1)
||||lemma1([1,1,1,1])
||||v1:pnat
||||==>v2:pnat=>v0:pnat=>y:pnat list=>s(plus(0,v2))=s(v2)in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],plus1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat
|||||==>v2:pnat=>v0:pnat=>y:pnat list=>s(v2)=s(v2)in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.........................done
||||lenqrevapp([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
||||==>y:pnat list=>length(qrev(x,\``v0::{y}''<in>/))=``s({plus(length(x),length(\y/))})''<out>in pnat

>>>>> INVOKING meta-ripple-direction CRITIC <<<<<

||||lenqrevapp([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
||||==>y:pnat list=>length(qrev(x,\``v0::{y}''<in>/))=``s({plus(length(x),length(\y/))})''<in>in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[lemma1,equ(left)])
|||||lenqrevapp([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>length(qrev(x,y))=plus(length(x),length(y))in pnat)
|||||==>y:pnat list=>length(qrev(x,\``v0::{y}''<in>/))=plus(length(x),length(\``_10663::{y}''<in>/))in pnat
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|lenqrevapp([1])
|x:pnat list
|==>y:pnat list=>length(qrev(nil,y))=plus(length(nil),length(y))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lenqrevapp([1,1])
||x:pnat list
||==>y:pnat list=>length(qrev(nil,y))=plus(0,length(y))in pnat
||SELECTED METHOD at depth 2: eval_def([2,1],plus1)
|||lenqrevapp([1,1,1])
|||x:pnat list
|||==>y:pnat list=>length(qrev(nil,y))=length(y)in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1,1],qrev1)
||||lenqrevapp([1,1,1,1])
||||x:pnat list
||||==>y:pnat list=>length(y)=length(y)in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for lenqrevapp

------------------------------------------------------------
lenqrevapp:

[x:pnat list,y:pnat list]

|- length(qrev(x,y))=plus(length(x),length(y))in pnat

induction([v0::x],[x:pnat list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([2,1],plus1) then 
       eval_def([1,1,1],qrev1) then 
         elementary(...),
   wave([1,2,1],[length2,equ(left)]) then 
     wave([2,1],[plus2,equ(left)]) then 
       wave([1,1,1],[qrev2,equ(left)]) then 
         wave([2,1],[lemma1,equ(left)]) then 
           fertilize(strong(v1))
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat,y:pnat list]

|- s(plus(v1,length(y)))=plus(v1,length(v0::y))in pnat

eval_def([2,2,1],length2) then 
  generalise(length(y),v2:pnat) then 
    induction([s(v1)],[v1:pnat]) then 
      [eval_def([2,1],plus1) then 
         eval_def([1,1,1],plus1) then 
           elementary(...),
       wave([1,1,1],[plus2,equ(left)]) then 
         wave([2,1],[plus2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
      ]


PLANNING for lenqrevapp COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for qrev...done
deleting synth(qrev)...done
deleting def(qrev)...done
deleting theorem record for qrev1...done
deleting wave record for qrev1...done
deleting wave record for qrev1...done
deleting func_defeqn record for qrev1...done
deleting wave(qrev1)...done
deleting theorem record for qrev2...done
deleting wave record for qrev2...done
deleting wave record for qrev2...done
deleting func_defeqn record for qrev2...done
deleting wave(qrev2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for lenqrevapp...done
deleting thm(lenqrevapp)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(revrev)...done
revrev([])
==>l:int list=>rev(rev(l))=l in int list
SELECTED METHOD at depth 0: induction([v0::l],[l:int list])
|revrev([2])
|v0:int
|l:int list
|v1:ih(rev(rev(l))=l in int list)
|==>rev(rev(``v0::{l}''<out>))=``v0::{l}''<out>in int list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||revrev([1,2])
||v0:int
||l:int list
||v1:ih(rev(rev(l))=l in int list)
||==>rev(``app({rev(l)},v0::nil)''<out>)=``v0::{l}''<out>in int list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:int,v1:int list]

|- rev(app(v1,v0::nil))=v0::rev(v1)in int list

saving thm(lemma1)...done
lemma1([])
==>v0:int=>v1:int list=>rev(app(v1,v0::nil))=v0::rev(v1)in int list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:int list])
|lemma1([2])
|v2:int
|v1:int list
|v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
|==>v0:int=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::rev(``v2::{v1}''<out>)in int list
|SELECTED METHOD at depth 1: wave([2,2,1],[rev2,equ(left)])
||lemma1([1,2])
||v2:int
||v1:int list
||v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
||==>v0:int=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::``app({rev(v1)},v2::nil)''<out>in int list
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:int
|||v1:int list
|||v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
|||==>v0:int=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=\v0/ ::``app({rev(v1)},v2::nil)''<out>in int list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v2:int
||||v1:int list
||||v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
||||==>v0:int=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=``app({\v0/ ::rev(v1)},v2::nil)''<out>in int list
||||SELECTED METHOD at depth 4: wave([1,1],[rev2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:int
|||||v1:int list
|||||v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
|||||==>v0:int=>``app({rev(app(v1,\v0/ ::nil))},v2::nil)''<out> =``app({\v0/ ::rev(v1)},v2::nil)''<out>in int list
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v2:int
||||||v1:int list
||||||v3:ih(v0:int=>rev(app(v1,v0::nil))=v0::rev(v1)in int list)
||||||==>app(rev(app(v1,v0::nil)),v2::nil)=app(rev(app(v1,v0::nil)),v2::nil)in int list
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:int list
|==>v0:int=>rev(app(nil,v0::nil))=v0::rev(nil)in int list
|SELECTED METHOD at depth 1: eval_def([2,2,1],rev1)
||lemma1([1,1])
||v1:int list
||==>v0:int=>rev(app(nil,v0::nil))=v0::nil in int list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:int list
|||==>v0:int=>rev(v0::nil)=v0::nil in int list
|||SELECTED METHOD at depth 3: eval_def([1,1],rev2)
||||lemma1([1,1,1,1])
||||v1:int list
||||==>v0:int=>app(rev(nil),v0::nil)=v0::nil in int list
||||SELECTED METHOD at depth 4: eval_def([1,1,1],rev1)
|||||lemma1([1,1,1,1,1])
|||||v1:int list
|||||==>v0:int=>app(nil,v0::nil)=v0::nil in int list
|||||SELECTED METHOD at depth 5: eval_def([1,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v1:int list
||||||==>v0:int=>v0::nil=v0::nil in int list
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma1:..............done
||revrev([1,2])
||v0:int
||l:int list
||v1:ih(rev(rev(l))=l in int list)
||==>rev(``app({rev(l)},v0::nil)''<out>)=``v0::{l}''<out>in int list
||SELECTED METHOD at depth 2: wave([1,1],[lemma1,equ(left)])
|||revrev([1,1,2])
|||v0:int
|||l:int list
|||v1:ih(rev(rev(l))=l in int list)
|||==>``v0::{rev(rev(l))}''<out> =``v0::{l}''<out>in int list
|||SELECTED METHOD at depth 3: fertilize(weak(v1))
||||revrev([1,1,1,2])
||||v0:int
||||l:int list
||||v1:ih(rev(rev(l))=l in int list)
||||==>v0::rev(rev(l))=v0::rev(rev(l))in int list
||||TERMINATING METHOD at depth 4: elementary(...)
|revrev([1])
|l:int list
|==>rev(rev(nil))=nil in int list
|SELECTED METHOD at depth 1: eval_def([1,1,1],rev1)
||revrev([1,1])
||l:int list
||==>rev(nil)=nil in int list
||SELECTED METHOD at depth 2: eval_def([1,1],rev1)
|||revrev([1,1,1])
|||l:int list
|||==>nil=nil in int list
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for revrev

------------------------------------------------------------
revrev:

[l:int list]

|- rev(rev(l))=l in int list

induction([v0::l],[l:int list]) then 
  [eval_def([1,1,1],rev1) then 
     eval_def([1,1],rev1) then 
       elementary(...),
   wave([1,1,1],[rev2,equ(left)]) then 
     wave([1,1],[lemma1,equ(left)]) then 
       fertilize(weak(v1)) then 
         elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:int,v1:int list]

|- rev(app(v1,v0::nil))=v0::rev(v1)in int list

induction([v2::v1],[v1:int list]) then 
  [eval_def([2,2,1],rev1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],rev2) then 
         eval_def([1,1,1],rev1) then 
           eval_def([1,1],app1) then 
             elementary(...),
   wave([2,2,1],[rev2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(right)]) then 
         wave([1,1],[rev2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
  ]


PLANNING for revrev COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for revrev...done
deleting thm(revrev)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(revapp1)...done
revapp1([])
==>x:pnat list=>y:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list
SELECTED METHOD at depth 0: induction([v0::y],[y:pnat list])
|revapp1([2])
|v0:pnat
|y:pnat list
|v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
|==>x:pnat list=>rev(app(rev(\x/),rev(``v0::{y}''<out>)))=app(``v0::{y}''<out>,\x/)in pnat list
|SELECTED METHOD at depth 1: wave([2,1,1,1],[rev2,equ(left)])
||revapp1([1,2])
||v0:pnat
||y:pnat list
||v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
||==>x:pnat list=>rev(app(rev(\x/),``app({rev(y)},v0::nil)''<out>))=app(``v0::{y}''<out>,\x/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||revapp1([1,1,2])
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
|||==>x:pnat list=>rev(app(rev(\x/),``app({rev(y)},v0::nil)''<out>))=``v0::{app(y,\x/)}''<out>in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,v2:pnat list]

|- rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list
SELECTED METHOD at depth 0: induction([v3::v1],[v1:pnat list])
|lemma1([2])
|v3:pnat
|v1:pnat list
|v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
|==>v0:pnat=>v2:pnat list=>rev(app(``v3::{v1}''<out>,app(\v2/,\v0/ ::nil)))=\v0/ ::rev(app(``v3::{v1}''<out>,\v2/))in pnat list
|SELECTED METHOD at depth 1: wave([1,2,2,1],[app2,equ(left)])
||lemma1([1,2])
||v3:pnat
||v1:pnat list
||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
||==>v0:pnat=>v2:pnat list=>rev(app(``v3::{v1}''<out>,app(\v2/,\v0/ ::nil)))=\v0/ ::rev(``v3::{app(v1,\v2/)}''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([2,2,1],[rev2,equ(left)])
|||lemma1([1,1,2])
|||v3:pnat
|||v1:pnat list
|||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
|||==>v0:pnat=>v2:pnat list=>rev(app(``v3::{v1}''<out>,app(\v2/,\v0/ ::nil)))=\v0/ ::``app({rev(app(v1,\v2/))},v3::nil)''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v3:pnat
||||v1:pnat list
||||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
||||==>v0:pnat=>v2:pnat list=>rev(``v3::{app(v1,app(\v2/,\v0/ ::nil))}''<out>)=\v0/ ::``app({rev(app(v1,\v2/))},v3::nil)''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([2,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
|||||==>v0:pnat=>v2:pnat list=>rev(``v3::{app(v1,app(\v2/,\v0/ ::nil))}''<out>)=``app({\v0/ ::rev(app(v1,\v2/))},v3::nil)''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1],[rev2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
||||||==>v0:pnat=>v2:pnat list=>``app({rev(app(v1,app(\v2/,\v0/ ::nil)))},v3::nil)''<out> =``app({\v0/ ::rev(app(v1,\v2/))},v3::nil)''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v4))
|||||||lemma1([1,1,1,1,1,1,2])
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(v0:pnat=>v2:pnat list=>rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list)
|||||||==>app(rev(app(v1,app(v2,v0::nil))),v3::nil)=app(rev(app(v1,app(v2,v0::nil))),v3::nil)in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>v2:pnat list=>rev(app(nil,app(v2,v0::nil)))=v0::rev(app(nil,v2))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,2,2,1],app1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>v2:pnat list=>rev(app(nil,app(v2,v0::nil)))=v0::rev(v2)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>v2:pnat list=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list
|||SELECTED METHOD at depth 3: induction([v3::v2],[v2:pnat list])
||||lemma1([2,1,1,1])
||||v3:pnat
||||v2:pnat list
||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
||||v1:pnat list
||||==>v0:pnat=>rev(app(``v3::{v2}''<out>,\v0/ ::nil))=\v0/ ::rev(``v3::{v2}''<out>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[rev2,equ(left)])
|||||lemma1([1,2,1,1,1])
|||||v3:pnat
|||||v2:pnat list
|||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
|||||v1:pnat list
|||||==>v0:pnat=>rev(app(``v3::{v2}''<out>,\v0/ ::nil))=\v0/ ::``app({rev(v2)},v3::nil)''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,1],[app2,equ(left)])
||||||lemma1([1,1,2,1,1,1])
||||||v3:pnat
||||||v2:pnat list
||||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
||||||v1:pnat list
||||||==>v0:pnat=>rev(``v3::{app(v2,\v0/ ::nil)}''<out>)=\v0/ ::``app({rev(v2)},v3::nil)''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1],[app2,equ(right)])
|||||||lemma1([1,1,1,2,1,1,1])
|||||||v3:pnat
|||||||v2:pnat list
|||||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
|||||||v1:pnat list
|||||||==>v0:pnat=>rev(``v3::{app(v2,\v0/ ::nil)}''<out>)=``app({\v0/ ::rev(v2)},v3::nil)''<out>in pnat list
|||||||SELECTED METHOD at depth 7: wave([1,1],[rev2,equ(left)])
||||||||lemma1([1,1,1,1,2,1,1,1])
||||||||v3:pnat
||||||||v2:pnat list
||||||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
||||||||v1:pnat list
||||||||==>v0:pnat=>``app({rev(app(v2,\v0/ ::nil))},v3::nil)''<out> =``app({\v0/ ::rev(v2)},v3::nil)''<out>in pnat list
||||||||SELECTED METHOD at depth 8: fertilize(weak(v4))
|||||||||lemma1([1,1,1,1,1,2,1,1,1])
|||||||||v3:pnat
|||||||||v2:pnat list
|||||||||v4:ih(v0:pnat=>rev(app(v2,v0::nil))=v0::rev(v2)in pnat list)
|||||||||v1:pnat list
|||||||||==>app(rev(app(v2,v0::nil)),v3::nil)=app(rev(app(v2,v0::nil)),v3::nil)in pnat list
|||||||||TERMINATING METHOD at depth 9: elementary(...)
||||lemma1([1,1,1,1])
||||v2:pnat list
||||v1:pnat list
||||==>v0:pnat=>rev(app(nil,v0::nil))=v0::rev(nil)in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,2,1],rev1)
|||||lemma1([1,1,1,1,1])
|||||v2:pnat list
|||||v1:pnat list
|||||==>v0:pnat=>rev(app(nil,v0::nil))=v0::nil in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v2:pnat list
||||||v1:pnat list
||||||==>v0:pnat=>rev(v0::nil)=v0::nil in pnat list
||||||SELECTED METHOD at depth 6: eval_def([1,1],rev2)
|||||||lemma1([1,1,1,1,1,1,1])
|||||||v2:pnat list
|||||||v1:pnat list
|||||||==>v0:pnat=>app(rev(nil),v0::nil)=v0::nil in pnat list
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1],rev1)
||||||||lemma1([1,1,1,1,1,1,1,1])
||||||||v2:pnat list
||||||||v1:pnat list
||||||||==>v0:pnat=>app(nil,v0::nil)=v0::nil in pnat list
||||||||SELECTED METHOD at depth 8: eval_def([1,1],app1)
|||||||||lemma1([1,1,1,1,1,1,1,1,1])
|||||||||v2:pnat list
|||||||||v1:pnat list
|||||||||==>v0:pnat=>v0::nil=v0::nil in pnat list
|||||||||TERMINATING METHOD at depth 9: elementary(...)
 adding wave-rules for lemma1:....................................................done
|||revapp1([1,1,2])
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
|||==>x:pnat list=>rev(app(rev(\x/),``app({rev(y)},v0::nil)''<out>))=``v0::{app(y,\x/)}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||revapp1([1,1,1,2])
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
||||==>x:pnat list=>``v0::{rev(app(rev(\x/),rev(y)))}''<out> =``v0::{app(y,\x/)}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v1))
|||||revapp1([1,1,1,1,2])
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat list=>rev(app(rev(x),rev(y)))=app(y,x)in pnat list)
|||||==>v0::rev(app(rev(x),rev(y)))=v0::rev(app(rev(x),rev(y)))in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|revapp1([1])
|y:pnat list
|==>x:pnat list=>rev(app(rev(x),rev(nil)))=app(nil,x)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],app1)
||revapp1([1,1])
||y:pnat list
||==>x:pnat list=>rev(app(rev(x),rev(nil)))=x in pnat list
||SELECTED METHOD at depth 2: eval_def([2,1,1,1],rev1)
|||revapp1([1,1,1])
|||y:pnat list
|||==>x:pnat list=>rev(app(rev(x),nil))=x in pnat list
|||SELECTED METHOD at depth 3: induction([v0::x],[x:pnat list])
||||revapp1([2,1,1,1])
||||v0:pnat
||||x:pnat list
||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
||||y:pnat list
||||==>rev(app(rev(``v0::{x}''<out>),nil))=``v0::{x}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1,1,1],[rev2,equ(left)])
|||||revapp1([1,2,1,1,1])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
|||||y:pnat list
|||||==>rev(app(``app({rev(x)},v0::nil)''<out>,nil))=``v0::{x}''<out>in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma2:

[v0:pnat,v1:pnat list]

|- app(app(v1,v0::nil),nil)=app(v1,app(nil,v0::nil))in pnat list

saving thm(lemma2)...done
lemma2([])
==>v0:pnat=>v1:pnat list=>app(app(v1,v0::nil),nil)=app(v1,app(nil,v0::nil))in pnat list
SELECTED METHOD at depth 0: eval_def([2,2,1],app1)
|lemma2([1])
|==>v0:pnat=>v1:pnat list=>app(app(v1,v0::nil),nil)=app(v1,v0::nil)in pnat list
|SELECTED METHOD at depth 1: generalise(app(v1,v0::nil),v2:pnat list)
||lemma2([1,1])
||==>v2:pnat list=>v0:pnat=>v1:pnat list=>app(v2,nil)=v2 in pnat list
||SELECTED METHOD at depth 2: induction([v3::v2],[v2:pnat list])
|||lemma2([2,1,1])
|||v3:pnat
|||v2:pnat list
|||v4:ih(v0:pnat=>v1:pnat list=>app(v2,nil)=v2 in pnat list)
|||==>v0:pnat=>v1:pnat list=>app(``v3::{v2}''<out>,nil)=``v3::{v2}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(left)])
||||lemma2([1,2,1,1])
||||v3:pnat
||||v2:pnat list
||||v4:ih(v0:pnat=>v1:pnat list=>app(v2,nil)=v2 in pnat list)
||||==>v0:pnat=>v1:pnat list=>``v3::{app(v2,nil)}''<out> =``v3::{v2}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v4))
|||||lemma2([1,1,2,1,1])
|||||v3:pnat
|||||v2:pnat list
|||||v4:ih(v0:pnat=>v1:pnat list=>app(v2,nil)=v2 in pnat list)
|||||==>v3::app(v2,nil)=v3::app(v2,nil)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|||lemma2([1,1,1])
|||v2:pnat list
|||==>v0:pnat=>v1:pnat list=>app(nil,nil)=nil in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app1)
||||lemma2([1,1,1,1])
||||v2:pnat list
||||==>v0:pnat=>v1:pnat list=>nil=nil in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma2:.................................done
|||||revapp1([1,2,1,1,1])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
|||||y:pnat list
|||||==>rev(app(``app({rev(x)},v0::nil)''<out>,nil))=``v0::{x}''<out>in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma3:

[v0:pnat,v1:pnat list]

|- rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list

saving thm(lemma3)...done
lemma3([])
==>v0:pnat=>v1:pnat list=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma3([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
|==>v0:pnat=>rev(app(app(``v2::{v1}''<out>,\v0/ ::nil),nil))=\v0/ ::rev(app(``v2::{v1}''<out>,nil))in pnat list
|SELECTED METHOD at depth 1: wave([1,2,2,1],[app2,equ(left)])
||lemma3([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
||==>v0:pnat=>rev(app(app(``v2::{v1}''<out>,\v0/ ::nil),nil))=\v0/ ::rev(``v2::{app(v1,nil)}''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([2,2,1],[rev2,equ(left)])
|||lemma3([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
|||==>v0:pnat=>rev(app(app(``v2::{v1}''<out>,\v0/ ::nil),nil))=\v0/ ::``app({rev(app(v1,nil))},v2::nil)''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[app2,equ(left)])
||||lemma3([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
||||==>v0:pnat=>rev(app(``v2::{app(v1,\v0/ ::nil)}''<out>,nil))=\v0/ ::``app({rev(app(v1,nil))},v2::nil)''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1,1],[app2,equ(left)])
|||||lemma3([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
|||||==>v0:pnat=>rev(``v2::{app(app(v1,\v0/ ::nil),nil)}''<out>)=\v0/ ::``app({rev(app(v1,nil))},v2::nil)''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(right)])
||||||lemma3([1,1,1,1,1,2])
||||||v2:pnat
||||||v1:pnat list
||||||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
||||||==>v0:pnat=>rev(``v2::{app(app(v1,\v0/ ::nil),nil)}''<out>)=``app({\v0/ ::rev(app(v1,nil))},v2::nil)''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1],[rev2,equ(left)])
|||||||lemma3([1,1,1,1,1,1,2])
|||||||v2:pnat
|||||||v1:pnat list
|||||||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
|||||||==>v0:pnat=>``app({rev(app(app(v1,\v0/ ::nil),nil))},v2::nil)''<out> =``app({\v0/ ::rev(app(v1,nil))},v2::nil)''<out>in pnat list
|||||||SELECTED METHOD at depth 7: fertilize(weak(v3))
||||||||lemma3([1,1,1,1,1,1,1,2])
||||||||v2:pnat
||||||||v1:pnat list
||||||||v3:ih(v0:pnat=>rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list)
||||||||==>app(rev(app(app(v1,v0::nil),nil)),v2::nil)=app(rev(app(app(v1,v0::nil),nil)),v2::nil)in pnat list
||||||||TERMINATING METHOD at depth 8: elementary(...)
|lemma3([1])
|v1:pnat list
|==>v0:pnat=>rev(app(app(nil,v0::nil),nil))=v0::rev(app(nil,nil))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,2,2,1],app1)
||lemma3([1,1])
||v1:pnat list
||==>v0:pnat=>rev(app(app(nil,v0::nil),nil))=v0::rev(nil)in pnat list
||SELECTED METHOD at depth 2: eval_def([2,2,1],rev1)
|||lemma3([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>rev(app(app(nil,v0::nil),nil))=v0::nil in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1,1,1],app1)
||||lemma3([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>rev(app(v0::nil,nil))=v0::nil in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1],app2)
|||||lemma3([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>rev(v0::app(nil,nil))=v0::nil in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,1],rev2)
||||||lemma3([1,1,1,1,1,1])
||||||v1:pnat list
||||||==>v0:pnat=>app(rev(app(nil,nil)),v0::nil)=v0::nil in pnat list
||||||SELECTED METHOD at depth 6: eval_def([1,1,1,1],app1)
|||||||lemma3([1,1,1,1,1,1,1])
|||||||v1:pnat list
|||||||==>v0:pnat=>app(rev(nil),v0::nil)=v0::nil in pnat list
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1],rev1)
||||||||lemma3([1,1,1,1,1,1,1,1])
||||||||v1:pnat list
||||||||==>v0:pnat=>app(nil,v0::nil)=v0::nil in pnat list
||||||||SELECTED METHOD at depth 8: eval_def([1,1],app1)
|||||||||lemma3([1,1,1,1,1,1,1,1,1])
|||||||||v1:pnat list
|||||||||==>v0:pnat=>v0::nil=v0::nil in pnat list
|||||||||TERMINATING METHOD at depth 9: elementary(...)
 adding wave-rules for lemma3:.........................................................................................................................done
|||||revapp1([1,2,1,1,1])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
|||||y:pnat list
|||||==>rev(app(``app({rev(x)},v0::nil)''<out>,nil))=``v0::{x}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1],[lemma3,equ(left)])
||||||revapp1([1,1,2,1,1,1])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
||||||y:pnat list
||||||==>``v0::{rev(app(rev(x),nil))}''<out> =``v0::{x}''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||revapp1([1,1,1,2,1,1,1])
|||||||v0:pnat
|||||||x:pnat list
|||||||v1:ih(rev(app(rev(x),nil))=x in pnat list)
|||||||y:pnat list
|||||||==>v0::rev(app(rev(x),nil))=v0::rev(app(rev(x),nil))in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
||||revapp1([1,1,1,1])
||||x:pnat list
||||y:pnat list
||||==>rev(app(rev(nil),nil))=nil in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],rev1)
|||||revapp1([1,1,1,1,1])
|||||x:pnat list
|||||y:pnat list
|||||==>rev(app(nil,nil))=nil in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],app1)
||||||revapp1([1,1,1,1,1,1])
||||||x:pnat list
||||||y:pnat list
||||||==>rev(nil)=nil in pnat list
||||||SELECTED METHOD at depth 6: eval_def([1,1],rev1)
|||||||revapp1([1,1,1,1,1,1,1])
|||||||x:pnat list
|||||||y:pnat list
|||||||==>nil=nil in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
Planning complete for revapp1

------------------------------------------------------------
revapp1:

[x:pnat list,y:pnat list]

|- rev(app(rev(x),rev(y)))=app(y,x)in pnat list

induction([v0::y],[y:pnat list]) then 
  [eval_def([2,1],app1) then 
     eval_def([2,1,1,1],rev1) then 
       induction([v0::x],[x:pnat list]) then 
         [eval_def([1,1,1,1],rev1) then 
            eval_def([1,1,1],app1) then 
              eval_def([1,1],rev1) then 
                elementary(...),
          wave([1,1,1,1],[rev2,equ(left)]) then 
            wave([1,1],[lemma3,equ(left)]) then 
              fertilize(weak(v1)) then 
                elementary(...)
         ],
   wave([2,1,1,1],[rev2,equ(left)]) then 
     wave([2,1],[app2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         fertilize(weak(v1)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,v2:pnat list]

|- rev(app(v1,app(v2,v0::nil)))=v0::rev(app(v1,v2))in pnat list

induction([v3::v1],[v1:pnat list]) then 
  [eval_def([1,2,2,1],app1) then 
     eval_def([1,1,1],app1) then 
       induction([v3::v2],[v2:pnat list]) then 
         [eval_def([2,2,1],rev1) then 
            eval_def([1,1,1],app1) then 
              eval_def([1,1],rev2) then 
                eval_def([1,1,1],rev1) then 
                  eval_def([1,1],app1) then 
                    elementary(...),
          wave([2,2,1],[rev2,equ(left)]) then 
            wave([1,1,1],[app2,equ(left)]) then 
              wave([2,1],[app2,equ(right)]) then 
                wave([1,1],[rev2,equ(left)]) then 
                  fertilize(weak(v4)) then 
                    elementary(...)
         ],
   wave([1,2,2,1],[app2,equ(left)]) then 
     wave([2,2,1],[rev2,equ(left)]) then 
       wave([1,1,1],[app2,equ(left)]) then 
         wave([2,1],[app2,equ(right)]) then 
           wave([1,1],[rev2,equ(left)]) then 
             fertilize(weak(v4)) then 
               elementary(...)
  ]

------------------------------------------------------------
lemma2:

[v0:pnat,v1:pnat list]

|- app(app(v1,v0::nil),nil)=app(v1,app(nil,v0::nil))in pnat list

eval_def([2,2,1],app1) then 
  generalise(app(v1,v0::nil),v2:pnat list) then 
    induction([v3::v2],[v2:pnat list]) then 
      [eval_def([1,1],app1) then 
         elementary(...),
       wave([1,1],[app2,equ(left)]) then 
         fertilize(weak(v4)) then 
           elementary(...)
      ]

------------------------------------------------------------
lemma3:

[v0:pnat,v1:pnat list]

|- rev(app(app(v1,v0::nil),nil))=v0::rev(app(v1,nil))in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,2,2,1],app1) then 
     eval_def([2,2,1],rev1) then 
       eval_def([1,1,1,1],app1) then 
         eval_def([1,1,1],app2) then 
           eval_def([1,1],rev2) then 
             eval_def([1,1,1,1],app1) then 
               eval_def([1,1,1],rev1) then 
                 eval_def([1,1],app1) then 
                   elementary(...),
   wave([1,2,2,1],[app2,equ(left)]) then 
     wave([2,2,1],[rev2,equ(left)]) then 
       wave([1,1,1,1],[app2,equ(left)]) then 
         wave([1,1,1],[app2,equ(left)]) then 
           wave([2,1],[app2,equ(right)]) then 
             wave([1,1],[rev2,equ(left)]) then 
               fertilize(weak(v3)) then 
                 elementary(...)
  ]


PLANNING for revapp1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting thm(lemma2)...done
deleting theorem record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting wave record for lemma3...done
deleting thm(lemma3)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for revapp1...done
deleting thm(revapp1)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading synth(qrev)...done
loading def(qrev)...done
loading eqn(qrev1)...done
loading eqn(qrev2)...done
 adding wave-rules for qrev1:..done
 adding wave-rules for qrev2:..done
 adding defeqn-record for qrev1...done 
 adding defeqn-record for qrev2...done 
loading thm(revqrev)...done
revqrev([])
==>l:pnat list=>m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|revqrev([2])
|v0:pnat
|l:pnat list
|v1:ih(m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list)
|==>m:pnat list=>app(rev(``v0::{l}''<out>),\m/)=qrev(``v0::{l}''<out>,\m/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||revqrev([1,2])
||v0:pnat
||l:pnat list
||v1:ih(m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list)
||==>m:pnat list=>app(``app({rev(l)},v0::nil)''<out>,\m/)=qrev(``v0::{l}''<out>,\m/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||revqrev([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list)
|||==>m:pnat list=>app(``app({rev(l)},v0::nil)''<out>,\m/)=qrev(l,\``v0::{m}''<in>/)in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[m:pnat list,v0:pnat,v1:pnat list]

|- app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list

saving thm(lemma1)...done
lemma1([])
==>m:pnat list=>v0:pnat=>v1:pnat list=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(m:pnat list=>v0:pnat=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list)
|==>m:pnat list=>v0:pnat=>app(app(``v2::{v1}''<out>,\v0/ ::nil),\m/)=app(``v2::{v1}''<out>,\v0/ ::\m/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(m:pnat list=>v0:pnat=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list)
||==>m:pnat list=>v0:pnat=>app(``v2::{app(v1,\v0/ ::nil)}''<out>,\m/)=app(``v2::{v1}''<out>,\v0/ ::\m/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(m:pnat list=>v0:pnat=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list)
|||==>m:pnat list=>v0:pnat=>app(``v2::{app(v1,\v0/ ::nil)}''<out>,\m/)=``v2::{app(v1,\v0/ ::\m/)}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(m:pnat list=>v0:pnat=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list)
||||==>m:pnat list=>v0:pnat=>``v2::{app(app(v1,\v0/ ::nil),\m/)}''<out> =``v2::{app(v1,\v0/ ::\m/)}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v3))
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(m:pnat list=>v0:pnat=>app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list)
|||||==>v2::app(app(v1,v0::nil),m)=v2::app(app(v1,v0::nil),m)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma1([1])
|v1:pnat list
|==>m:pnat list=>v0:pnat=>app(app(nil,v0::nil),m)=app(nil,v0::m)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],app1)
||lemma1([1,1])
||v1:pnat list
||==>m:pnat list=>v0:pnat=>app(app(nil,v0::nil),m)=v0::m in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>m:pnat list=>v0:pnat=>app(v0::nil,m)=v0::m in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>m:pnat list=>v0:pnat=>v0::app(nil,m)=v0::m in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,1,1],app1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>m:pnat list=>v0:pnat=>v0::m=v0::m in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.....done
|||revqrev([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list)
|||==>m:pnat list=>app(``app({rev(l)},v0::nil)''<out>,\m/)=qrev(l,\``v0::{m}''<in>/)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||revqrev([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(m:pnat list=>app(rev(l),m)=qrev(l,m)in pnat list)
||||==>m:pnat list=>app(rev(l),\``v0::{m}''<in>/)=qrev(l,\``v0::{m}''<in>/)in pnat list
||||TERMINATING METHOD at depth 4: fertilize(strong(v1))
|revqrev([1])
|l:pnat list
|==>m:pnat list=>app(rev(nil),m)=qrev(nil,m)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],qrev1)
||revqrev([1,1])
||l:pnat list
||==>m:pnat list=>app(rev(nil),m)=m in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],rev1)
|||revqrev([1,1,1])
|||l:pnat list
|||==>m:pnat list=>app(nil,m)=m in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app1)
||||revqrev([1,1,1,1])
||||l:pnat list
||||==>m:pnat list=>m=m in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for revqrev

------------------------------------------------------------
revqrev:

[l:pnat list,m:pnat list]

|- app(rev(l),m)=qrev(l,m)in pnat list

induction([v0::l],[l:pnat list]) then 
  [eval_def([2,1],qrev1) then 
     eval_def([1,1,1],rev1) then 
       eval_def([1,1],app1) then 
         elementary(...),
   wave([1,1,1],[rev2,equ(left)]) then 
     wave([2,1],[qrev2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         fertilize(strong(v1))
  ]

------------------------------------------------------------
lemma1:

[m:pnat list,v0:pnat,v1:pnat list]

|- app(app(v1,v0::nil),m)=app(v1,v0::m)in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],app2) then 
         eval_def([2,1,1],app1) then 
           elementary(...),
   wave([1,1,1],[app2,equ(left)]) then 
     wave([2,1],[app2,equ(left)]) then 
       wave([1,1],[app2,equ(left)]) then 
         fertilize(weak(v3)) then 
           elementary(...)
  ]


PLANNING for revqrev COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for qrev...done
deleting synth(qrev)...done
deleting def(qrev)...done
deleting theorem record for qrev1...done
deleting wave record for qrev1...done
deleting wave record for qrev1...done
deleting func_defeqn record for qrev1...done
deleting wave(qrev1)...done
deleting theorem record for qrev2...done
deleting wave record for qrev2...done
deleting wave record for qrev2...done
deleting func_defeqn record for qrev2...done
deleting wave(qrev2)...done
deleting theorem record for revqrev...done
deleting thm(revqrev)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading scheme(twos)...done
loading synth(half)...done
loading synth(half)...done
loading def(half)...done
loading eqn(half1)...done
loading eqn(half2)...done
loading eqn(half3)...done
 adding wave-rules for half1:..done
 adding wave-rules for half2:..done
 adding wave-rules for half3:..............done
 adding defeqn-record for half1...done 
 adding defeqn-record for half2...done 
 adding defeqn-record for half3...done 
loading thm(cnc_s)...done
 adding wave-rules for cnc_s:done
 adding cancel-record for cnc_s...done
loading thm(cnc_half)...done
 adding wave-rules for cnc_half:done
 adding cancel-record for cnc_half...done
loading thm(halfplus1)...done
halfplus1([])
==>x:pnat=>half(plus(x,x))=x in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|halfplus1([2])
|x:pnat
|v0:ih(half(plus(x,x))=x in pnat)
|==>half(plus(``s({x})''<out>,``s({x})''<out>))=``s({x})''<out>in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[plus2,equ(left)])
||halfplus1([1,2])
||x:pnat
||v0:ih(half(plus(x,x))=x in pnat)
||==>half(``s({plus(x,``s({x})''<out>)})''<out>)=``s({x})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=s(plus(v0,x))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat
SELECTED METHOD at depth 0: induction([s(v0)],[v0:pnat])
|lemma1([2])
|v0:pnat
|v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(plus(``s({v0})''<out>,\x/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||v0:pnat
||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(``s({plus(v0,\x/)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =s(``s({plus(v0,\x/)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =``s({s(plus(v0,\x/))})''<out>in pnat
|||SELECTED METHOD at depth 3: fertilize(weak(v1))
||||lemma1([1,1,1,2])
||||v0:pnat
||||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||||==>s(plus(v0,s(x)))=s(plus(v0,s(x)))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
|lemma1([1])
|v0:pnat
|==>x:pnat=>plus(0,s(x))=s(plus(0,x))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],plus1)
||lemma1([1,1])
||v0:pnat
||==>x:pnat=>s(x)=s(plus(0,x))in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],plus1)
|||lemma1([1,1,1])
|||v0:pnat
|||==>x:pnat=>s(x)=s(x)in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
 adding wave-rules for lemma1:.................done
||halfplus1([1,2])
||x:pnat
||v0:ih(half(plus(x,x))=x in pnat)
||==>half(``s({plus(x,``s({x})''<out>)})''<out>)=``s({x})''<out>in pnat
||SELECTED METHOD at depth 2: wave([1,1,1,1],[lemma1,equ(left)])
|||halfplus1([1,1,2])
|||x:pnat
|||v0:ih(half(plus(x,x))=x in pnat)
|||==>half(``s({``s({plus(x,x)})''<out>})''<out>)=``s({x})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[half3,equ(left)])
||||halfplus1([1,1,1,2])
||||x:pnat
||||v0:ih(half(plus(x,x))=x in pnat)
||||==>``s({half(plus(x,x))})''<out> =``s({x})''<out>in pnat
||||SELECTED METHOD at depth 4: fertilize(weak(v0))
|||||halfplus1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(half(plus(x,x))=x in pnat)
|||||==>s(half(plus(x,x)))=s(half(plus(x,x)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
|halfplus1([1])
|x:pnat
|==>half(plus(0,0))=0 in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,1],plus1)
||halfplus1([1,1])
||x:pnat
||==>half(0)=0 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1],half1)
|||halfplus1([1,1,1])
|||x:pnat
|||==>0=0 in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for halfplus1

------------------------------------------------------------
halfplus1:

[x:pnat]

|- half(plus(x,x))=x in pnat

induction([s(x)],[x:pnat]) then 
  [eval_def([1,1,1],plus1) then 
     eval_def([1,1],half1) then 
       elementary(...),
   wave([1,1,1],[plus2,equ(left)]) then 
     wave([1,1,1,1],[lemma1,equ(left)]) then 
       wave([1,1],[half3,equ(left)]) then 
         fertilize(weak(v0)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=s(plus(v0,x))in pnat

induction([s(v0)],[v0:pnat]) then 
  [eval_def([1,1],plus1) then 
     eval_def([1,2,1],plus1) then 
       elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1],[plus2,equ(left)]) then 
       fertilize(weak(v1)) then 
         elementary(...)
  ]


PLANNING for halfplus1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for half...done
deleting synth(half)...done
deleting def(half)...done
deleting theorem record for half1...done
deleting wave record for half1...done
deleting wave record for half1...done
deleting func_defeqn record for half1...done
deleting wave(half1)...done
deleting theorem record for half2...done
deleting wave record for half2...done
deleting wave record for half2...done
deleting func_defeqn record for half2...done
deleting wave(half2)...done
deleting theorem record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting func_defeqn record for half3...done
deleting wave(half3)...done
deleting theorem record for halfplus1...done
deleting thm(halfplus1)...done
loading synth(even)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(evenplus1)...done
evenplus1([])
==>x:pnat=>even(plus(x,x))
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|evenplus1([2])
|x:pnat
|v0:ih(even(plus(x,x)))
|==>even(plus(``s({x})''<out>,``s({x})''<out>))
|SELECTED METHOD at depth 1: wave([1],[plus2,equ(left)])
||evenplus1([1,2])
||x:pnat
||v0:ih(even(plus(x,x)))
||==>even(``s({plus(x,``s({x})''<out>)})''<out>)

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=M1(plus(v0,x),v0,x)in pnat

saving thm(lemma1)...done
 adding wave-rules for lemma1:..........................done
||evenplus1([1,2])
||x:pnat
||v0:ih(even(plus(x,x)))
||==>even(``s({plus(x,``s({x})''<out>)})''<out>)
||SELECTED METHOD at depth 2: wave([1,1],[lemma1,equ(left)])
|||evenplus1([1,1,2])
|||x:pnat
|||v0:ih(even(plus(x,x)))
|||==>even(``s({"M1({plus(x,x)},x,x)"<out>})''<out>)
|||SELECTED METHOD at depth 3: wave([],[even3,equ(left)])
||||evenplus1([1,1,1,2])
||||x:pnat
||||v0:ih(even(plus(x,x)))
||||==>even("Var1({plus(x,x)},x,x)"<out>)
||||TERMINATING METHOD at depth 4: fertilize(strong(v0))
Planning partially complete for evenplus1

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat
SELECTED METHOD at depth 0: induction([s(v0)],[v0:pnat])
|lemma1([2])
|v0:pnat
|v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(plus(``s({v0})''<out>,\x/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||v0:pnat
||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||==>x:pnat=>plus(``s({v0})''<out>,s(\x/))=s(``s({plus(v0,\x/)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =s(``s({plus(v0,\x/)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||lemma1([1,1,2])
|||v0:pnat
|||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
|||==>x:pnat=>``s({plus(v0,s(\x/))})''<out> =``s({s(plus(v0,\x/))})''<out>in pnat
|||SELECTED METHOD at depth 3: fertilize(weak(v1))
||||lemma1([1,1,1,2])
||||v0:pnat
||||v1:ih(x:pnat=>plus(v0,s(x))=s(plus(v0,x))in pnat)
||||==>s(plus(v0,s(x)))=s(plus(v0,s(x)))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
|lemma1([1])
|v0:pnat
|==>x:pnat=>plus(0,s(x))=s(plus(0,x))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],plus1)
||lemma1([1,1])
||v0:pnat
||==>x:pnat=>s(x)=s(plus(0,x))in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],plus1)
|||lemma1([1,1,1])
|||v0:pnat
|||==>x:pnat=>s(x)=s(x)in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
 adding wave-rules for lemma1:.................done
|evenplus1([1])
|x:pnat
|==>even(plus(0,0))
|SELECTED METHOD at depth 1: eval_def([1],plus1)
||evenplus1([1,1])
||x:pnat
||==>even(0)
||SELECTED METHOD at depth 2: eval_def([],even1)
|||evenplus1([1,1,1])
|||x:pnat
|||==>{true}
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for evenplus1

------------------------------------------------------------
evenplus1:

[x:pnat]

|- even(plus(x,x))

induction([s(x)],[x:pnat]) then 
  [eval_def([1],plus1) then 
     eval_def([],even1) then 
       elementary(...),
   wave([1],[plus2,equ(left)]) then 
     wave([1,1],[lemma1,equ(left)]) then 
       wave([],[even3,equ(left)]) then 
         fertilize(strong(v0))
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,x:pnat]

|- plus(v0,s(x))=s(plus(v0,x))in pnat

induction([s(v0)],[v0:pnat]) then 
  [eval_def([1,1],plus1) then 
     eval_def([1,2,1],plus1) then 
       elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1],[plus2,equ(left)]) then 
       fertilize(weak(v1)) then 
         elementary(...)
  ]


PLANNING for evenplus1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for evenplus1...done
deleting thm(evenplus1)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(revapp4)...done
revapp4([])
==>x:pnat list=>y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|revapp4([2])
|v0:pnat
|x:pnat list
|v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
|==>y:pnat list=>rev(rev(app(``v0::{x}''<out>,\y/)))=app(rev(rev(``v0::{x}''<out>)),rev(rev(\y/)))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,2,1],[rev2,equ(left)])
||revapp4([1,2])
||v0:pnat
||x:pnat list
||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
||==>y:pnat list=>rev(rev(app(``v0::{x}''<out>,\y/)))=app(rev(``app({rev(x)},v0::nil)''<out>),rev(rev(\y/)))in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1,1],[app2,equ(left)])
|||revapp4([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
|||==>y:pnat list=>rev(rev(``v0::{app(x,\y/)}''<out>))=app(rev(``app({rev(x)},v0::nil)''<out>),rev(rev(\y/)))in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[rev2,equ(left)])
||||revapp4([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
||||==>y:pnat list=>rev(``app({rev(app(x,\y/))},v0::nil)''<out>)=app(rev(``app({rev(x)},v0::nil)''<out>),rev(rev(\y/)))in pnat list

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- rev(app(v1,v0::nil))=M2(rev(v1),v0,v1)in pnat list

saving thm(lemma1)...done
 adding wave-rules for lemma1:..............done
||||revapp4([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
||||==>y:pnat list=>rev(``app({rev(app(x,\y/))},v0::nil)''<out>)=app(rev(``app({rev(x)},v0::nil)''<out>),rev(rev(\y/)))in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,1],[lemma1,equ(left)])
|||||revapp4([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
|||||==>y:pnat list=>rev(``app({rev(app(x,\y/))},v0::nil)''<out>)=app("M2({rev(rev(x))},v0,rev(x))"<out>,rev(rev(\y/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1],[lemma1,equ(left)])
||||||revapp4([1,1,1,1,1,2])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
||||||==>y:pnat list=>"M2({rev(rev(app(x,\y/)))},v0,rev(app(x,\y/)))"<out> =app("M2({rev(rev(x))},v0,rev(x))"<out>,rev(rev(\y/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1],[app2,equ(left)])
|||||||revapp4([1,1,1,1,1,1,2])
|||||||v0:pnat
|||||||x:pnat list
|||||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
|||||||==>y:pnat list=>``v0::{rev(rev(app(x,\y/)))}''<out> =``v0::{app(rev(rev(x)),rev(rev(\y/)))}''<out>in pnat list
|||||||SELECTED METHOD at depth 7: fertilize(weak(v1))
||||||||revapp4([1,1,1,1,1,1,1,2])
||||||||v0:pnat
||||||||x:pnat list
||||||||v1:ih(y:pnat list=>rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list)
||||||||==>v0::rev(rev(app(x,y)))=v0::rev(rev(app(x,y)))in pnat list
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning partially complete for revapp4

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|==>v0:pnat=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::rev(``v2::{v1}''<out>)in pnat list
|SELECTED METHOD at depth 1: wave([2,2,1],[rev2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||==>v0:pnat=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::``app({rev(v1)},v2::nil)''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|||==>v0:pnat=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=\v0/ ::``app({rev(v1)},v2::nil)''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||||==>v0:pnat=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=``app({\v0/ ::rev(v1)},v2::nil)''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[rev2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|||||==>v0:pnat=>``app({rev(app(v1,\v0/ ::nil))},v2::nil)''<out> =``app({\v0/ ::rev(v1)},v2::nil)''<out>in pnat list
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||v1:pnat list
||||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||||||==>app(rev(app(v1,v0::nil)),v2::nil)=app(rev(app(v1,v0::nil)),v2::nil)in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>rev(app(nil,v0::nil))=v0::rev(nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,2,1],rev1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>rev(app(nil,v0::nil))=v0::nil in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>rev(v0::nil)=v0::nil in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],rev2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>app(rev(nil),v0::nil)=v0::nil in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1],rev1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>app(nil,v0::nil)=v0::nil in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v1:pnat list
||||||==>v0:pnat=>v0::nil=v0::nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma1:..............done
|revapp4([1])
|x:pnat list
|==>y:pnat list=>rev(rev(app(nil,y)))=app(rev(rev(nil)),rev(rev(y)))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],rev1)
||revapp4([1,1])
||x:pnat list
||==>y:pnat list=>rev(rev(app(nil,y)))=app(rev(nil),rev(rev(y)))in pnat list
||SELECTED METHOD at depth 2: eval_def([1,2,1],rev1)
|||revapp4([1,1,1])
|||x:pnat list
|||==>y:pnat list=>rev(rev(app(nil,y)))=app(nil,rev(rev(y)))in pnat list
|||SELECTED METHOD at depth 3: eval_def([2,1],app1)
||||revapp4([1,1,1,1])
||||x:pnat list
||||==>y:pnat list=>rev(rev(app(nil,y)))=rev(rev(y))in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],app1)
|||||revapp4([1,1,1,1,1])
|||||x:pnat list
|||||==>y:pnat list=>rev(rev(y))=rev(rev(y))in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
Planning complete for revapp4

------------------------------------------------------------
revapp4:

[x:pnat list,y:pnat list]

|- rev(rev(app(x,y)))=app(rev(rev(x)),rev(rev(y)))in pnat list

induction([v0::x],[x:pnat list]) then 
  [eval_def([1,1,2,1],rev1) then 
     eval_def([1,2,1],rev1) then 
       eval_def([2,1],app1) then 
         eval_def([1,1,1,1],app1) then 
           elementary(...),
   wave([1,1,2,1],[rev2,equ(left)]) then 
     wave([1,1,1,1],[app2,equ(left)]) then 
       wave([1,1,1],[rev2,equ(left)]) then 
         wave([1,2,1],[lemma1,equ(left)]) then 
           wave([1,1],[lemma1,equ(left)]) then 
             wave([2,1],[app2,equ(left)]) then 
               fertilize(weak(v1)) then 
                 elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- rev(app(v1,v0::nil))=v0::rev(v1)in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([2,2,1],rev1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],rev2) then 
         eval_def([1,1,1],rev1) then 
           eval_def([1,1],app1) then 
             elementary(...),
   wave([2,2,1],[rev2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(right)]) then 
         wave([1,1],[rev2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
  ]


PLANNING for revapp4 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for revapp4...done
deleting thm(revapp4)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(revapp2)...done
revapp2([])
==>x:pnat list=>y:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list
SELECTED METHOD at depth 0: induction([v0::y],[y:pnat list])
|revapp2([2])
|v0:pnat
|y:pnat list
|v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
|==>x:pnat list=>rev(app(rev(``v0::{y}''<out>),\x/))=app(rev(\x/),``v0::{y}''<out>)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1,1],[rev2,equ(left)])
||revapp2([1,2])
||v0:pnat
||y:pnat list
||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
||==>x:pnat list=>rev(app(``app({rev(y)},v0::nil)''<out>,\x/))=app(rev(\x/),``v0::{y}''<out>)in pnat list

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,y:pnat list]

|- app(v1,v0::y)=app(M3(v0,v1,y),y)in pnat list

saving thm(lemma1)...done
 adding wave-rules for lemma1:.done
||revapp2([1,2])
||v0:pnat
||y:pnat list
||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
||==>x:pnat list=>rev(app(``app({rev(y)},v0::nil)''<out>,\x/))=app(rev(\x/),``v0::{y}''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[lemma1,equ(left)])
|||revapp2([1,1,2])
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
|||==>x:pnat list=>rev(app(``app({rev(y)},v0::nil)''<out>,\x/))=app("M3(v0,{rev(\x/)},y)"<in>,y)in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1],[rev2,equ(right)])
||||revapp2([1,1,1,2])
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
||||==>x:pnat list=>rev(app(``app({rev(y)},v0::nil)''<out>,\x/))=app(rev(\``v0::{x}''<in>/),y)in pnat list

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma2:

[v0:pnat,v1:pnat list,x:pnat list]

|- app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list

saving thm(lemma2)...done
lemma2([])
==>v0:pnat=>v1:pnat list=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma2([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list)
|==>v0:pnat=>x:pnat list=>app(app(``v2::{v1}''<out>,\v0/ ::nil),\x/)=app(``v2::{v1}''<out>,\v0/ ::\x/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[app2,equ(left)])
||lemma2([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list)
||==>v0:pnat=>x:pnat list=>app(``v2::{app(v1,\v0/ ::nil)}''<out>,\x/)=app(``v2::{v1}''<out>,\v0/ ::\x/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma2([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list)
|||==>v0:pnat=>x:pnat list=>app(``v2::{app(v1,\v0/ ::nil)}''<out>,\x/)=``v2::{app(v1,\v0/ ::\x/)}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(left)])
||||lemma2([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list)
||||==>v0:pnat=>x:pnat list=>``v2::{app(app(v1,\v0/ ::nil),\x/)}''<out> =``v2::{app(v1,\v0/ ::\x/)}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v3))
|||||lemma2([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>x:pnat list=>app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list)
|||||==>v2::app(app(v1,v0::nil),x)=v2::app(app(v1,v0::nil),x)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma2([1])
|v1:pnat list
|==>v0:pnat=>x:pnat list=>app(app(nil,v0::nil),x)=app(nil,v0::x)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],app1)
||lemma2([1,1])
||v1:pnat list
||==>v0:pnat=>x:pnat list=>app(app(nil,v0::nil),x)=v0::x in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma2([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>x:pnat list=>app(v0::nil,x)=v0::x in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app2)
||||lemma2([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>x:pnat list=>v0::app(nil,x)=v0::x in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,1,1],app1)
|||||lemma2([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>x:pnat list=>v0::x=v0::x in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma2:.....done
||||revapp2([1,1,1,2])
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
||||==>x:pnat list=>rev(app(``app({rev(y)},v0::nil)''<out>,\x/))=app(rev(\``v0::{x}''<in>/),y)in pnat list
||||SELECTED METHOD at depth 4: wave([1,1,1],[lemma2,equ(left)])
|||||revapp2([1,1,1,1,2])
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat list=>rev(app(rev(y),x))=app(rev(x),y)in pnat list)
|||||==>x:pnat list=>rev(app(rev(y),\``v0::{x}''<in>/))=app(rev(\``v0::{x}''<in>/),y)in pnat list
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
Planning partially complete for revapp2

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list)
|==>v0:pnat=>y:pnat list=>app(``v2::{v1}''<out>,\v0/ ::\y/)=app(app(``v2::{v1}''<out>,\v0/ ::nil),\y/)in pnat list
|SELECTED METHOD at depth 1: wave([1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list)
||==>v0:pnat=>y:pnat list=>app(``v2::{v1}''<out>,\v0/ ::\y/)=app(``v2::{app(v1,\v0/ ::nil)}''<out>,\y/)in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list)
|||==>v0:pnat=>y:pnat list=>``v2::{app(v1,\v0/ ::\y/)}''<out> =app(``v2::{app(v1,\v0/ ::nil)}''<out>,\y/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list)
||||==>v0:pnat=>y:pnat list=>``v2::{app(v1,\v0/ ::\y/)}''<out> =``v2::{app(app(v1,\v0/ ::nil),\y/)}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v3))
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>y:pnat list=>app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list)
|||||==>v2::app(v1,v0::y)=v2::app(v1,v0::y)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>y:pnat list=>app(nil,v0::y)=app(app(nil,v0::nil),y)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1],app1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>y:pnat list=>v0::y=app(app(nil,v0::nil),y)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,2,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>y:pnat list=>v0::y=app(v0::nil,y)in pnat list
|||SELECTED METHOD at depth 3: eval_def([2,1],app2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>y:pnat list=>v0::y=v0::app(nil,y)in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,2,1],app1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>y:pnat list=>v0::y=v0::y in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.....done
|revapp2([1])
|y:pnat list
|==>x:pnat list=>rev(app(rev(nil),x))=app(rev(x),nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,1,1],rev1)
||revapp2([1,1])
||y:pnat list
||==>x:pnat list=>rev(app(nil,x))=app(rev(x),nil)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||revapp2([1,1,1])
|||y:pnat list
|||==>x:pnat list=>rev(x)=app(rev(x),nil)in pnat list
|||SELECTED METHOD at depth 3: generalise(rev(x),v0:pnat list)
||||revapp2([1,1,1,1])
||||y:pnat list
||||==>v0:pnat list=>x:pnat list=>v0=app(v0,nil)in pnat list
||||SELECTED METHOD at depth 4: induction([v1::v0],[v0:pnat list])
|||||revapp2([2,1,1,1,1])
|||||v1:pnat
|||||v0:pnat list
|||||v2:ih(x:pnat list=>v0=app(v0,nil)in pnat list)
|||||y:pnat list
|||||==>x:pnat list=>``v1::{v0}''<out> =app(``v1::{v0}''<out>,nil)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||revapp2([1,2,1,1,1,1])
||||||v1:pnat
||||||v0:pnat list
||||||v2:ih(x:pnat list=>v0=app(v0,nil)in pnat list)
||||||y:pnat list
||||||==>x:pnat list=>``v1::{v0}''<out> =``v1::{app(v0,nil)}''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v2))
|||||||revapp2([1,1,2,1,1,1,1])
|||||||v1:pnat
|||||||v0:pnat list
|||||||v2:ih(x:pnat list=>v0=app(v0,nil)in pnat list)
|||||||y:pnat list
|||||||==>v1::v0=v1::v0 in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||||revapp2([1,1,1,1,1])
|||||v0:pnat list
|||||y:pnat list
|||||==>x:pnat list=>nil=app(nil,nil)in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1],app1)
||||||revapp2([1,1,1,1,1,1])
||||||v0:pnat list
||||||y:pnat list
||||||==>x:pnat list=>nil=nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for revapp2

------------------------------------------------------------
revapp2:

[x:pnat list,y:pnat list]

|- rev(app(rev(y),x))=app(rev(x),y)in pnat list

induction([v0::y],[y:pnat list]) then 
  [eval_def([1,1,1,1],rev1) then 
     eval_def([1,1,1],app1) then 
       generalise(rev(x),v0:pnat list) then 
         induction([v1::v0],[v0:pnat list]) then 
           [eval_def([2,1],app1) then 
              elementary(...),
            wave([2,1],[app2,equ(left)]) then 
              fertilize(weak(v2)) then 
                elementary(...)
           ],
   wave([1,1,1,1],[rev2,equ(left)]) then 
     wave([2,1],[lemma1,equ(left)]) then 
       wave([1,2,1],[rev2,equ(right)]) then 
         wave([1,1,1],[lemma2,equ(left)]) then 
           fertilize(strong(v1))
  ]

------------------------------------------------------------
lemma2:

[v0:pnat,v1:pnat list,x:pnat list]

|- app(app(v1,v0::nil),x)=app(v1,v0::x)in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],app2) then 
         eval_def([2,1,1],app1) then 
           elementary(...),
   wave([1,1,1],[app2,equ(left)]) then 
     wave([2,1],[app2,equ(left)]) then 
       wave([1,1],[app2,equ(left)]) then 
         fertilize(weak(v3)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,y:pnat list]

|- app(v1,v0::y)=app(app(v1,v0::nil),y)in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,1],app1) then 
     eval_def([1,2,1],app1) then 
       eval_def([2,1],app2) then 
         eval_def([2,2,1],app1) then 
           elementary(...),
   wave([1,2,1],[app2,equ(left)]) then 
     wave([1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(left)]) then 
         fertilize(weak(v3)) then 
           elementary(...)
  ]


PLANNING for revapp2 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting thm(lemma2)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for revapp2...done
deleting thm(revapp2)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(revapp3)...done
revapp3([])
==>x:pnat list=>y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list
SELECTED METHOD at depth 0: induction([v0::x],[x:pnat list])
|revapp3([2])
|v0:pnat
|x:pnat list
|v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
|==>y:pnat list=>app(rev(rev(``v0::{x}''<out>)),\y/)=rev(rev(app(``v0::{x}''<out>,\y/)))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1,1],[rev2,equ(left)])
||revapp3([1,2])
||v0:pnat
||x:pnat list
||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
||==>y:pnat list=>app(rev(``app({rev(x)},v0::nil)''<out>),\y/)=rev(rev(app(``v0::{x}''<out>,\y/)))in pnat list
||SELECTED METHOD at depth 2: wave([1,1,2,1],[app2,equ(left)])
|||revapp3([1,1,2])
|||v0:pnat
|||x:pnat list
|||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
|||==>y:pnat list=>app(rev(``app({rev(x)},v0::nil)''<out>),\y/)=rev(rev(``v0::{app(x,\y/)}''<out>))in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1],[rev2,equ(left)])
||||revapp3([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
||||==>y:pnat list=>app(rev(``app({rev(x)},v0::nil)''<out>),\y/)=rev(``app({rev(app(x,\y/))},v0::nil)''<out>)in pnat list

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- rev(app(v1,v0::nil))=M6(rev(v1),v0,v1)in pnat list

saving thm(lemma1)...done
 adding wave-rules for lemma1:..............done
||||revapp3([1,1,1,2])
||||v0:pnat
||||x:pnat list
||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
||||==>y:pnat list=>app(rev(``app({rev(x)},v0::nil)''<out>),\y/)=rev(``app({rev(app(x,\y/))},v0::nil)''<out>)in pnat list
||||SELECTED METHOD at depth 4: wave([1,1,1],[lemma1,equ(left)])
|||||revapp3([1,1,1,1,2])
|||||v0:pnat
|||||x:pnat list
|||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
|||||==>y:pnat list=>app("M6({rev(rev(x))},v0,rev(x))"<out>,\y/)=rev(``app({rev(app(x,\y/))},v0::nil)''<out>)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[lemma1,equ(left)])
||||||revapp3([1,1,1,1,1,2])
||||||v0:pnat
||||||x:pnat list
||||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
||||||==>y:pnat list=>app("M6({rev(rev(x))},v0,rev(x))"<out>,\y/)="M6({rev(rev(app(x,\y/)))},v0,rev(app(x,\y/)))"<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1],[app2,equ(left)])
|||||||revapp3([1,1,1,1,1,1,2])
|||||||v0:pnat
|||||||x:pnat list
|||||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
|||||||==>y:pnat list=>``v0::{app(rev(rev(x)),\y/)}''<out> =``v0::{rev(rev(app(x,\y/)))}''<out>in pnat list
|||||||SELECTED METHOD at depth 7: fertilize(weak(v1))
||||||||revapp3([1,1,1,1,1,1,1,2])
||||||||v0:pnat
||||||||x:pnat list
||||||||v1:ih(y:pnat list=>app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list)
||||||||==>v0::app(rev(rev(x)),y)=v0::app(rev(rev(x)),y)in pnat list
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning partially complete for revapp3

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|==>v0:pnat=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::rev(``v2::{v1}''<out>)in pnat list
|SELECTED METHOD at depth 1: wave([2,2,1],[rev2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||==>v0:pnat=>rev(app(``v2::{v1}''<out>,\v0/ ::nil))=\v0/ ::``app({rev(v1)},v2::nil)''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|||==>v0:pnat=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=\v0/ ::``app({rev(v1)},v2::nil)''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||||==>v0:pnat=>rev(``v2::{app(v1,\v0/ ::nil)}''<out>)=``app({\v0/ ::rev(v1)},v2::nil)''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[rev2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
|||||==>v0:pnat=>``app({rev(app(v1,\v0/ ::nil))},v2::nil)''<out> =``app({\v0/ ::rev(v1)},v2::nil)''<out>in pnat list
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||v1:pnat list
||||||v3:ih(v0:pnat=>rev(app(v1,v0::nil))=v0::rev(v1)in pnat list)
||||||==>app(rev(app(v1,v0::nil)),v2::nil)=app(rev(app(v1,v0::nil)),v2::nil)in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:pnat list
|==>v0:pnat=>rev(app(nil,v0::nil))=v0::rev(nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,2,1],rev1)
||lemma1([1,1])
||v1:pnat list
||==>v0:pnat=>rev(app(nil,v0::nil))=v0::nil in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>v0:pnat=>rev(v0::nil)=v0::nil in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],rev2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>v0:pnat=>app(rev(nil),v0::nil)=v0::nil in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1,1],rev1)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||==>v0:pnat=>app(nil,v0::nil)=v0::nil in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v1:pnat list
||||||==>v0:pnat=>v0::nil=v0::nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma1:..............done
|revapp3([1])
|x:pnat list
|==>y:pnat list=>app(rev(rev(nil)),y)=rev(rev(app(nil,y)))in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||revapp3([1,1])
||x:pnat list
||==>y:pnat list=>app(rev(rev(nil)),y)=rev(rev(y))in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1,1],rev1)
|||revapp3([1,1,1])
|||x:pnat list
|||==>y:pnat list=>app(rev(nil),y)=rev(rev(y))in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1,1],rev1)
||||revapp3([1,1,1,1])
||||x:pnat list
||||==>y:pnat list=>app(nil,y)=rev(rev(y))in pnat list
||||SELECTED METHOD at depth 4: eval_def([1,1],app1)
|||||revapp3([1,1,1,1,1])
|||||x:pnat list
|||||==>y:pnat list=>y=rev(rev(y))in pnat list
|||||SELECTED METHOD at depth 5: induction([v0::y],[y:pnat list])
||||||revapp3([2,1,1,1,1,1])
||||||v0:pnat
||||||y:pnat list
||||||v1:ih(y=rev(rev(y))in pnat list)
||||||x:pnat list
||||||==>``v0::{y}''<out> =rev(rev(``v0::{y}''<out>))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,1],[rev2,equ(left)])
|||||||revapp3([1,2,1,1,1,1,1])
|||||||v0:pnat
|||||||y:pnat list
|||||||v1:ih(y=rev(rev(y))in pnat list)
|||||||x:pnat list
|||||||==>``v0::{y}''<out> =rev(``app({rev(y)},v0::nil)''<out>)in pnat list
|||||||SELECTED METHOD at depth 7: wave([2,1],[lemma1,equ(left)])
||||||||revapp3([1,1,2,1,1,1,1,1])
||||||||v0:pnat
||||||||y:pnat list
||||||||v1:ih(y=rev(rev(y))in pnat list)
||||||||x:pnat list
||||||||==>``v0::{y}''<out> =``v0::{rev(rev(y))}''<out>in pnat list
||||||||SELECTED METHOD at depth 8: fertilize(weak(v1))
|||||||||revapp3([1,1,1,2,1,1,1,1,1])
|||||||||v0:pnat
|||||||||y:pnat list
|||||||||v1:ih(y=rev(rev(y))in pnat list)
|||||||||x:pnat list
|||||||||==>v0::y=v0::y in pnat list
|||||||||TERMINATING METHOD at depth 9: elementary(...)
||||||revapp3([1,1,1,1,1,1])
||||||y:pnat list
||||||x:pnat list
||||||==>nil=rev(rev(nil))in pnat list
||||||SELECTED METHOD at depth 6: eval_def([1,2,1],rev1)
|||||||revapp3([1,1,1,1,1,1,1])
|||||||y:pnat list
|||||||x:pnat list
|||||||==>nil=rev(nil)in pnat list
|||||||SELECTED METHOD at depth 7: eval_def([2,1],rev1)
||||||||revapp3([1,1,1,1,1,1,1,1])
||||||||y:pnat list
||||||||x:pnat list
||||||||==>nil=nil in pnat list
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning complete for revapp3

------------------------------------------------------------
revapp3:

[x:pnat list,y:pnat list]

|- app(rev(rev(x)),y)=rev(rev(app(x,y)))in pnat list

induction([v0::x],[x:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     eval_def([1,1,1,1],rev1) then 
       eval_def([1,1,1],rev1) then 
         eval_def([1,1],app1) then 
           induction([v0::y],[y:pnat list]) then 
             [eval_def([1,2,1],rev1) then 
                eval_def([2,1],rev1) then 
                  elementary(...),
              wave([1,2,1],[rev2,equ(left)]) then 
                wave([2,1],[lemma1,equ(left)]) then 
                  fertilize(weak(v1)) then 
                    elementary(...)
             ],
   wave([1,1,1,1],[rev2,equ(left)]) then 
     wave([1,1,2,1],[app2,equ(left)]) then 
       wave([1,2,1],[rev2,equ(left)]) then 
         wave([1,1,1],[lemma1,equ(left)]) then 
           wave([2,1],[lemma1,equ(left)]) then 
             wave([1,1],[app2,equ(left)]) then 
               fertilize(weak(v1)) then 
                 elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list]

|- rev(app(v1,v0::nil))=v0::rev(v1)in pnat list

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([2,2,1],rev1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],rev2) then 
         eval_def([1,1,1],rev1) then 
           eval_def([1,1],app1) then 
             elementary(...),
   wave([2,2,1],[rev2,equ(left)]) then 
     wave([1,1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(right)]) then 
         wave([1,1],[rev2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
  ]


PLANNING for revapp3 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for revapp3...done
deleting thm(revapp3)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading synth(even)...done
loading def(true)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading thm(evenlenapp1)...done
evenlenapp1([])
==>a:pnat list=>even(length(app(a,a)))
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|evenlenapp1([2])
|v0:pnat
|a:pnat list
|v1:ih(even(length(app(a,a))))
|==>even(length(app(``v0::{a}''<out>,``v0::{a}''<out>)))
|SELECTED METHOD at depth 1: wave([1,1],[app2,equ(left)])
||evenlenapp1([1,2])
||v0:pnat
||a:pnat list
||v1:ih(even(length(app(a,a))))
||==>even(length(``v0::{app(a,``v0::{a}''<out>)}''<out>))
||SELECTED METHOD at depth 2: wave([1],[length2,equ(left)])
|||evenlenapp1([1,1,2])
|||v0:pnat
|||a:pnat list
|||v1:ih(even(length(app(a,a))))
|||==>even(``s({length(app(a,``v0::{a}''<out>))})''<out>)

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat list,a:pnat list,v0:pnat]

|- app(v1,v0::a)=M7(app(v1,a),a,v0,v1)in pnat list

saving thm(lemma1)...done
 adding wave-rules for lemma1:...................................................done
|||evenlenapp1([1,1,2])
|||v0:pnat
|||a:pnat list
|||v1:ih(even(length(app(a,a))))
|||==>even(``s({length(app(a,``v0::{a}''<out>))})''<out>)
|||SELECTED METHOD at depth 3: wave([1,1,1],[lemma1,equ(left)])
||||evenlenapp1([1,1,1,2])
||||v0:pnat
||||a:pnat list
||||v1:ih(even(length(app(a,a))))
||||==>even(``s({length("M7({app(a,a)},a,v0,a)"<out>)})''<out>)

Backtracking to [1,1,2] (patch point)
deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat list,a:pnat list,v0:pnat]

|- length(app(v1,v0::a))=M8(length(app(v1,a)),a,v0,v1)in pnat

saving thm(lemma1)...done
 adding wave-rules for lemma1:......................................................................................done
|||evenlenapp1([1,1,2])
|||v0:pnat
|||a:pnat list
|||v1:ih(even(length(app(a,a))))
|||==>even(``s({length(app(a,``v0::{a}''<out>))})''<out>)
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||evenlenapp1([1,1,1,2])
||||v0:pnat
||||a:pnat list
||||v1:ih(even(length(app(a,a))))
||||==>even(``s({"M8({length(app(a,a))},a,v0,a)"<out>})''<out>)
||||SELECTED METHOD at depth 4: wave([],[even3,equ(left)])
|||||evenlenapp1([1,1,1,1,2])
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(even(length(app(a,a))))
|||||==>even("Var37({length(app(a,a))},a,v0,a)"<out>)
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
Planning partially complete for evenlenapp1

saving thm(lemma1)...done
lemma1([])
==>v1:pnat list=>a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat
SELECTED METHOD at depth 0: induction([v2::v1],[v1:pnat list])
|lemma1([2])
|v2:pnat
|v1:pnat list
|v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
|==>a:pnat list=>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::\a/))=s(length(app(``v2::{v1}''<out>,\a/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||v1:pnat list
||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
||==>a:pnat list=>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::\a/))=s(length(``v2::{app(v1,\a/)}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||v1:pnat list
|||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
|||==>a:pnat list=>v0:pnat=>length(app(``v2::{v1}''<out>,\v0/ ::\a/))=s(``s({length(app(v1,\a/))})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||v1:pnat list
||||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
||||==>a:pnat list=>v0:pnat=>length(``v2::{app(v1,\v0/ ::\a/)}''<out>)=s(``s({length(app(v1,\a/))})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
|||||==>a:pnat list=>v0:pnat=>``s({length(app(v1,\v0/ ::\a/))})''<out> =s(``s({length(app(v1,\a/))})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||v1:pnat list
|||||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
|||||==>a:pnat list=>v0:pnat=>``s({length(app(v1,\v0/ ::\a/))})''<out> =``s({s(length(app(v1,\a/)))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||v1:pnat list
||||||v3:ih(a:pnat list=>v0:pnat=>length(app(v1,v0::a))=s(length(app(v1,a)))in pnat)
||||||==>s(length(app(v1,v0::a)))=s(length(app(v1,_331615::a)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:pnat list
|==>a:pnat list=>v0:pnat=>length(app(nil,v0::a))=s(length(app(nil,a)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||lemma1([1,1])
||v1:pnat list
||==>a:pnat list=>v0:pnat=>length(app(nil,v0::a))=s(length(a))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||v1:pnat list
|||==>a:pnat list=>v0:pnat=>length(v0::a)=s(length(a))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||==>a:pnat list=>v0:pnat=>s(length(a))=s(length(a))in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma1:................................done
Planning partially complete for evenlenapp1

|evenlenapp1([1])
|a:pnat list
|==>even(length(app(nil,nil)))
|SELECTED METHOD at depth 1: eval_def([1,1],app1)
||evenlenapp1([1,1])
||a:pnat list
||==>even(length(nil))
||SELECTED METHOD at depth 2: eval_def([1],length1)
|||evenlenapp1([1,1,1])
|||a:pnat list
|||==>even(0)
|||SELECTED METHOD at depth 3: eval_def([],even1)
||||evenlenapp1([1,1,1,1])
||||a:pnat list
||||==>{true}
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for evenlenapp1

------------------------------------------------------------
evenlenapp1:

[a:pnat list]

|- even(length(app(a,a)))

induction([v0::a],[a:pnat list]) then 
  [eval_def([1,1],app1) then 
     eval_def([1],length1) then 
       eval_def([],even1) then 
         elementary(...),
   wave([1,1],[app2,equ(left)]) then 
     wave([1],[length2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         wave([],[even3,equ(left)]) then 
           fertilize(strong(v1))
  ]

------------------------------------------------------------
lemma1:

[v1:pnat list,a:pnat list,v0:pnat]

|- length(app(v1,v0::a))=s(length(app(v1,a)))in pnat

induction([v2::v1],[v1:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         elementary(...),
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([1,2,1],[length2,equ(left)]) then 
       wave([1,1,1],[app2,equ(left)]) then 
         wave([1,1],[length2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
  ]


PLANNING for evenlenapp1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for evenlenapp1...done
deleting thm(evenlenapp1)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading synth(rotate)...done
loading def(rotate)...done
loading eqn(rotate1)...done
loading eqn(rotate2)...done
loading eqn(rotate3)...done
 adding wave-rules for rotate1:..done
 adding wave-rules for rotate2:..done
 adding wave-rules for rotate3:...........done
 adding defeqn-record for rotate1...done 
 adding defeqn-record for rotate2...done 
 adding defeqn-record for rotate3...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading thm(rotlenapp)...done
rotlenapp([])
==>l:pnat list=>a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|rotlenapp([2])
|v0:pnat
|l:pnat list
|v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
|==>a:pnat list=>rotate(length(``v0::{l}''<out>),app(``v0::{l}''<out>,\a/))=app(\a/,``v0::{l}''<out>)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[length2,equ(left)])
||rotlenapp([1,2])
||v0:pnat
||l:pnat list
||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
||==>a:pnat list=>rotate(``s({length(l)})''<out>,app(``v0::{l}''<out>,\a/))=app(\a/,``v0::{l}''<out>)in pnat list
||SELECTED METHOD at depth 2: wave([2,1,1],[app2,equ(left)])
|||rotlenapp([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
|||==>a:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,\a/)}''<out>)=app(\a/,``v0::{l}''<out>)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[rotate3,equ(left)])
||||rotlenapp([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
||||==>a:pnat list=>rotate(length(l),``app({app(l,\a/)},v0::nil)''<in>)=app(\a/,``v0::{l}''<out>)in pnat list

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[a:pnat list,l:pnat list,v0:pnat]

|- app(a,v0::l)=app(M9(a,l,v0),l)in pnat list

saving thm(lemma1)...done
 adding wave-rules for lemma1:.done
||||rotlenapp([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
||||==>a:pnat list=>rotate(length(l),``app({app(l,\a/)},v0::nil)''<in>)=app(\a/,``v0::{l}''<out>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,1],[lemma1,equ(left)])
|||||rotlenapp([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
|||||==>a:pnat list=>rotate(length(l),``app({app(l,\a/)},v0::nil)''<in>)=app(\"M9({a},l,v0)"<in>/,l)in pnat list

>>>>> INVOKING lemma-speculation CRITIC <<<<<

------------------------------------------------------------
lemma2:

[a:pnat list,l:pnat list,v0:pnat]

|- app(app(l,a),v0::nil)=app(l,M10(a,l,v0))in pnat list

saving thm(lemma2)...done
 adding wave-rules for lemma2:....done
|||||rotlenapp([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
|||||==>a:pnat list=>rotate(length(l),``app({app(l,\a/)},v0::nil)''<in>)=app(\"M9({a},l,v0)"<in>/,l)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1,1],[lemma2,equ(left)])
||||||rotlenapp([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(a:pnat list=>rotate(length(l),app(l,a))=app(a,l)in pnat list)
||||||==>a:pnat list=>rotate(length(l),app(l,\"M10({a},l,v0)"<in>/))=app(\"M9({a},l,v0)"<in>/,l)in pnat list
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
Planning partially complete for rotlenapp

saving thm(lemma2)...done
lemma2([])
==>a:pnat list=>l:pnat list=>v0:pnat=>app(app(l,a),v0::nil)=app(l,app(a,v0::nil))in pnat list
SELECTED METHOD at depth 0: generalise(v0::nil,v1:pnat list)
|lemma2([1])
|==>v1:pnat list=>a:pnat list=>l:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list
|SELECTED METHOD at depth 1: induction([v2::l],[l:pnat list])
||lemma2([2,1])
||v2:pnat
||l:pnat list
||v3:ih(v1:pnat list=>a:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list)
||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(app(``v2::{l}''<out>,\a/),\v1/)=app(``v2::{l}''<out>,app(\a/,\v1/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[app2,equ(left)])
|||lemma2([1,2,1])
|||v2:pnat
|||l:pnat list
|||v3:ih(v1:pnat list=>a:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list)
|||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(``v2::{app(l,\a/)}''<out>,\v1/)=app(``v2::{l}''<out>,app(\a/,\v1/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])
||||lemma2([1,1,2,1])
||||v2:pnat
||||l:pnat list
||||v3:ih(v1:pnat list=>a:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list)
||||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(``v2::{app(l,\a/)}''<out>,\v1/)=``v2::{app(l,app(\a/,\v1/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[app2,equ(left)])
|||||lemma2([1,1,1,2,1])
|||||v2:pnat
|||||l:pnat list
|||||v3:ih(v1:pnat list=>a:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list)
|||||==>v1:pnat list=>a:pnat list=>v0:pnat=>``v2::{app(app(l,\a/),\v1/)}''<out> =``v2::{app(l,app(\a/,\v1/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma2([1,1,1,1,2,1])
||||||v2:pnat
||||||l:pnat list
||||||v3:ih(v1:pnat list=>a:pnat list=>v0:pnat=>app(app(l,a),v1)=app(l,app(a,v1))in pnat list)
||||||==>v2::app(app(l,a),v1)=v2::app(app(l,a),v1)in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
||lemma2([1,1])
||l:pnat list
||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(app(nil,a),v1)=app(nil,app(a,v1))in pnat list
||SELECTED METHOD at depth 2: eval_def([2,1],app1)
|||lemma2([1,1,1])
|||l:pnat list
|||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(app(nil,a),v1)=app(a,v1)in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1,1],app1)
||||lemma2([1,1,1,1])
||||l:pnat list
||||==>v1:pnat list=>a:pnat list=>v0:pnat=>app(a,v1)=app(a,v1)in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma2:.......................done
Planning partially complete for rotlenapp

saving thm(lemma1)...done
lemma1([])
==>a:pnat list=>l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list
SELECTED METHOD at depth 0: induction([v1::a],[a:pnat list])
|lemma1([2])
|v1:pnat
|a:pnat list
|v2:ih(l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list)
|==>l:pnat list=>v0:pnat=>app(``v1::{a}''<out>,\v0/ ::\l/)=app(app(``v1::{a}''<out>,\v0/ ::nil),\l/)in pnat list
|SELECTED METHOD at depth 1: wave([1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v1:pnat
||a:pnat list
||v2:ih(l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list)
||==>l:pnat list=>v0:pnat=>app(``v1::{a}''<out>,\v0/ ::\l/)=app(``v1::{app(a,\v0/ ::nil)}''<out>,\l/)in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v1:pnat
|||a:pnat list
|||v2:ih(l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list)
|||==>l:pnat list=>v0:pnat=>``v1::{app(a,\v0/ ::\l/)}''<out> =app(``v1::{app(a,\v0/ ::nil)}''<out>,\l/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v1:pnat
||||a:pnat list
||||v2:ih(l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list)
||||==>l:pnat list=>v0:pnat=>``v1::{app(a,\v0/ ::\l/)}''<out> =``v1::{app(app(a,\v0/ ::nil),\l/)}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v2))
|||||lemma1([1,1,1,1,2])
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(l:pnat list=>v0:pnat=>app(a,v0::l)=app(app(a,v0::nil),l)in pnat list)
|||||==>v1::app(a,v0::l)=v1::app(a,v0::l)in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|lemma1([1])
|a:pnat list
|==>l:pnat list=>v0:pnat=>app(nil,v0::l)=app(app(nil,v0::nil),l)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1],app1)
||lemma1([1,1])
||a:pnat list
||==>l:pnat list=>v0:pnat=>v0::l=app(app(nil,v0::nil),l)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,2,1],app1)
|||lemma1([1,1,1])
|||a:pnat list
|||==>l:pnat list=>v0:pnat=>v0::l=app(v0::nil,l)in pnat list
|||SELECTED METHOD at depth 3: eval_def([2,1],app2)
||||lemma1([1,1,1,1])
||||a:pnat list
||||==>l:pnat list=>v0:pnat=>v0::l=v0::app(nil,l)in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,2,1],app1)
|||||lemma1([1,1,1,1,1])
|||||a:pnat list
|||||==>l:pnat list=>v0:pnat=>v0::l=v0::l in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.....done
|rotlenapp([1])
|l:pnat list
|==>a:pnat list=>rotate(length(nil),app(nil,a))=app(a,nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1,1],app1)
||rotlenapp([1,1])
||l:pnat list
||==>a:pnat list=>rotate(length(nil),a)=app(a,nil)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],length1)
|||rotlenapp([1,1,1])
|||l:pnat list
|||==>a:pnat list=>rotate(0,a)=app(a,nil)in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],rotate1)
||||rotlenapp([1,1,1,1])
||||l:pnat list
||||==>a:pnat list=>a=app(a,nil)in pnat list
||||SELECTED METHOD at depth 4: induction([v0::a],[a:pnat list])
|||||rotlenapp([2,1,1,1,1])
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(a=app(a,nil)in pnat list)
|||||l:pnat list
|||||==>``v0::{a}''<out> =app(``v0::{a}''<out>,nil)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||rotlenapp([1,2,1,1,1,1])
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(a=app(a,nil)in pnat list)
||||||l:pnat list
||||||==>``v0::{a}''<out> =``v0::{app(a,nil)}''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||rotlenapp([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(a=app(a,nil)in pnat list)
|||||||l:pnat list
|||||||==>v0::a=v0::a in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||||rotlenapp([1,1,1,1,1])
|||||a:pnat list
|||||l:pnat list
|||||==>nil=app(nil,nil)in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1],app1)
||||||rotlenapp([1,1,1,1,1,1])
||||||a:pnat list
||||||l:pnat list
||||||==>nil=nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for rotlenapp

------------------------------------------------------------
rotlenapp:

[l:pnat list,a:pnat list]

|- rotate(length(l),app(l,a))=app(a,l)in pnat list

induction([v0::l],[l:pnat list]) then 
  [eval_def([2,1,1],app1) then 
     eval_def([1,1,1],length1) then 
       eval_def([1,1],rotate1) then 
         induction([v0::a],[a:pnat list]) then 
           [eval_def([2,1],app1) then 
              elementary(...),
            wave([2,1],[app2,equ(left)]) then 
              fertilize(weak(v1)) then 
                elementary(...)
           ],
   wave([1,1,1],[length2,equ(left)]) then 
     wave([2,1,1],[app2,equ(left)]) then 
       wave([1,1],[rotate3,equ(left)]) then 
         wave([2,1],[lemma1,equ(left)]) then 
           wave([2,1,1],[lemma2,equ(left)]) then 
             fertilize(strong(v1))
  ]

------------------------------------------------------------
lemma2:

[a:pnat list,l:pnat list,v0:pnat]

|- app(app(l,a),v0::nil)=app(l,app(a,v0::nil))in pnat list

generalise(v0::nil,v1:pnat list) then 
  induction([v2::l],[l:pnat list]) then 
    [eval_def([2,1],app1) then 
       eval_def([1,1,1],app1) then 
         elementary(...),
     wave([1,1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(left)]) then 
         wave([1,1],[app2,equ(left)]) then 
           fertilize(weak(v3)) then 
             elementary(...)
    ]

------------------------------------------------------------
lemma1:

[a:pnat list,l:pnat list,v0:pnat]

|- app(a,v0::l)=app(app(a,v0::nil),l)in pnat list

induction([v1::a],[a:pnat list]) then 
  [eval_def([1,1],app1) then 
     eval_def([1,2,1],app1) then 
       eval_def([2,1],app2) then 
         eval_def([2,2,1],app1) then 
           elementary(...),
   wave([1,2,1],[app2,equ(left)]) then 
     wave([1,1],[app2,equ(left)]) then 
       wave([2,1],[app2,equ(left)]) then 
         fertilize(weak(v2)) then 
           elementary(...)
  ]


PLANNING for rotlenapp COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting thm(lemma2)...done
deleting theorem record for rotate...done
deleting synth(rotate)...done
deleting def(rotate)...done
deleting theorem record for rotate1...done
deleting wave record for rotate1...done
deleting wave record for rotate1...done
deleting func_defeqn record for rotate1...done
deleting wave(rotate1)...done
deleting theorem record for rotate2...done
deleting wave record for rotate2...done
deleting wave record for rotate2...done
deleting func_defeqn record for rotate2...done
deleting wave(rotate2)...done
deleting theorem record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting func_defeqn record for rotate3...done
deleting wave(rotate3)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for rotlenapp...done
deleting thm(rotlenapp)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading synth(even)...done
loading def(true)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading thm(ssid)...done
 adding wave-rules for ssid:......done
loading thm(evenlenapp2)...done
evenlenapp2([])
==>a:pnat list=>b:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1)
SELECTED METHOD at depth 0: induction([v0::b],[b:pnat list])
|evenlenapp2([2])
|v0:pnat
|b:pnat list
|v1:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|==>a:pnat list=>even(length(app(\a/,``v0::{b}''<out>)))=even(length(app(``v0::{b}''<out>,\a/)))in u(1)
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||evenlenapp2([1,2])
||v0:pnat
||b:pnat list
||v1:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||==>a:pnat list=>even(length(app(\a/,``v0::{b}''<out>)))=even(length(``v0::{app(b,\a/)}''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||evenlenapp2([1,1,2])
|||v0:pnat
|||b:pnat list
|||v1:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|||==>a:pnat list=>even(length(app(\a/,``v0::{b}''<out>)))=even(``s({length(app(b,\a/))})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([v0::v1::b],[b:pnat list])
|evenlenapp2([3])
|v0:pnat
|v1:pnat
|b:pnat list
|v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(app(``v0::v1::{b}''<out>,\a/)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|evenlenapp2([3])
|v0:pnat
|v1:pnat
|b:pnat list
|v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(app(``v0::{``v1::{b}''<out>}''<out>,\a/)))in u(1)
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||evenlenapp2([1,3])
||v0:pnat
||v1:pnat
||b:pnat list
||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(``v0::{app(``v1::{b}''<out>,\a/)}''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([2,1,1,2,1],[app2,equ(left)])
|||evenlenapp2([1,1,3])
|||v0:pnat
|||v1:pnat
|||b:pnat list
|||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(``v0::{``v1::{app(b,\a/)}''<out>}''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||evenlenapp2([1,1,1,3])
||||v0:pnat
||||v1:pnat
||||b:pnat list
||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(``s({length(``v1::{app(b,\a/)}''<out>)})''<out>)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,2,1],[length2,equ(left)])
|||||evenlenapp2([1,1,1,1,3])
|||||v0:pnat
|||||v1:pnat
|||||b:pnat list
|||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|||||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(``s({``s({length(app(b,\a/))})''<out>})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([2,1],[even3,equ(left)])
||||||evenlenapp2([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||||||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(app(b,\a/)))in u(1)

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[a:pnat list,b:pnat list,v0:pnat,v1:pnat]

|- even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1)

saving thm(lemma1)...done
lemma1([])
==>a:pnat list=>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1)
SELECTED METHOD at depth 0: induction([v2::a],[a:pnat list])
|lemma1([2])
|v2:pnat
|a:pnat list
|v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(app(``v2::{a}''<out>,\b/)))in u(1)
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||a:pnat list
||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(``v2::{app(a,\b/)}''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||a:pnat list
|||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(``s({length(app(a,\b/))})''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||a:pnat list
||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(``v2::{app(a,\v0/ ::\v1/ ::\b/)}''<out>))=even(``s({length(app(a,\b/))})''<out>)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(``s({length(app(a,\v0/ ::\v1/ ::\b/))})''<out>)=even(``s({length(app(a,\b/))})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([v2::v3::a],[a:pnat list])
|lemma1([3])
|v2:pnat
|v3:pnat
|a:pnat list
|v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(app(``v2::v3::{a}''<out>,\b/)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|lemma1([3])
|v2:pnat
|v3:pnat
|a:pnat list
|v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(app(``v2::{``v3::{a}''<out>}''<out>,\b/)))in u(1)
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||lemma1([1,3])
||v2:pnat
||v3:pnat
||a:pnat list
||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(``v2::{app(``v3::{a}''<out>,\b/)}''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([2,1,1,2,1],[app2,equ(left)])
|||lemma1([1,1,3])
|||v2:pnat
|||v3:pnat
|||a:pnat list
|||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(``v2::{``v3::{app(a,\b/)}''<out>}''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||lemma1([1,1,1,3])
||||v2:pnat
||||v3:pnat
||||a:pnat list
||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(``s({length(``v3::{app(a,\b/)}''<out>)})''<out>)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,2,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,3])
|||||v2:pnat
|||||v3:pnat
|||||a:pnat list
|||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(``s({``s({length(app(a,\b/))})''<out>})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([2,1],[even3,equ(left)])
||||||lemma1([1,1,1,1,1,3])
||||||v2:pnat
||||||v3:pnat
||||||a:pnat list
||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::v3::{a}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(app(a,\b/)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||lemma1([1,1,1,1,1,3])
||||||v2:pnat
||||||v3:pnat
||||||a:pnat list
||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(``v2::{``v3::{a}''<out>}''<out>,\v0/ ::\v1/ ::\b/)))=even(length(app(a,\b/)))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1],[app2,equ(left)])
|||||||lemma1([1,1,1,1,1,1,3])
|||||||v2:pnat
|||||||v3:pnat
|||||||a:pnat list
|||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(``v2::{app(``v3::{a}''<out>,\v0/ ::\v1/ ::\b/)}''<out>))=even(length(app(a,\b/)))in u(1)
|||||||SELECTED METHOD at depth 7: wave([2,1,1,1,1],[app2,equ(left)])
||||||||lemma1([1,1,1,1,1,1,1,3])
||||||||v2:pnat
||||||||v3:pnat
||||||||a:pnat list
||||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(``v2::{``v3::{app(a,\v0/ ::\v1/ ::\b/)}''<out>}''<out>))=even(length(app(a,\b/)))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[length2,equ(left)])
|||||||||lemma1([1,1,1,1,1,1,1,1,3])
|||||||||v2:pnat
|||||||||v3:pnat
|||||||||a:pnat list
|||||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(``s({length(``v3::{app(a,\v0/ ::\v1/ ::\b/)}''<out>)})''<out>)=even(length(app(a,\b/)))in u(1)
|||||||||SELECTED METHOD at depth 9: wave([1,1,1,1],[length2,equ(left)])
||||||||||lemma1([1,1,1,1,1,1,1,1,1,3])
||||||||||v2:pnat
||||||||||v3:pnat
||||||||||a:pnat list
||||||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
||||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(``s({``s({length(app(a,\v0/ ::\v1/ ::\b/))})''<out>})''<out>)=even(length(app(a,\b/)))in u(1)
||||||||||SELECTED METHOD at depth 10: wave([1,1],[even3,equ(left)])
|||||||||||lemma1([1,1,1,1,1,1,1,1,1,1,3])
|||||||||||v2:pnat
|||||||||||v3:pnat
|||||||||||a:pnat list
|||||||||||v4:ih(b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1))
|||||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(a,\v0/ ::\v1/ ::\b/)))=even(length(app(a,\b/)))in u(1)
|||||||||||TERMINATING METHOD at depth 11: fertilize(strong(v4))
|lemma1([2])
|v2:pnat
|a:pnat list
|==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(v2::nil,v0::v1::b)))=even(length(app(v2::nil,b)))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app2)
||lemma1([1,2])
||v2:pnat
||a:pnat list
||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(v2::nil,v0::v1::b)))=even(length(v2::app(nil,b)))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,2,1],length2)
|||lemma1([1,1,2])
|||v2:pnat
|||a:pnat list
|||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(v2::nil,v0::v1::b)))=even(s(length(app(nil,b))))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1,2,1],app1)
||||lemma1([1,1,1,2])
||||v2:pnat
||||a:pnat list
||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(v2::nil,v0::v1::b)))=even(s(length(b)))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],app2)
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||a:pnat list
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(v2::app(nil,v0::v1::b)))=even(s(length(b)))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],length2)
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||a:pnat list
||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(length(app(nil,v0::v1::b))))=even(s(length(b)))in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1,1,1,1],app1)
|||||||lemma1([1,1,1,1,1,1,2])
|||||||v2:pnat
|||||||a:pnat list
|||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(length(v0::v1::b)))=even(s(length(b)))in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1,1],length2)
||||||||lemma1([1,1,1,1,1,1,1,2])
||||||||v2:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(s(length(v1::b))))=even(s(length(b)))in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],even3)
|||||||||lemma1([1,1,1,1,1,1,1,1,2])
|||||||||v2:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(v1::b))=even(s(length(b)))in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1],length2)
||||||||||lemma1([1,1,1,1,1,1,1,1,1,2])
||||||||||v2:pnat
||||||||||a:pnat list
||||||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(length(b)))=even(s(length(b)))in u(1)
||||||||||TERMINATING METHOD at depth 10: elementary(...)
|lemma1([1])
|a:pnat list
|==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(nil,v0::v1::b)))=even(length(app(nil,b)))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||lemma1([1,1])
||a:pnat list
||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(app(nil,v0::v1::b)))=even(length(b))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,1,1],app1)
|||lemma1([1,1,1])
|||a:pnat list
|||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(v0::v1::b))=even(length(b))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1],length2)
||||lemma1([1,1,1,1])
||||a:pnat list
||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(length(v1::b)))=even(length(b))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],length2)
|||||lemma1([1,1,1,1,1])
|||||a:pnat list
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(s(s(length(b))))=even(length(b))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even3)
||||||lemma1([1,1,1,1,1,1])
||||||a:pnat list
||||||==>b:pnat list=>v0:pnat=>v1:pnat=>even(length(b))=even(length(b))in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma1:..done
||||||evenlenapp2([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||||||==>a:pnat list=>even(length(app(\a/,``v0::v1::{b}''<out>)))=even(length(app(b,\a/)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||evenlenapp2([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
||||||==>a:pnat list=>even(length(app(\a/,``v0::{``v1::{b}''<out>}''<out>)))=even(length(app(b,\a/)))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[lemma1,equ(left)])
|||||||evenlenapp2([1,1,1,1,1,1,3])
|||||||v0:pnat
|||||||v1:pnat
|||||||b:pnat list
|||||||v2:ih(a:pnat list=>even(length(app(a,b)))=even(length(app(b,a)))in u(1))
|||||||==>a:pnat list=>even(length(app(\a/,b)))=even(length(app(b,\a/)))in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v2))
|evenlenapp2([2])
|v0:pnat
|b:pnat list
|==>a:pnat list=>even(length(app(a,v0::nil)))=even(length(app(v0::nil,a)))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app2)
||evenlenapp2([1,2])
||v0:pnat
||b:pnat list
||==>a:pnat list=>even(length(app(a,v0::nil)))=even(length(v0::app(nil,a)))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,2,1],length2)
|||evenlenapp2([1,1,2])
|||v0:pnat
|||b:pnat list
|||==>a:pnat list=>even(length(app(a,v0::nil)))=even(s(length(app(nil,a))))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1,2,1],app1)
||||evenlenapp2([1,1,1,2])
||||v0:pnat
||||b:pnat list
||||==>a:pnat list=>even(length(app(a,v0::nil)))=even(s(length(a)))in u(1)
||||SELECTED METHOD at depth 4: induction([v1::a],[a:pnat list])
|||||evenlenapp2([2,1,1,1,2])
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||v0:pnat
|||||b:pnat list
|||||==>even(length(app(``v1::{a}''<out>,v0::nil)))=even(s(length(``v1::{a}''<out>)))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[length2,equ(left)])
||||||evenlenapp2([1,2,1,1,1,2])
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||v0:pnat
||||||b:pnat list
||||||==>even(length(app(``v1::{a}''<out>,v0::nil)))=even(s(``s({length(a)})''<out>))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[ssid,equ(left)])
|||||||evenlenapp2([1,1,2,1,1,1,2])
|||||||v1:pnat
|||||||a:pnat list
|||||||v2:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||v0:pnat
|||||||b:pnat list
|||||||==>even(length(app(``v1::{a}''<out>,v0::nil)))=even(``s({s(length(a))})''<out>)in u(1)
|||||||SELECTED METHOD at depth 7: wave([1,1,1,1],[app2,equ(left)])
||||||||evenlenapp2([1,1,1,2,1,1,1,2])
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||v0:pnat
||||||||b:pnat list
||||||||==>even(length(``v1::{app(a,v0::nil)}''<out>))=even(``s({s(length(a))})''<out>)in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[length2,equ(left)])
|||||||||evenlenapp2([1,1,1,1,2,1,1,1,2])
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v2:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>even(``s({length(app(a,v0::nil))})''<out>)=even(``s({s(length(a))})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

||||SELECTED METHOD at depth 4: induction([v1::v2::a],[a:pnat list])
|||||evenlenapp2([3,1,1,1,2])
|||||v1:pnat
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||v0:pnat
|||||b:pnat list
|||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(s(length(``v1::v2::{a}''<out>)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||evenlenapp2([3,1,1,1,2])
|||||v1:pnat
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||v0:pnat
|||||b:pnat list
|||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(s(length(``v1::{``v2::{a}''<out>}''<out>)))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[length2,equ(left)])
||||||evenlenapp2([1,3,1,1,1,2])
||||||v1:pnat
||||||v2:pnat
||||||a:pnat list
||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||v0:pnat
||||||b:pnat list
||||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(s(``s({length(``v2::{a}''<out>)})''<out>))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,1],[length2,equ(left)])
|||||||evenlenapp2([1,1,3,1,1,1,2])
|||||||v1:pnat
|||||||v2:pnat
|||||||a:pnat list
|||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||v0:pnat
|||||||b:pnat list
|||||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(s(``s({``s({length(a)})''<out>})''<out>))in u(1)
|||||||SELECTED METHOD at depth 7: wave([1,2,1],[ssid,equ(left)])
||||||||evenlenapp2([1,1,1,3,1,1,1,2])
||||||||v1:pnat
||||||||v2:pnat
||||||||a:pnat list
||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||v0:pnat
||||||||b:pnat list
||||||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(``s({s(``s({length(a)})''<out>)})''<out>)in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,2,1],[ssid,equ(left)])
|||||||||evenlenapp2([1,1,1,1,3,1,1,1,2])
|||||||||v1:pnat
|||||||||v2:pnat
|||||||||a:pnat list
|||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(``s({``s({s(length(a))})''<out>})''<out>)in u(1)
|||||||||SELECTED METHOD at depth 9: wave([2,1],[even3,equ(left)])
||||||||||evenlenapp2([1,1,1,1,1,3,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:pnat
||||||||||a:pnat list
||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>even(length(app(``v1::v2::{a}''<out>,v0::nil)))=even(s(length(a)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||||||evenlenapp2([1,1,1,1,1,3,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:pnat
||||||||||a:pnat list
||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>even(length(app(``v1::{``v2::{a}''<out>}''<out>,v0::nil)))=even(s(length(a)))in u(1)
||||||||||SELECTED METHOD at depth 10: wave([1,1,1,1],[app2,equ(left)])
|||||||||||evenlenapp2([1,1,1,1,1,1,3,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v2:pnat
|||||||||||a:pnat list
|||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>even(length(``v1::{app(``v2::{a}''<out>,v0::nil)}''<out>))=even(s(length(a)))in u(1)
|||||||||||SELECTED METHOD at depth 11: wave([2,1,1,1,1],[app2,equ(left)])
||||||||||||evenlenapp2([1,1,1,1,1,1,1,3,1,1,1,2])
||||||||||||v1:pnat
||||||||||||v2:pnat
||||||||||||a:pnat list
||||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||||||v0:pnat
||||||||||||b:pnat list
||||||||||||==>even(length(``v1::{``v2::{app(a,v0::nil)}''<out>}''<out>))=even(s(length(a)))in u(1)
||||||||||||SELECTED METHOD at depth 12: wave([1,1,1],[length2,equ(left)])
|||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,3,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||v2:pnat
|||||||||||||a:pnat list
|||||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||||||||v0:pnat
|||||||||||||b:pnat list
|||||||||||||==>even(``s({length(``v2::{app(a,v0::nil)}''<out>)})''<out>)=even(s(length(a)))in u(1)
|||||||||||||SELECTED METHOD at depth 13: wave([1,1,1,1],[length2,equ(left)])
||||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,3,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||v2:pnat
||||||||||||||a:pnat list
||||||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
||||||||||||||v0:pnat
||||||||||||||b:pnat list
||||||||||||||==>even(``s({``s({length(app(a,v0::nil))})''<out>})''<out>)=even(s(length(a)))in u(1)
||||||||||||||SELECTED METHOD at depth 14: wave([1,1],[even3,equ(left)])
|||||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,1,3,1,1,1,2])
|||||||||||||||v1:pnat
|||||||||||||||v2:pnat
|||||||||||||||a:pnat list
|||||||||||||||v3:ih(even(length(app(a,v0::nil)))=even(s(length(a)))in u(1))
|||||||||||||||v0:pnat
|||||||||||||||b:pnat list
|||||||||||||||==>even(length(app(a,v0::nil)))=even(s(length(a)))in u(1)
|||||||||||||||TERMINATING METHOD at depth 15: fertilize(strong(v3))
|||||evenlenapp2([2,1,1,1,2])
|||||v1:pnat
|||||a:pnat list
|||||v0:pnat
|||||b:pnat list
|||||==>even(length(app(v1::nil,v0::nil)))=even(s(length(v1::nil)))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,2,1],length2)
||||||evenlenapp2([1,2,1,1,1,2])
||||||v1:pnat
||||||a:pnat list
||||||v0:pnat
||||||b:pnat list
||||||==>even(length(app(v1::nil,v0::nil)))=even(s(s(length(nil))))in u(1)
||||||SELECTED METHOD at depth 6: eval_def([2,1],even3)
|||||||evenlenapp2([1,1,2,1,1,1,2])
|||||||v1:pnat
|||||||a:pnat list
|||||||v0:pnat
|||||||b:pnat list
|||||||==>even(length(app(v1::nil,v0::nil)))=even(length(nil))in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,2,1],length1)
||||||||evenlenapp2([1,1,1,2,1,1,1,2])
||||||||v1:pnat
||||||||a:pnat list
||||||||v0:pnat
||||||||b:pnat list
||||||||==>even(length(app(v1::nil,v0::nil)))=even(0)in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([2,1],even1)
|||||||||evenlenapp2([1,1,1,1,2,1,1,1,2])
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>even(length(app(v1::nil,v0::nil)))={true}in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],app2)
||||||||||evenlenapp2([1,1,1,1,1,2,1,1,1,2])
||||||||||v1:pnat
||||||||||a:pnat list
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>even(length(v1::app(nil,v0::nil)))={true}in u(1)
||||||||||SELECTED METHOD at depth 10: eval_def([1,1,1],length2)
|||||||||||evenlenapp2([1,1,1,1,1,1,2,1,1,1,2])
|||||||||||v1:pnat
|||||||||||a:pnat list
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>even(s(length(app(nil,v0::nil))))={true}in u(1)
|||||||||||SELECTED METHOD at depth 11: eval_def([1,1,1,1,1],app1)
||||||||||||evenlenapp2([1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||v1:pnat
||||||||||||a:pnat list
||||||||||||v0:pnat
||||||||||||b:pnat list
||||||||||||==>even(s(length(v0::nil)))={true}in u(1)
||||||||||||SELECTED METHOD at depth 12: eval_def([1,1,1,1],length2)
|||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,2,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||a:pnat list
|||||||||||||v0:pnat
|||||||||||||b:pnat list
|||||||||||||==>even(s(s(length(nil))))={true}in u(1)
|||||||||||||SELECTED METHOD at depth 13: eval_def([1,1],even3)
||||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||a:pnat list
||||||||||||||v0:pnat
||||||||||||||b:pnat list
||||||||||||||==>even(length(nil))={true}in u(1)
||||||||||||||SELECTED METHOD at depth 14: eval_def([1,1,1],length1)
|||||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,1,2,1,1,1,2])
|||||||||||||||v1:pnat
|||||||||||||||a:pnat list
|||||||||||||||v0:pnat
|||||||||||||||b:pnat list
|||||||||||||||==>even(0)={true}in u(1)
|||||||||||||||SELECTED METHOD at depth 15: eval_def([1,1],even1)
||||||||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||||||v1:pnat
||||||||||||||||a:pnat list
||||||||||||||||v0:pnat
||||||||||||||||b:pnat list
||||||||||||||||==>{true}={true}in u(1)
||||||||||||||||TERMINATING METHOD at depth 16: elementary(...)
|||||evenlenapp2([1,1,1,1,2])
|||||a:pnat list
|||||v0:pnat
|||||b:pnat list
|||||==>even(length(app(nil,v0::nil)))=even(s(length(nil)))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,2,1],length1)
||||||evenlenapp2([1,1,1,1,1,2])
||||||a:pnat list
||||||v0:pnat
||||||b:pnat list
||||||==>even(length(app(nil,v0::nil)))=even(s(0))in u(1)
||||||SELECTED METHOD at depth 6: eval_def([2,1],even2)
|||||||evenlenapp2([1,1,1,1,1,1,2])
|||||||a:pnat list
|||||||v0:pnat
|||||||b:pnat list
|||||||==>even(length(app(nil,v0::nil)))=void in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1,1],app1)
||||||||evenlenapp2([1,1,1,1,1,1,1,2])
||||||||a:pnat list
||||||||v0:pnat
||||||||b:pnat list
||||||||==>even(length(v0::nil))=void in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1,1],length2)
|||||||||evenlenapp2([1,1,1,1,1,1,1,1,2])
|||||||||a:pnat list
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>even(s(length(nil)))=void in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],length1)
||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,2])
||||||||||a:pnat list
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>even(s(0))=void in u(1)
||||||||||SELECTED METHOD at depth 10: eval_def([1,1],even2)
|||||||||||evenlenapp2([1,1,1,1,1,1,1,1,1,1,2])
|||||||||||a:pnat list
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>void=void in u(1)
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
|evenlenapp2([1])
|b:pnat list
|==>a:pnat list=>even(length(app(a,nil)))=even(length(app(nil,a)))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||evenlenapp2([1,1])
||b:pnat list
||==>a:pnat list=>even(length(app(a,nil)))=even(length(a))in u(1)
||SELECTED METHOD at depth 2: induction([v0::a],[a:pnat list])
|||evenlenapp2([2,1,1])
|||v0:pnat
|||a:pnat list
|||v1:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||b:pnat list
|||==>even(length(app(``v0::{a}''<out>,nil)))=even(length(``v0::{a}''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||evenlenapp2([1,2,1,1])
||||v0:pnat
||||a:pnat list
||||v1:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||b:pnat list
||||==>even(length(app(``v0::{a}''<out>,nil)))=even(``s({length(a)})''<out>)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,1,1],[app2,equ(left)])
|||||evenlenapp2([1,1,2,1,1])
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||||b:pnat list
|||||==>even(length(``v0::{app(a,nil)}''<out>))=even(``s({length(a)})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1],[length2,equ(left)])
||||||evenlenapp2([1,1,1,2,1,1])
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||||b:pnat list
||||||==>even(``s({length(app(a,nil))})''<out>)=even(``s({length(a)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

||SELECTED METHOD at depth 2: induction([v0::v1::a],[a:pnat list])
|||evenlenapp2([3,1,1])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||b:pnat list
|||==>even(length(app(``v0::v1::{a}''<out>,nil)))=even(length(``v0::v1::{a}''<out>))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||evenlenapp2([3,1,1])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||b:pnat list
|||==>even(length(app(``v0::v1::{a}''<out>,nil)))=even(length(``v0::{``v1::{a}''<out>}''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||evenlenapp2([1,3,1,1])
||||v0:pnat
||||v1:pnat
||||a:pnat list
||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||b:pnat list
||||==>even(length(app(``v0::v1::{a}''<out>,nil)))=even(``s({length(``v1::{a}''<out>)})''<out>)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,2,1],[length2,equ(left)])
|||||evenlenapp2([1,1,3,1,1])
|||||v0:pnat
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||||b:pnat list
|||||==>even(length(app(``v0::v1::{a}''<out>,nil)))=even(``s({``s({length(a)})''<out>})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([2,1],[even3,equ(left)])
||||||evenlenapp2([1,1,1,3,1,1])
||||||v0:pnat
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||||b:pnat list
||||||==>even(length(app(``v0::v1::{a}''<out>,nil)))=even(length(a))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||evenlenapp2([1,1,1,3,1,1])
||||||v0:pnat
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||||b:pnat list
||||||==>even(length(app(``v0::{``v1::{a}''<out>}''<out>,nil)))=even(length(a))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1],[app2,equ(left)])
|||||||evenlenapp2([1,1,1,1,3,1,1])
|||||||v0:pnat
|||||||v1:pnat
|||||||a:pnat list
|||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||||||b:pnat list
|||||||==>even(length(``v0::{app(``v1::{a}''<out>,nil)}''<out>))=even(length(a))in u(1)
|||||||SELECTED METHOD at depth 7: wave([2,1,1,1,1],[app2,equ(left)])
||||||||evenlenapp2([1,1,1,1,1,3,1,1])
||||||||v0:pnat
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||||||b:pnat list
||||||||==>even(length(``v0::{``v1::{app(a,nil)}''<out>}''<out>))=even(length(a))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[length2,equ(left)])
|||||||||evenlenapp2([1,1,1,1,1,1,3,1,1])
|||||||||v0:pnat
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||||||||b:pnat list
|||||||||==>even(``s({length(``v1::{app(a,nil)}''<out>)})''<out>)=even(length(a))in u(1)
|||||||||SELECTED METHOD at depth 9: wave([1,1,1,1],[length2,equ(left)])
||||||||||evenlenapp2([1,1,1,1,1,1,1,3,1,1])
||||||||||v0:pnat
||||||||||v1:pnat
||||||||||a:pnat list
||||||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
||||||||||b:pnat list
||||||||||==>even(``s({``s({length(app(a,nil))})''<out>})''<out>)=even(length(a))in u(1)
||||||||||SELECTED METHOD at depth 10: wave([1,1],[even3,equ(left)])
|||||||||||evenlenapp2([1,1,1,1,1,1,1,1,3,1,1])
|||||||||||v0:pnat
|||||||||||v1:pnat
|||||||||||a:pnat list
|||||||||||v2:ih(even(length(app(a,nil)))=even(length(a))in u(1))
|||||||||||b:pnat list
|||||||||||==>even(length(app(a,nil)))=even(length(a))in u(1)
|||||||||||TERMINATING METHOD at depth 11: fertilize(strong(v2))
|||evenlenapp2([2,1,1])
|||v0:pnat
|||a:pnat list
|||b:pnat list
|||==>even(length(app(v0::nil,nil)))=even(length(v0::nil))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,2,1],length2)
||||evenlenapp2([1,2,1,1])
||||v0:pnat
||||a:pnat list
||||b:pnat list
||||==>even(length(app(v0::nil,nil)))=even(s(length(nil)))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,2,1],length1)
|||||evenlenapp2([1,1,2,1,1])
|||||v0:pnat
|||||a:pnat list
|||||b:pnat list
|||||==>even(length(app(v0::nil,nil)))=even(s(0))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([2,1],even2)
||||||evenlenapp2([1,1,1,2,1,1])
||||||v0:pnat
||||||a:pnat list
||||||b:pnat list
||||||==>even(length(app(v0::nil,nil)))=void in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1,1,1],app2)
|||||||evenlenapp2([1,1,1,1,2,1,1])
|||||||v0:pnat
|||||||a:pnat list
|||||||b:pnat list
|||||||==>even(length(v0::app(nil,nil)))=void in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1],length2)
||||||||evenlenapp2([1,1,1,1,1,2,1,1])
||||||||v0:pnat
||||||||a:pnat list
||||||||b:pnat list
||||||||==>even(s(length(app(nil,nil))))=void in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1,1,1,1],app1)
|||||||||evenlenapp2([1,1,1,1,1,1,2,1,1])
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||b:pnat list
|||||||||==>even(s(length(nil)))=void in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],length1)
||||||||||evenlenapp2([1,1,1,1,1,1,1,2,1,1])
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||b:pnat list
||||||||||==>even(s(0))=void in u(1)
||||||||||SELECTED METHOD at depth 10: eval_def([1,1],even2)
|||||||||||evenlenapp2([1,1,1,1,1,1,1,1,2,1,1])
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||b:pnat list
|||||||||||==>void=void in u(1)
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
|||evenlenapp2([1,1,1])
|||a:pnat list
|||b:pnat list
|||==>even(length(app(nil,nil)))=even(length(nil))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,2,1],length1)
||||evenlenapp2([1,1,1,1])
||||a:pnat list
||||b:pnat list
||||==>even(length(app(nil,nil)))=even(0)in u(1)
||||SELECTED METHOD at depth 4: eval_def([2,1],even1)
|||||evenlenapp2([1,1,1,1,1])
|||||a:pnat list
|||||b:pnat list
|||||==>even(length(app(nil,nil)))={true}in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,1,1],app1)
||||||evenlenapp2([1,1,1,1,1,1])
||||||a:pnat list
||||||b:pnat list
||||||==>even(length(nil))={true}in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],length1)
|||||||evenlenapp2([1,1,1,1,1,1,1])
|||||||a:pnat list
|||||||b:pnat list
|||||||==>even(0)={true}in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1],even1)
||||||||evenlenapp2([1,1,1,1,1,1,1,1])
||||||||a:pnat list
||||||||b:pnat list
||||||||==>{true}={true}in u(1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning complete for evenlenapp2

------------------------------------------------------------
evenlenapp2:

[a:pnat list,b:pnat list]

|- even(length(app(a,b)))=even(length(app(b,a)))in u(1)

induction([v0::v1::b],[b:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     induction([v0::v1::a],[a:pnat list]) then 
       [eval_def([1,2,1],length1) then 
          eval_def([2,1],even1) then 
            eval_def([1,1,1,1],app1) then 
              eval_def([1,1,1],length1) then 
                eval_def([1,1],even1) then 
                  elementary(...),
        eval_def([1,2,1],length2) then 
          eval_def([1,1,2,1],length1) then 
            eval_def([2,1],even2) then 
              eval_def([1,1,1,1],app2) then 
                eval_def([1,1,1],length2) then 
                  eval_def([1,1,1,1,1],app1) then 
                    eval_def([1,1,1,1],length1) then 
                      eval_def([1,1],even2) then 
                        elementary(...),
        wave([1,2,1],[length2,equ(left)]) then 
          wave([1,1,2,1],[length2,equ(left)]) then 
            wave([2,1],[even3,equ(left)]) then 
              wave([1,1,1,1],[app2,equ(left)]) then 
                wave([2,1,1,1,1],[app2,equ(left)]) then 
                  wave([1,1,1],[length2,equ(left)]) then 
                    wave([1,1,1,1],[length2,equ(left)]) then 
                      wave([1,1],[even3,equ(left)]) then 
                        fertilize(strong(v2))
       ],
   eval_def([1,1,2,1],app2) then 
     eval_def([1,2,1],length2) then 
       eval_def([1,1,1,2,1],app1) then 
         induction([v1::v2::a],[a:pnat list]) then 
           [eval_def([1,1,2,1],length1) then 
              eval_def([2,1],even2) then 
                eval_def([1,1,1,1],app1) then 
                  eval_def([1,1,1],length2) then 
                    eval_def([1,1,1,1],length1) then 
                      eval_def([1,1],even2) then 
                        elementary(...),
            eval_def([1,1,2,1],length2) then 
              eval_def([2,1],even3) then 
                eval_def([1,2,1],length1) then 
                  eval_def([2,1],even1) then 
                    eval_def([1,1,1,1],app2) then 
                      eval_def([1,1,1],length2) then 
                        eval_def([1,1,1,1,1],app1) then 
                          eval_def([1,1,1,1],length2) then 
                            eval_def([1,1],even3) then 
                              eval_def([1,1,1],length1) then 
                                eval_def([1,1],even1) then 
                                  elementary(...),
            wave([1,1,2,1],[length2,equ(left)]) then 
              wave([1,1,1,2,1],[length2,equ(left)]) then 
                wave([1,2,1],[ssid,equ(left)]) then 
                  wave([1,1,2,1],[ssid,equ(left)]) then 
                    wave([2,1],[even3,equ(left)]) then 
                      wave([1,1,1,1],[app2,equ(left)]) then 
                        wave([2,1,1,1,1],[app2,equ(left)]) then 
                          wave([1,1,1],[length2,equ(left)]) then 
                            wave([1,1,1,1],[length2,equ(left)]) then 
                              wave([1,1],[even3,equ(left)]) then 
                                fertilize(strong(v3))
           ],
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([2,1,1,2,1],[app2,equ(left)]) then 
       wave([1,2,1],[length2,equ(left)]) then 
         wave([1,1,2,1],[length2,equ(left)]) then 
           wave([2,1],[even3,equ(left)]) then 
             wave([1,1],[lemma1,equ(left)]) then 
               fertilize(strong(v2))
  ]

------------------------------------------------------------
lemma1:

[a:pnat list,b:pnat list,v0:pnat,v1:pnat]

|- even(length(app(a,v0::v1::b)))=even(length(app(a,b)))in u(1)

induction([v2::v3::a],[a:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     eval_def([1,1,1,1],app1) then 
       eval_def([1,1,1],length2) then 
         eval_def([1,1,1,1],length2) then 
           eval_def([1,1],even3) then 
             elementary(...),
   eval_def([1,1,2,1],app2) then 
     eval_def([1,2,1],length2) then 
       eval_def([1,1,1,2,1],app1) then 
         eval_def([1,1,1,1],app2) then 
           eval_def([1,1,1],length2) then 
             eval_def([1,1,1,1,1],app1) then 
               eval_def([1,1,1,1],length2) then 
                 eval_def([1,1],even3) then 
                   eval_def([1,1,1],length2) then 
                     elementary(...),
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([2,1,1,2,1],[app2,equ(left)]) then 
       wave([1,2,1],[length2,equ(left)]) then 
         wave([1,1,2,1],[length2,equ(left)]) then 
           wave([2,1],[even3,equ(left)]) then 
             wave([1,1,1,1],[app2,equ(left)]) then 
               wave([2,1,1,1,1],[app2,equ(left)]) then 
                 wave([1,1,1],[length2,equ(left)]) then 
                   wave([1,1,1,1],[length2,equ(left)]) then 
                     wave([1,1],[even3,equ(left)]) then 
                       fertilize(strong(v4))
  ]


PLANNING for evenlenapp2 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave(ssid)...done
deleting theorem record for evenlenapp2...done
deleting thm(evenlenapp2)...done
loading synth(half)...done
loading synth(half)...done
loading def(half)...done
loading eqn(half1)...done
loading eqn(half2)...done
loading eqn(half3)...done
 adding wave-rules for half1:..done
 adding wave-rules for half2:..done
 adding wave-rules for half3:..............done
 adding defeqn-record for half1...done 
 adding defeqn-record for half2...done 
 adding defeqn-record for half3...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading synth(even)...done
loading def(true)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(ssid)...done
 adding wave-rules for ssid:......done
loading thm(halflenapp1)...done
halflenapp1([])
==>a:pnat list=>b:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat
SELECTED METHOD at depth 0: induction([v0::b],[b:pnat list])
|halflenapp1([2])
|v0:pnat
|b:pnat list
|v1:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|==>a:pnat list=>half(length(app(\a/,``v0::{b}''<out>)))=half(length(app(``v0::{b}''<out>,\a/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||halflenapp1([1,2])
||v0:pnat
||b:pnat list
||v1:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||==>a:pnat list=>half(length(app(\a/,``v0::{b}''<out>)))=half(length(``v0::{app(b,\a/)}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[length2,equ(left)])
|||halflenapp1([1,1,2])
|||v0:pnat
|||b:pnat list
|||v1:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|||==>a:pnat list=>half(length(app(\a/,``v0::{b}''<out>)))=half(``s({length(app(b,\a/))})''<out>)in pnat

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([v0::v1::b],[b:pnat list])
|halflenapp1([3])
|v0:pnat
|v1:pnat
|b:pnat list
|v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(length(app(``v0::v1::{b}''<out>,\a/)))in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|halflenapp1([3])
|v0:pnat
|v1:pnat
|b:pnat list
|v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(length(app(``v0::{``v1::{b}''<out>}''<out>,\a/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[app2,equ(left)])
||halflenapp1([1,3])
||v0:pnat
||v1:pnat
||b:pnat list
||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(length(``v0::{app(``v1::{b}''<out>,\a/)}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([2,1,1,2,1],[app2,equ(left)])
|||halflenapp1([1,1,3])
|||v0:pnat
|||v1:pnat
|||b:pnat list
|||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(length(``v0::{``v1::{app(b,\a/)}''<out>}''<out>))in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||halflenapp1([1,1,1,3])
||||v0:pnat
||||v1:pnat
||||b:pnat list
||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(``s({length(``v1::{app(b,\a/)}''<out>)})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1,2,1],[length2,equ(left)])
|||||halflenapp1([1,1,1,1,3])
|||||v0:pnat
|||||v1:pnat
|||||b:pnat list
|||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|||||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=half(``s({``s({length(app(b,\a/))})''<out>})''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1],[half3,equ(left)])
||||||halflenapp1([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||||||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=``s({half(length(app(b,\a/)))})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[a:pnat list,b:pnat list,v0:pnat,v1:pnat]

|- length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat

saving thm(lemma1)...done
lemma1([])
==>a:pnat list=>b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat
SELECTED METHOD at depth 0: induction([v2::a],[a:pnat list])
|lemma1([2])
|v2:pnat
|a:pnat list
|v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
|==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/))=s(s(length(app(``v2::{a}''<out>,\b/))))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1,2,1],[app2,equ(left)])
||lemma1([1,2])
||v2:pnat
||a:pnat list
||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
||==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/))=s(s(length(``v2::{app(a,\b/)}''<out>)))in pnat
||SELECTED METHOD at depth 2: wave([1,1,2,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v2:pnat
|||a:pnat list
|||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
|||==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/))=s(s(``s({length(app(a,\b/))})''<out>))in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[ssid,equ(left)])
||||lemma1([1,1,1,2])
||||v2:pnat
||||a:pnat list
||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
||||==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/))=s(``s({s(length(app(a,\b/)))})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[ssid,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(``v2::{a}''<out>,\v0/ ::\v1/ ::\b/))=``s({s(s(length(app(a,\b/))))})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v2:pnat
||||||a:pnat list
||||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
||||||==>b:pnat list=>v0:pnat=>v1:pnat=>length(``v2::{app(a,\v0/ ::\v1/ ::\b/)}''<out>)=``s({s(s(length(app(a,\b/))))})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1],[length2,equ(left)])
|||||||lemma1([1,1,1,1,1,1,2])
|||||||v2:pnat
|||||||a:pnat list
|||||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
|||||||==>b:pnat list=>v0:pnat=>v1:pnat=>``s({length(app(a,\v0/ ::\v1/ ::\b/))})''<out> =``s({s(s(length(app(a,\b/))))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: fertilize(weak(v3))
||||||||lemma1([1,1,1,1,1,1,1,2])
||||||||v2:pnat
||||||||a:pnat list
||||||||v3:ih(b:pnat list=>v0:pnat=>v1:pnat=>length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat)
||||||||==>s(length(app(a,v0::v1::b)))=s(length(app(a,_191149::_191152::b)))in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
|lemma1([1])
|a:pnat list
|==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(nil,v0::v1::b))=s(s(length(app(nil,b))))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,1,2,1],app1)
||lemma1([1,1])
||a:pnat list
||==>b:pnat list=>v0:pnat=>v1:pnat=>length(app(nil,v0::v1::b))=s(s(length(b)))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||a:pnat list
|||==>b:pnat list=>v0:pnat=>v1:pnat=>length(v0::v1::b)=s(s(length(b)))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||a:pnat list
||||==>b:pnat list=>v0:pnat=>v1:pnat=>s(length(v1::b))=s(s(length(b)))in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],length2)
|||||lemma1([1,1,1,1,1])
|||||a:pnat list
|||||==>b:pnat list=>v0:pnat=>v1:pnat=>s(s(length(b)))=s(s(length(b)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.....................................done
||||||halflenapp1([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||||||==>a:pnat list=>half(length(app(\a/,``v0::v1::{b}''<out>)))=``s({half(length(app(b,\a/)))})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||halflenapp1([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||b:pnat list
||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||||||==>a:pnat list=>half(length(app(\a/,``v0::{``v1::{b}''<out>}''<out>)))=``s({half(length(app(b,\a/)))})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1],[lemma1,equ(left)])
|||||||halflenapp1([1,1,1,1,1,1,3])
|||||||v0:pnat
|||||||v1:pnat
|||||||b:pnat list
|||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|||||||==>a:pnat list=>half(``s({``s({length(app(\a/,b))})''<out>})''<out>)=``s({half(length(app(b,\a/)))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: wave([1,1],[half3,equ(left)])
||||||||halflenapp1([1,1,1,1,1,1,1,3])
||||||||v0:pnat
||||||||v1:pnat
||||||||b:pnat list
||||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
||||||||==>a:pnat list=>``s({half(length(app(\a/,b)))})''<out> =``s({half(length(app(b,\a/)))})''<out>in pnat
||||||||SELECTED METHOD at depth 8: fertilize(weak(v2))
|||||||||halflenapp1([1,1,1,1,1,1,1,1,3])
|||||||||v0:pnat
|||||||||v1:pnat
|||||||||b:pnat list
|||||||||v2:ih(a:pnat list=>half(length(app(a,b)))=half(length(app(b,a)))in pnat)
|||||||||==>s(half(length(app(a,b))))=s(half(length(app(a,b))))in pnat
|||||||||TERMINATING METHOD at depth 9: elementary(...)
|halflenapp1([2])
|v0:pnat
|b:pnat list
|==>a:pnat list=>half(length(app(a,v0::nil)))=half(length(app(v0::nil,a)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app2)
||halflenapp1([1,2])
||v0:pnat
||b:pnat list
||==>a:pnat list=>half(length(app(a,v0::nil)))=half(length(v0::app(nil,a)))in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],length2)
|||halflenapp1([1,1,2])
|||v0:pnat
|||b:pnat list
|||==>a:pnat list=>half(length(app(a,v0::nil)))=half(s(length(app(nil,a))))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1,1,2,1],app1)
||||halflenapp1([1,1,1,2])
||||v0:pnat
||||b:pnat list
||||==>a:pnat list=>half(length(app(a,v0::nil)))=half(s(length(a)))in pnat
||||SELECTED METHOD at depth 4: induction([v1::a],[a:pnat list])
|||||halflenapp1([2,1,1,1,2])
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||v0:pnat
|||||b:pnat list
|||||==>half(length(app(``v1::{a}''<out>,v0::nil)))=half(s(length(``v1::{a}''<out>)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[length2,equ(left)])
||||||halflenapp1([1,2,1,1,1,2])
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||v0:pnat
||||||b:pnat list
||||||==>half(length(app(``v1::{a}''<out>,v0::nil)))=half(s(``s({length(a)})''<out>))in pnat
||||||SELECTED METHOD at depth 6: wave([1,2,1],[ssid,equ(left)])
|||||||halflenapp1([1,1,2,1,1,1,2])
|||||||v1:pnat
|||||||a:pnat list
|||||||v2:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||v0:pnat
|||||||b:pnat list
|||||||==>half(length(app(``v1::{a}''<out>,v0::nil)))=half(``s({s(length(a))})''<out>)in pnat
|||||||SELECTED METHOD at depth 7: wave([1,1,1,1],[app2,equ(left)])
||||||||halflenapp1([1,1,1,2,1,1,1,2])
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||v0:pnat
||||||||b:pnat list
||||||||==>half(length(``v1::{app(a,v0::nil)}''<out>))=half(``s({s(length(a))})''<out>)in pnat
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[length2,equ(left)])
|||||||||halflenapp1([1,1,1,1,2,1,1,1,2])
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v2:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>half(``s({length(app(a,v0::nil))})''<out>)=half(``s({s(length(a))})''<out>)in pnat

>>>>> INVOKING induction-revision CRITIC <<<<<

||||SELECTED METHOD at depth 4: induction([v1::v2::a],[a:pnat list])
|||||halflenapp1([3,1,1,1,2])
|||||v1:pnat
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||v0:pnat
|||||b:pnat list
|||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(s(length(``v1::v2::{a}''<out>)))in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||halflenapp1([3,1,1,1,2])
|||||v1:pnat
|||||v2:pnat
|||||a:pnat list
|||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||v0:pnat
|||||b:pnat list
|||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(s(length(``v1::{``v2::{a}''<out>}''<out>)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[length2,equ(left)])
||||||halflenapp1([1,3,1,1,1,2])
||||||v1:pnat
||||||v2:pnat
||||||a:pnat list
||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||v0:pnat
||||||b:pnat list
||||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(s(``s({length(``v2::{a}''<out>)})''<out>))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,1],[length2,equ(left)])
|||||||halflenapp1([1,1,3,1,1,1,2])
|||||||v1:pnat
|||||||v2:pnat
|||||||a:pnat list
|||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||v0:pnat
|||||||b:pnat list
|||||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(s(``s({``s({length(a)})''<out>})''<out>))in pnat
|||||||SELECTED METHOD at depth 7: wave([1,2,1],[ssid,equ(left)])
||||||||halflenapp1([1,1,1,3,1,1,1,2])
||||||||v1:pnat
||||||||v2:pnat
||||||||a:pnat list
||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||v0:pnat
||||||||b:pnat list
||||||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(``s({s(``s({length(a)})''<out>)})''<out>)in pnat
||||||||SELECTED METHOD at depth 8: wave([1,1,2,1],[ssid,equ(left)])
|||||||||halflenapp1([1,1,1,1,3,1,1,1,2])
|||||||||v1:pnat
|||||||||v2:pnat
|||||||||a:pnat list
|||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=half(``s({``s({s(length(a))})''<out>})''<out>)in pnat
|||||||||SELECTED METHOD at depth 9: wave([2,1],[half3,equ(left)])
||||||||||halflenapp1([1,1,1,1,1,3,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:pnat
||||||||||a:pnat list
||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>half(length(app(``v1::v2::{a}''<out>,v0::nil)))=``s({half(s(length(a)))})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||||||halflenapp1([1,1,1,1,1,3,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:pnat
||||||||||a:pnat list
||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>half(length(app(``v1::{``v2::{a}''<out>}''<out>,v0::nil)))=``s({half(s(length(a)))})''<out>in pnat
||||||||||SELECTED METHOD at depth 10: wave([1,1,1,1],[app2,equ(left)])
|||||||||||halflenapp1([1,1,1,1,1,1,3,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v2:pnat
|||||||||||a:pnat list
|||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>half(length(``v1::{app(``v2::{a}''<out>,v0::nil)}''<out>))=``s({half(s(length(a)))})''<out>in pnat
|||||||||||SELECTED METHOD at depth 11: wave([2,1,1,1,1],[app2,equ(left)])
||||||||||||halflenapp1([1,1,1,1,1,1,1,3,1,1,1,2])
||||||||||||v1:pnat
||||||||||||v2:pnat
||||||||||||a:pnat list
||||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||||||v0:pnat
||||||||||||b:pnat list
||||||||||||==>half(length(``v1::{``v2::{app(a,v0::nil)}''<out>}''<out>))=``s({half(s(length(a)))})''<out>in pnat
||||||||||||SELECTED METHOD at depth 12: wave([1,1,1],[length2,equ(left)])
|||||||||||||halflenapp1([1,1,1,1,1,1,1,1,3,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||v2:pnat
|||||||||||||a:pnat list
|||||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||||||||v0:pnat
|||||||||||||b:pnat list
|||||||||||||==>half(``s({length(``v2::{app(a,v0::nil)}''<out>)})''<out>)=``s({half(s(length(a)))})''<out>in pnat
|||||||||||||SELECTED METHOD at depth 13: wave([1,1,1,1],[length2,equ(left)])
||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,3,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||v2:pnat
||||||||||||||a:pnat list
||||||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||||||||v0:pnat
||||||||||||||b:pnat list
||||||||||||||==>half(``s({``s({length(app(a,v0::nil))})''<out>})''<out>)=``s({half(s(length(a)))})''<out>in pnat
||||||||||||||SELECTED METHOD at depth 14: wave([1,1],[half3,equ(left)])
|||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,1,3,1,1,1,2])
|||||||||||||||v1:pnat
|||||||||||||||v2:pnat
|||||||||||||||a:pnat list
|||||||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
|||||||||||||||v0:pnat
|||||||||||||||b:pnat list
|||||||||||||||==>``s({half(length(app(a,v0::nil)))})''<out> =``s({half(s(length(a)))})''<out>in pnat
|||||||||||||||SELECTED METHOD at depth 15: fertilize(weak(v3))
||||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,2])
||||||||||||||||v1:pnat
||||||||||||||||v2:pnat
||||||||||||||||a:pnat list
||||||||||||||||v3:ih(half(length(app(a,v0::nil)))=half(s(length(a)))in pnat)
||||||||||||||||v0:pnat
||||||||||||||||b:pnat list
||||||||||||||||==>s(half(length(app(a,v0::nil))))=s(half(length(app(a,v0::nil))))in pnat
||||||||||||||||TERMINATING METHOD at depth 16: elementary(...)
|||||halflenapp1([2,1,1,1,2])
|||||v1:pnat
|||||a:pnat list
|||||v0:pnat
|||||b:pnat list
|||||==>half(length(app(v1::nil,v0::nil)))=half(s(length(v1::nil)))in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,2,1],length2)
||||||halflenapp1([1,2,1,1,1,2])
||||||v1:pnat
||||||a:pnat list
||||||v0:pnat
||||||b:pnat list
||||||==>half(length(app(v1::nil,v0::nil)))=half(s(s(length(nil))))in pnat
||||||SELECTED METHOD at depth 6: eval_def([2,1],half3)
|||||||halflenapp1([1,1,2,1,1,1,2])
|||||||v1:pnat
|||||||a:pnat list
|||||||v0:pnat
|||||||b:pnat list
|||||||==>half(length(app(v1::nil,v0::nil)))=s(half(length(nil)))in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1,2,1],length1)
||||||||halflenapp1([1,1,1,2,1,1,1,2])
||||||||v1:pnat
||||||||a:pnat list
||||||||v0:pnat
||||||||b:pnat list
||||||||==>half(length(app(v1::nil,v0::nil)))=s(half(0))in pnat
||||||||SELECTED METHOD at depth 8: eval_def([1,2,1],half1)
|||||||||halflenapp1([1,1,1,1,2,1,1,1,2])
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>half(length(app(v1::nil,v0::nil)))=s(0)in pnat
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],app2)
||||||||||halflenapp1([1,1,1,1,1,2,1,1,1,2])
||||||||||v1:pnat
||||||||||a:pnat list
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>half(length(v1::app(nil,v0::nil)))=s(0)in pnat
||||||||||SELECTED METHOD at depth 10: eval_def([1,1,1],length2)
|||||||||||halflenapp1([1,1,1,1,1,1,2,1,1,1,2])
|||||||||||v1:pnat
|||||||||||a:pnat list
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>half(s(length(app(nil,v0::nil))))=s(0)in pnat
|||||||||||SELECTED METHOD at depth 11: eval_def([1,1,1,1,1],app1)
||||||||||||halflenapp1([1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||v1:pnat
||||||||||||a:pnat list
||||||||||||v0:pnat
||||||||||||b:pnat list
||||||||||||==>half(s(length(v0::nil)))=s(0)in pnat
||||||||||||SELECTED METHOD at depth 12: eval_def([1,1,1,1],length2)
|||||||||||||halflenapp1([1,1,1,1,1,1,1,1,2,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||a:pnat list
|||||||||||||v0:pnat
|||||||||||||b:pnat list
|||||||||||||==>half(s(s(length(nil))))=s(0)in pnat
|||||||||||||SELECTED METHOD at depth 13: eval_def([1,1],half3)
||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||a:pnat list
||||||||||||||v0:pnat
||||||||||||||b:pnat list
||||||||||||||==>s(half(length(nil)))=s(0)in pnat
||||||||||||||SELECTED METHOD at depth 14: eval_def([1,1,1,1],length1)
|||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,1,2,1,1,1,2])
|||||||||||||||v1:pnat
|||||||||||||||a:pnat list
|||||||||||||||v0:pnat
|||||||||||||||b:pnat list
|||||||||||||||==>s(half(0))=s(0)in pnat
|||||||||||||||SELECTED METHOD at depth 15: eval_def([1,1,1],half1)
||||||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2])
||||||||||||||||v1:pnat
||||||||||||||||a:pnat list
||||||||||||||||v0:pnat
||||||||||||||||b:pnat list
||||||||||||||||==>s(0)=s(0)in pnat
||||||||||||||||TERMINATING METHOD at depth 16: elementary(...)
|||||halflenapp1([1,1,1,1,2])
|||||a:pnat list
|||||v0:pnat
|||||b:pnat list
|||||==>half(length(app(nil,v0::nil)))=half(s(length(nil)))in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,2,1],length1)
||||||halflenapp1([1,1,1,1,1,2])
||||||a:pnat list
||||||v0:pnat
||||||b:pnat list
||||||==>half(length(app(nil,v0::nil)))=half(s(0))in pnat
||||||SELECTED METHOD at depth 6: eval_def([2,1],half2)
|||||||halflenapp1([1,1,1,1,1,1,2])
|||||||a:pnat list
|||||||v0:pnat
|||||||b:pnat list
|||||||==>half(length(app(nil,v0::nil)))=0 in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1,1],app1)
||||||||halflenapp1([1,1,1,1,1,1,1,2])
||||||||a:pnat list
||||||||v0:pnat
||||||||b:pnat list
||||||||==>half(length(v0::nil))=0 in pnat
||||||||SELECTED METHOD at depth 8: eval_def([1,1,1],length2)
|||||||||halflenapp1([1,1,1,1,1,1,1,1,2])
|||||||||a:pnat list
|||||||||v0:pnat
|||||||||b:pnat list
|||||||||==>half(s(length(nil)))=0 in pnat
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],length1)
||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,2])
||||||||||a:pnat list
||||||||||v0:pnat
||||||||||b:pnat list
||||||||||==>half(s(0))=0 in pnat
||||||||||SELECTED METHOD at depth 10: eval_def([1,1],half2)
|||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,1,2])
|||||||||||a:pnat list
|||||||||||v0:pnat
|||||||||||b:pnat list
|||||||||||==>0=0 in pnat
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
|halflenapp1([1])
|b:pnat list
|==>a:pnat list=>half(length(app(a,nil)))=half(length(app(nil,a)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1,2,1],app1)
||halflenapp1([1,1])
||b:pnat list
||==>a:pnat list=>half(length(app(a,nil)))=half(length(a))in pnat
||SELECTED METHOD at depth 2: induction([v0::a],[a:pnat list])
|||halflenapp1([2,1,1])
|||v0:pnat
|||a:pnat list
|||v1:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||b:pnat list
|||==>half(length(app(``v0::{a}''<out>,nil)))=half(length(``v0::{a}''<out>))in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||halflenapp1([1,2,1,1])
||||v0:pnat
||||a:pnat list
||||v1:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||b:pnat list
||||==>half(length(app(``v0::{a}''<out>,nil)))=half(``s({length(a)})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1,1],[app2,equ(left)])
|||||halflenapp1([1,1,2,1,1])
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||||b:pnat list
|||||==>half(length(``v0::{app(a,nil)}''<out>))=half(``s({length(a)})''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1],[length2,equ(left)])
||||||halflenapp1([1,1,1,2,1,1])
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||b:pnat list
||||||==>half(``s({length(app(a,nil))})''<out>)=half(``s({length(a)})''<out>)in pnat

>>>>> INVOKING induction-revision CRITIC <<<<<

||SELECTED METHOD at depth 2: induction([v0::v1::a],[a:pnat list])
|||halflenapp1([3,1,1])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||b:pnat list
|||==>half(length(app(``v0::v1::{a}''<out>,nil)))=half(length(``v0::v1::{a}''<out>))in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||halflenapp1([3,1,1])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||b:pnat list
|||==>half(length(app(``v0::v1::{a}''<out>,nil)))=half(length(``v0::{``v1::{a}''<out>}''<out>))in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[length2,equ(left)])
||||halflenapp1([1,3,1,1])
||||v0:pnat
||||v1:pnat
||||a:pnat list
||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||b:pnat list
||||==>half(length(app(``v0::v1::{a}''<out>,nil)))=half(``s({length(``v1::{a}''<out>)})''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([1,1,2,1],[length2,equ(left)])
|||||halflenapp1([1,1,3,1,1])
|||||v0:pnat
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||||b:pnat list
|||||==>half(length(app(``v0::v1::{a}''<out>,nil)))=half(``s({``s({length(a)})''<out>})''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1],[half3,equ(left)])
||||||halflenapp1([1,1,1,3,1,1])
||||||v0:pnat
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||b:pnat list
||||||==>half(length(app(``v0::v1::{a}''<out>,nil)))=``s({half(length(a))})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||halflenapp1([1,1,1,3,1,1])
||||||v0:pnat
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||b:pnat list
||||||==>half(length(app(``v0::{``v1::{a}''<out>}''<out>,nil)))=``s({half(length(a))})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,1],[app2,equ(left)])
|||||||halflenapp1([1,1,1,1,3,1,1])
|||||||v0:pnat
|||||||v1:pnat
|||||||a:pnat list
|||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||||||b:pnat list
|||||||==>half(length(``v0::{app(``v1::{a}''<out>,nil)}''<out>))=``s({half(length(a))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: wave([2,1,1,1,1],[app2,equ(left)])
||||||||halflenapp1([1,1,1,1,1,3,1,1])
||||||||v0:pnat
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||||b:pnat list
||||||||==>half(length(``v0::{``v1::{app(a,nil)}''<out>}''<out>))=``s({half(length(a))})''<out>in pnat
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[length2,equ(left)])
|||||||||halflenapp1([1,1,1,1,1,1,3,1,1])
|||||||||v0:pnat
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||||||||b:pnat list
|||||||||==>half(``s({length(``v1::{app(a,nil)}''<out>)})''<out>)=``s({half(length(a))})''<out>in pnat
|||||||||SELECTED METHOD at depth 9: wave([1,1,1,1],[length2,equ(left)])
||||||||||halflenapp1([1,1,1,1,1,1,1,3,1,1])
||||||||||v0:pnat
||||||||||v1:pnat
||||||||||a:pnat list
||||||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||||||b:pnat list
||||||||||==>half(``s({``s({length(app(a,nil))})''<out>})''<out>)=``s({half(length(a))})''<out>in pnat
||||||||||SELECTED METHOD at depth 10: wave([1,1],[half3,equ(left)])
|||||||||||halflenapp1([1,1,1,1,1,1,1,1,3,1,1])
|||||||||||v0:pnat
|||||||||||v1:pnat
|||||||||||a:pnat list
|||||||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
|||||||||||b:pnat list
|||||||||||==>``s({half(length(app(a,nil)))})''<out> =``s({half(length(a))})''<out>in pnat
|||||||||||SELECTED METHOD at depth 11: fertilize(weak(v2))
||||||||||||halflenapp1([1,1,1,1,1,1,1,1,1,3,1,1])
||||||||||||v0:pnat
||||||||||||v1:pnat
||||||||||||a:pnat list
||||||||||||v2:ih(half(length(app(a,nil)))=half(length(a))in pnat)
||||||||||||b:pnat list
||||||||||||==>s(half(length(app(a,nil))))=s(half(length(app(a,nil))))in pnat
||||||||||||TERMINATING METHOD at depth 12: elementary(...)
|||halflenapp1([2,1,1])
|||v0:pnat
|||a:pnat list
|||b:pnat list
|||==>half(length(app(v0::nil,nil)))=half(length(v0::nil))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,2,1],length2)
||||halflenapp1([1,2,1,1])
||||v0:pnat
||||a:pnat list
||||b:pnat list
||||==>half(length(app(v0::nil,nil)))=half(s(length(nil)))in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,2,1],length1)
|||||halflenapp1([1,1,2,1,1])
|||||v0:pnat
|||||a:pnat list
|||||b:pnat list
|||||==>half(length(app(v0::nil,nil)))=half(s(0))in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1],half2)
||||||halflenapp1([1,1,1,2,1,1])
||||||v0:pnat
||||||a:pnat list
||||||b:pnat list
||||||==>half(length(app(v0::nil,nil)))=0 in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1,1,1],app2)
|||||||halflenapp1([1,1,1,1,2,1,1])
|||||||v0:pnat
|||||||a:pnat list
|||||||b:pnat list
|||||||==>half(length(v0::app(nil,nil)))=0 in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1],length2)
||||||||halflenapp1([1,1,1,1,1,2,1,1])
||||||||v0:pnat
||||||||a:pnat list
||||||||b:pnat list
||||||||==>half(s(length(app(nil,nil))))=0 in pnat
||||||||SELECTED METHOD at depth 8: eval_def([1,1,1,1,1],app1)
|||||||||halflenapp1([1,1,1,1,1,1,2,1,1])
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||b:pnat list
|||||||||==>half(s(length(nil)))=0 in pnat
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1,1],length1)
||||||||||halflenapp1([1,1,1,1,1,1,1,2,1,1])
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||b:pnat list
||||||||||==>half(s(0))=0 in pnat
||||||||||SELECTED METHOD at depth 10: eval_def([1,1],half2)
|||||||||||halflenapp1([1,1,1,1,1,1,1,1,2,1,1])
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||b:pnat list
|||||||||||==>0=0 in pnat
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
|||halflenapp1([1,1,1])
|||a:pnat list
|||b:pnat list
|||==>half(length(app(nil,nil)))=half(length(nil))in pnat
|||SELECTED METHOD at depth 3: eval_def([1,2,1],length1)
||||halflenapp1([1,1,1,1])
||||a:pnat list
||||b:pnat list
||||==>half(length(app(nil,nil)))=half(0)in pnat
||||SELECTED METHOD at depth 4: eval_def([2,1],half1)
|||||halflenapp1([1,1,1,1,1])
|||||a:pnat list
|||||b:pnat list
|||||==>half(length(app(nil,nil)))=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,1,1],app1)
||||||halflenapp1([1,1,1,1,1,1])
||||||a:pnat list
||||||b:pnat list
||||||==>half(length(nil))=0 in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],length1)
|||||||halflenapp1([1,1,1,1,1,1,1])
|||||||a:pnat list
|||||||b:pnat list
|||||||==>half(0)=0 in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1],half1)
||||||||halflenapp1([1,1,1,1,1,1,1,1])
||||||||a:pnat list
||||||||b:pnat list
||||||||==>0=0 in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning complete for halflenapp1

------------------------------------------------------------
halflenapp1:

[a:pnat list,b:pnat list]

|- half(length(app(a,b)))=half(length(app(b,a)))in pnat

induction([v0::v1::b],[b:pnat list]) then 
  [eval_def([1,1,2,1],app1) then 
     induction([v0::v1::a],[a:pnat list]) then 
       [eval_def([1,2,1],length1) then 
          eval_def([2,1],half1) then 
            eval_def([1,1,1,1],app1) then 
              eval_def([1,1,1],length1) then 
                eval_def([1,1],half1) then 
                  elementary(...),
        eval_def([1,2,1],length2) then 
          eval_def([1,1,2,1],length1) then 
            eval_def([2,1],half2) then 
              eval_def([1,1,1,1],app2) then 
                eval_def([1,1,1],length2) then 
                  eval_def([1,1,1,1,1],app1) then 
                    eval_def([1,1,1,1],length1) then 
                      eval_def([1,1],half2) then 
                        elementary(...),
        wave([1,2,1],[length2,equ(left)]) then 
          wave([1,1,2,1],[length2,equ(left)]) then 
            wave([2,1],[half3,equ(left)]) then 
              wave([1,1,1,1],[app2,equ(left)]) then 
                wave([2,1,1,1,1],[app2,equ(left)]) then 
                  wave([1,1,1],[length2,equ(left)]) then 
                    wave([1,1,1,1],[length2,equ(left)]) then 
                      wave([1,1],[half3,equ(left)]) then 
                        fertilize(weak(v2)) then 
                          elementary(...)
       ],
   eval_def([1,1,2,1],app2) then 
     eval_def([1,2,1],length2) then 
       eval_def([1,1,1,2,1],app1) then 
         induction([v1::v2::a],[a:pnat list]) then 
           [eval_def([1,1,2,1],length1) then 
              eval_def([2,1],half2) then 
                eval_def([1,1,1,1],app1) then 
                  eval_def([1,1,1],length2) then 
                    eval_def([1,1,1,1],length1) then 
                      eval_def([1,1],half2) then 
                        elementary(...),
            eval_def([1,1,2,1],length2) then 
              eval_def([2,1],half3) then 
                eval_def([1,1,2,1],length1) then 
                  eval_def([1,2,1],half1) then 
                    eval_def([1,1,1,1],app2) then 
                      eval_def([1,1,1],length2) then 
                        eval_def([1,1,1,1,1],app1) then 
                          eval_def([1,1,1,1],length2) then 
                            eval_def([1,1],half3) then 
                              eval_def([1,1,1,1],length1) then 
                                eval_def([1,1,1],half1) then 
                                  elementary(...),
            wave([1,1,2,1],[length2,equ(left)]) then 
              wave([1,1,1,2,1],[length2,equ(left)]) then 
                wave([1,2,1],[ssid,equ(left)]) then 
                  wave([1,1,2,1],[ssid,equ(left)]) then 
                    wave([2,1],[half3,equ(left)]) then 
                      wave([1,1,1,1],[app2,equ(left)]) then 
                        wave([2,1,1,1,1],[app2,equ(left)]) then 
                          wave([1,1,1],[length2,equ(left)]) then 
                            wave([1,1,1,1],[length2,equ(left)]) then 
                              wave([1,1],[half3,equ(left)]) then 
                                fertilize(weak(v3)) then 
                                  elementary(...)
           ],
   wave([1,1,2,1],[app2,equ(left)]) then 
     wave([2,1,1,2,1],[app2,equ(left)]) then 
       wave([1,2,1],[length2,equ(left)]) then 
         wave([1,1,2,1],[length2,equ(left)]) then 
           wave([2,1],[half3,equ(left)]) then 
             wave([1,1,1],[lemma1,equ(left)]) then 
               wave([1,1],[half3,equ(left)]) then 
                 fertilize(weak(v2)) then 
                   elementary(...)
  ]

------------------------------------------------------------
lemma1:

[a:pnat list,b:pnat list,v0:pnat,v1:pnat]

|- length(app(a,v0::v1::b))=s(s(length(app(a,b))))in pnat

induction([v2::a],[a:pnat list]) then 
  [eval_def([1,1,1,2,1],app1) then 
     eval_def([1,1,1],app1) then 
       eval_def([1,1],length2) then 
         eval_def([1,1,1],length2) then 
           elementary(...),
   wave([1,1,1,2,1],[app2,equ(left)]) then 
     wave([1,1,2,1],[length2,equ(left)]) then 
       wave([1,2,1],[ssid,equ(left)]) then 
         wave([2,1],[ssid,equ(left)]) then 
           wave([1,1,1],[app2,equ(left)]) then 
             wave([1,1],[length2,equ(left)]) then 
               fertilize(weak(v3)) then 
                 elementary(...)
  ]


PLANNING for halflenapp1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for half...done
deleting synth(half)...done
deleting def(half)...done
deleting theorem record for half1...done
deleting wave record for half1...done
deleting wave record for half1...done
deleting func_defeqn record for half1...done
deleting wave(half1)...done
deleting theorem record for half2...done
deleting wave record for half2...done
deleting wave record for half2...done
deleting func_defeqn record for half2...done
deleting wave(half2)...done
deleting theorem record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting func_defeqn record for half3...done
deleting wave(half3)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave(ssid)...done
deleting theorem record for halflenapp1...done
deleting thm(halflenapp1)...done
loading synth(even)...done
loading def(true)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading thm(ssid)...done
 adding wave-rules for ssid:......done
loading thm(evenplus2)...done
evenplus2([])
==>x:pnat=>y:pnat=>even(plus(x,y))=even(plus(y,x))in u(1)
SELECTED METHOD at depth 0: induction([s(y)],[y:pnat])
|evenplus2([2])
|y:pnat
|v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
|==>x:pnat=>even(plus(\x/,``s({y})''<out>))=even(plus(``s({y})''<out>,\x/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||evenplus2([1,2])
||y:pnat
||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
||==>x:pnat=>even(plus(\x/,``s({y})''<out>))=even(``s({plus(y,\x/)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([s(s(y))],[y:pnat])
|evenplus2([3])
|y:pnat
|v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
|==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(plus(``s(s({y}))''<out>,\x/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|evenplus2([3])
|y:pnat
|v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
|==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(plus(``s({``s({y})''<out>})''<out>,\x/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||evenplus2([1,3])
||y:pnat
||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
||==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(``s({plus(``s({y})''<out>,\x/)})''<out>)in u(1)
||SELECTED METHOD at depth 2: wave([1,1,2,1],[plus2,equ(left)])
|||evenplus2([1,1,3])
|||y:pnat
|||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
|||==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(``s({``s({plus(y,\x/)})''<out>})''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([2,1],[even3,equ(left)])
||||evenplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
||||==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(plus(y,\x/))in u(1)

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[x:pnat,y:pnat]

|- even(plus(x,s(s(y))))=even(plus(x,y))in u(1)

saving thm(lemma1)...done
lemma1([])
==>x:pnat=>y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1)
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|==>y:pnat=>even(plus(``s({x})''<out>,s(s(\y/))))=even(plus(``s({x})''<out>,\y/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
||==>y:pnat=>even(plus(``s({x})''<out>,s(s(\y/))))=even(``s({plus(x,\y/)})''<out>)in u(1)
||SELECTED METHOD at depth 2: wave([1,1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|||==>y:pnat=>even(``s({plus(x,s(s(\y/)))})''<out>)=even(``s({plus(x,\y/)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([s(s(x))],[x:pnat])
|lemma1([3])
|x:pnat
|v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|==>y:pnat=>even(plus(``s(s({x}))''<out>,s(s(\y/))))=even(plus(``s(s({x}))''<out>,\y/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|lemma1([3])
|x:pnat
|v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|==>y:pnat=>even(plus(``s(s({x}))''<out>,s(s(\y/))))=even(plus(``s({``s({x})''<out>})''<out>,\y/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,3])
||x:pnat
||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
||==>y:pnat=>even(plus(``s(s({x}))''<out>,s(s(\y/))))=even(``s({plus(``s({x})''<out>,\y/)})''<out>)in u(1)
||SELECTED METHOD at depth 2: wave([1,1,2,1],[plus2,equ(left)])
|||lemma1([1,1,3])
|||x:pnat
|||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|||==>y:pnat=>even(plus(``s(s({x}))''<out>,s(s(\y/))))=even(``s({``s({plus(x,\y/)})''<out>})''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([2,1],[even3,equ(left)])
||||lemma1([1,1,1,3])
||||x:pnat
||||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
||||==>y:pnat=>even(plus(``s(s({x}))''<out>,s(s(\y/))))=even(plus(x,\y/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||lemma1([1,1,1,3])
||||x:pnat
||||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
||||==>y:pnat=>even(plus(``s({``s({x})''<out>})''<out>,s(s(\y/))))=even(plus(x,\y/))in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,1],[plus2,equ(left)])
|||||lemma1([1,1,1,1,3])
|||||x:pnat
|||||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|||||==>y:pnat=>even(``s({plus(``s({x})''<out>,s(s(\y/)))})''<out>)=even(plus(x,\y/))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[plus2,equ(left)])
||||||lemma1([1,1,1,1,1,3])
||||||x:pnat
||||||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
||||||==>y:pnat=>even(``s({``s({plus(x,s(s(\y/)))})''<out>})''<out>)=even(plus(x,\y/))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[even3,equ(left)])
|||||||lemma1([1,1,1,1,1,1,3])
|||||||x:pnat
|||||||v0:ih(y:pnat=>even(plus(x,s(s(y))))=even(plus(x,y))in u(1))
|||||||==>y:pnat=>even(plus(x,s(s(\y/))))=even(plus(x,\y/))in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v0))
|lemma1([2])
|x:pnat
|==>y:pnat=>even(plus(s(0),s(s(y))))=even(plus(s(0),y))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus2)
||lemma1([1,2])
||x:pnat
||==>y:pnat=>even(plus(s(0),s(s(y))))=even(s(plus(0,y)))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,2,1],plus1)
|||lemma1([1,1,2])
|||x:pnat
|||==>y:pnat=>even(plus(s(0),s(s(y))))=even(s(y))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1],plus2)
||||lemma1([1,1,1,2])
||||x:pnat
||||==>y:pnat=>even(s(plus(0,s(s(y)))))=even(s(y))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],plus1)
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||==>y:pnat=>even(s(s(s(y))))=even(s(y))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even3)
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||==>y:pnat=>even(s(y))=even(s(y))in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|x:pnat
|==>y:pnat=>even(plus(0,s(s(y))))=even(plus(0,y))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus1)
||lemma1([1,1])
||x:pnat
||==>y:pnat=>even(plus(0,s(s(y))))=even(y)in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,1],plus1)
|||lemma1([1,1,1])
|||x:pnat
|||==>y:pnat=>even(s(s(y)))=even(y)in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1],even3)
||||lemma1([1,1,1,1])
||||x:pnat
||||==>y:pnat=>even(y)=even(y)in u(1)
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma1:..done
||||evenplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
||||==>x:pnat=>even(plus(\x/,``s(s({y}))''<out>))=even(plus(y,\x/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||evenplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
||||==>x:pnat=>even(plus(\x/,``s({``s({y})''<out>})''<out>))=even(plus(y,\x/))in u(1)
||||SELECTED METHOD at depth 4: wave([1,1],[lemma1,equ(left)])
|||||evenplus2([1,1,1,1,3])
|||||y:pnat
|||||v0:ih(x:pnat=>even(plus(x,y))=even(plus(y,x))in u(1))
|||||==>x:pnat=>even(plus(\x/,y))=even(plus(y,\x/))in u(1)
|||||TERMINATING METHOD at depth 5: fertilize(strong(v0))
|evenplus2([2])
|y:pnat
|==>x:pnat=>even(plus(x,s(0)))=even(plus(s(0),x))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus2)
||evenplus2([1,2])
||y:pnat
||==>x:pnat=>even(plus(x,s(0)))=even(s(plus(0,x)))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,2,1],plus1)
|||evenplus2([1,1,2])
|||y:pnat
|||==>x:pnat=>even(plus(x,s(0)))=even(s(x))in u(1)
|||SELECTED METHOD at depth 3: induction([s(x)],[x:pnat])
||||evenplus2([2,1,1,2])
||||x:pnat
||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||y:pnat
||||==>even(plus(``s({x})''<out>,s(0)))=even(s(``s({x})''<out>))in u(1)
||||SELECTED METHOD at depth 4: wave([1,2,1],[ssid,equ(left)])
|||||evenplus2([1,2,1,1,2])
|||||x:pnat
|||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
|||||y:pnat
|||||==>even(plus(``s({x})''<out>,s(0)))=even(``s({s(x)})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1],[plus2,equ(left)])
||||||evenplus2([1,1,2,1,1,2])
||||||x:pnat
||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||||y:pnat
||||||==>even(``s({plus(x,s(0))})''<out>)=even(``s({s(x)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

|||SELECTED METHOD at depth 3: induction([s(s(x))],[x:pnat])
||||evenplus2([3,1,1,2])
||||x:pnat
||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||y:pnat
||||==>even(plus(``s(s({x}))''<out>,s(0)))=even(s(``s(s({x}))''<out>))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||evenplus2([3,1,1,2])
||||x:pnat
||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||y:pnat
||||==>even(plus(``s(s({x}))''<out>,s(0)))=even(s(``s({``s({x})''<out>})''<out>))in u(1)
||||SELECTED METHOD at depth 4: wave([1,2,1],[ssid,equ(left)])
|||||evenplus2([1,3,1,1,2])
|||||x:pnat
|||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
|||||y:pnat
|||||==>even(plus(``s(s({x}))''<out>,s(0)))=even(``s({s(``s({x})''<out>)})''<out>)in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[ssid,equ(left)])
||||||evenplus2([1,1,3,1,1,2])
||||||x:pnat
||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||||y:pnat
||||||==>even(plus(``s(s({x}))''<out>,s(0)))=even(``s({``s({s(x)})''<out>})''<out>)in u(1)
||||||SELECTED METHOD at depth 6: wave([2,1],[even3,equ(left)])
|||||||evenplus2([1,1,1,3,1,1,2])
|||||||x:pnat
|||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
|||||||y:pnat
|||||||==>even(plus(``s(s({x}))''<out>,s(0)))=even(s(x))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||||evenplus2([1,1,1,3,1,1,2])
|||||||x:pnat
|||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
|||||||y:pnat
|||||||==>even(plus(``s({``s({x})''<out>})''<out>,s(0)))=even(s(x))in u(1)
|||||||SELECTED METHOD at depth 7: wave([1,1,1],[plus2,equ(left)])
||||||||evenplus2([1,1,1,1,3,1,1,2])
||||||||x:pnat
||||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||||||y:pnat
||||||||==>even(``s({plus(``s({x})''<out>,s(0))})''<out>)=even(s(x))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,1,1],[plus2,equ(left)])
|||||||||evenplus2([1,1,1,1,1,3,1,1,2])
|||||||||x:pnat
|||||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
|||||||||y:pnat
|||||||||==>even(``s({``s({plus(x,s(0))})''<out>})''<out>)=even(s(x))in u(1)
|||||||||SELECTED METHOD at depth 9: wave([1,1],[even3,equ(left)])
||||||||||evenplus2([1,1,1,1,1,1,3,1,1,2])
||||||||||x:pnat
||||||||||v0:ih(even(plus(x,s(0)))=even(s(x))in u(1))
||||||||||y:pnat
||||||||||==>even(plus(x,s(0)))=even(s(x))in u(1)
||||||||||TERMINATING METHOD at depth 10: fertilize(strong(v0))
||||evenplus2([2,1,1,2])
||||x:pnat
||||y:pnat
||||==>even(plus(s(0),s(0)))=even(s(s(0)))in u(1)
||||SELECTED METHOD at depth 4: eval_def([2,1],even3)
|||||evenplus2([1,2,1,1,2])
|||||x:pnat
|||||y:pnat
|||||==>even(plus(s(0),s(0)))=even(0)in u(1)
|||||SELECTED METHOD at depth 5: eval_def([2,1],even1)
||||||evenplus2([1,1,2,1,1,2])
||||||x:pnat
||||||y:pnat
||||||==>even(plus(s(0),s(0)))={true}in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],plus2)
|||||||evenplus2([1,1,1,2,1,1,2])
|||||||x:pnat
|||||||y:pnat
|||||||==>even(s(plus(0,s(0))))={true}in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1,1],plus1)
||||||||evenplus2([1,1,1,1,2,1,1,2])
||||||||x:pnat
||||||||y:pnat
||||||||==>even(s(s(0)))={true}in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],even3)
|||||||||evenplus2([1,1,1,1,1,2,1,1,2])
|||||||||x:pnat
|||||||||y:pnat
|||||||||==>even(0)={true}in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1],even1)
||||||||||evenplus2([1,1,1,1,1,1,2,1,1,2])
||||||||||x:pnat
||||||||||y:pnat
||||||||||==>{true}={true}in u(1)
||||||||||TERMINATING METHOD at depth 10: elementary(...)
||||evenplus2([1,1,1,2])
||||x:pnat
||||y:pnat
||||==>even(plus(0,s(0)))=even(s(0))in u(1)
||||SELECTED METHOD at depth 4: eval_def([2,1],even2)
|||||evenplus2([1,1,1,1,2])
|||||x:pnat
|||||y:pnat
|||||==>even(plus(0,s(0)))=void in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],plus1)
||||||evenplus2([1,1,1,1,1,2])
||||||x:pnat
||||||y:pnat
||||||==>even(s(0))=void in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1],even2)
|||||||evenplus2([1,1,1,1,1,1,2])
|||||||x:pnat
|||||||y:pnat
|||||||==>void=void in u(1)
|||||||TERMINATING METHOD at depth 7: elementary(...)
|evenplus2([1])
|y:pnat
|==>x:pnat=>even(plus(x,0))=even(plus(0,x))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus1)
||evenplus2([1,1])
||y:pnat
||==>x:pnat=>even(plus(x,0))=even(x)in u(1)
||SELECTED METHOD at depth 2: induction([s(s(x))],[x:pnat])
|||evenplus2([3,1,1])
|||x:pnat
|||v0:ih(even(plus(x,0))=even(x)in u(1))
|||y:pnat
|||==>even(plus(``s(s({x}))''<out>,0))=even(``s(s({x}))''<out>)in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||evenplus2([3,1,1])
|||x:pnat
|||v0:ih(even(plus(x,0))=even(x)in u(1))
|||y:pnat
|||==>even(plus(``s(s({x}))''<out>,0))=even(``s({``s({x})''<out>})''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([2,1],[even3,equ(left)])
||||evenplus2([1,3,1,1])
||||x:pnat
||||v0:ih(even(plus(x,0))=even(x)in u(1))
||||y:pnat
||||==>even(plus(``s(s({x}))''<out>,0))=even(x)in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||evenplus2([1,3,1,1])
||||x:pnat
||||v0:ih(even(plus(x,0))=even(x)in u(1))
||||y:pnat
||||==>even(plus(``s({``s({x})''<out>})''<out>,0))=even(x)in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,1],[plus2,equ(left)])
|||||evenplus2([1,1,3,1,1])
|||||x:pnat
|||||v0:ih(even(plus(x,0))=even(x)in u(1))
|||||y:pnat
|||||==>even(``s({plus(``s({x})''<out>,0)})''<out>)=even(x)in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[plus2,equ(left)])
||||||evenplus2([1,1,1,3,1,1])
||||||x:pnat
||||||v0:ih(even(plus(x,0))=even(x)in u(1))
||||||y:pnat
||||||==>even(``s({``s({plus(x,0)})''<out>})''<out>)=even(x)in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[even3,equ(left)])
|||||||evenplus2([1,1,1,1,3,1,1])
|||||||x:pnat
|||||||v0:ih(even(plus(x,0))=even(x)in u(1))
|||||||y:pnat
|||||||==>even(plus(x,0))=even(x)in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v0))
|||evenplus2([2,1,1])
|||x:pnat
|||y:pnat
|||==>even(plus(s(0),0))=even(s(0))in u(1)
|||SELECTED METHOD at depth 3: eval_def([2,1],even2)
||||evenplus2([1,2,1,1])
||||x:pnat
||||y:pnat
||||==>even(plus(s(0),0))=void in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1],plus2)
|||||evenplus2([1,1,2,1,1])
|||||x:pnat
|||||y:pnat
|||||==>even(s(plus(0,0)))=void in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,1,1],plus1)
||||||evenplus2([1,1,1,2,1,1])
||||||x:pnat
||||||y:pnat
||||||==>even(s(0))=void in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1],even2)
|||||||evenplus2([1,1,1,1,2,1,1])
|||||||x:pnat
|||||||y:pnat
|||||||==>void=void in u(1)
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||evenplus2([1,1,1])
|||x:pnat
|||y:pnat
|||==>even(plus(0,0))=even(0)in u(1)
|||SELECTED METHOD at depth 3: eval_def([2,1],even1)
||||evenplus2([1,1,1,1])
||||x:pnat
||||y:pnat
||||==>even(plus(0,0))={true}in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1],plus1)
|||||evenplus2([1,1,1,1,1])
|||||x:pnat
|||||y:pnat
|||||==>even(0)={true}in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even1)
||||||evenplus2([1,1,1,1,1,1])
||||||x:pnat
||||||y:pnat
||||||==>{true}={true}in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for evenplus2

------------------------------------------------------------
evenplus2:

[x:pnat,y:pnat]

|- even(plus(x,y))=even(plus(y,x))in u(1)

induction([s(s(y))],[y:pnat]) then 
  [eval_def([1,2,1],plus1) then 
     induction([s(s(x))],[x:pnat]) then 
       [eval_def([2,1],even1) then 
          eval_def([1,1,1],plus1) then 
            eval_def([1,1],even1) then 
              elementary(...),
        eval_def([2,1],even2) then 
          eval_def([1,1,1],plus2) then 
            eval_def([1,1,1,1],plus1) then 
              eval_def([1,1],even2) then 
                elementary(...),
        wave([2,1],[even3,equ(left)]) then 
          wave([1,1,1],[plus2,equ(left)]) then 
            wave([1,1,1,1],[plus2,equ(left)]) then 
              wave([1,1],[even3,equ(left)]) then 
                fertilize(strong(v0))
       ],
   eval_def([1,2,1],plus2) then 
     eval_def([1,1,2,1],plus1) then 
       induction([s(s(x))],[x:pnat]) then 
         [eval_def([2,1],even2) then 
            eval_def([1,1,1],plus1) then 
              eval_def([1,1],even2) then 
                elementary(...),
          eval_def([2,1],even3) then 
            eval_def([2,1],even1) then 
              eval_def([1,1,1],plus2) then 
                eval_def([1,1,1,1],plus1) then 
                  eval_def([1,1],even3) then 
                    eval_def([1,1],even1) then 
                      elementary(...),
          wave([1,2,1],[ssid,equ(left)]) then 
            wave([1,1,2,1],[ssid,equ(left)]) then 
              wave([2,1],[even3,equ(left)]) then 
                wave([1,1,1],[plus2,equ(left)]) then 
                  wave([1,1,1,1],[plus2,equ(left)]) then 
                    wave([1,1],[even3,equ(left)]) then 
                      fertilize(strong(v0))
         ],
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1,2,1],[plus2,equ(left)]) then 
       wave([2,1],[even3,equ(left)]) then 
         wave([1,1],[lemma1,equ(left)]) then 
           fertilize(strong(v0))
  ]

------------------------------------------------------------
lemma1:

[x:pnat,y:pnat]

|- even(plus(x,s(s(y))))=even(plus(x,y))in u(1)

induction([s(s(x))],[x:pnat]) then 
  [eval_def([1,2,1],plus1) then 
     eval_def([1,1,1],plus1) then 
       eval_def([1,1],even3) then 
         elementary(...),
   eval_def([1,2,1],plus2) then 
     eval_def([1,1,2,1],plus1) then 
       eval_def([1,1,1],plus2) then 
         eval_def([1,1,1,1],plus1) then 
           eval_def([1,1],even3) then 
             elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1,2,1],[plus2,equ(left)]) then 
       wave([2,1],[even3,equ(left)]) then 
         wave([1,1,1],[plus2,equ(left)]) then 
           wave([1,1,1,1],[plus2,equ(left)]) then 
             wave([1,1],[even3,equ(left)]) then 
               fertilize(strong(v0))
  ]


PLANNING for evenplus2 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave(ssid)...done
deleting theorem record for evenplus2...done
deleting thm(evenplus2)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading synth(even)...done
loading def(true)...done
loading synth(even)...done
loading def(even)...done
loading eqn(even1)...done
loading eqn(even2)...done
loading eqn(even3)...done
 adding wave-rules for even1:done
 adding wave-rules for even2:done
 adding wave-rules for even3:..done
 adding defeqn-record for even1...done 
 adding defeqn-record for even2...done 
 adding defeqn-record for even3...done 
loading thm(ssid)...done
 adding wave-rules for ssid:......done
loading thm(evenlenapp3)...done
evenlenapp3([])
==>a:pnat list=>b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1)
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|evenlenapp3([2])
|v0:pnat
|a:pnat list
|v1:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|==>b:pnat list=>even(length(app(``v0::{a}''<out>,\b/)))=even(plus(length(\b/),length(``v0::{a}''<out>)))in u(1)
|SELECTED METHOD at depth 1: wave([2,1,2,1],[length2,equ(left)])
||evenlenapp3([1,2])
||v0:pnat
||a:pnat list
||v1:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||==>b:pnat list=>even(length(app(``v0::{a}''<out>,\b/)))=even(plus(length(\b/),``s({length(a)})''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([1,1,1,1],[app2,equ(left)])
|||evenlenapp3([1,1,2])
|||v0:pnat
|||a:pnat list
|||v1:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||==>b:pnat list=>even(length(``v0::{app(a,\b/)}''<out>))=even(plus(length(\b/),``s({length(a)})''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])
||||evenlenapp3([1,1,1,2])
||||v0:pnat
||||a:pnat list
||||v1:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||||==>b:pnat list=>even(``s({length(app(a,\b/))})''<out>)=even(plus(length(\b/),``s({length(a)})''<out>))in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([v0::v1::a],[a:pnat list])
|evenlenapp3([3])
|v0:pnat
|v1:pnat
|a:pnat list
|v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|==>b:pnat list=>even(length(app(``v0::v1::{a}''<out>,\b/)))=even(plus(length(\b/),length(``v0::v1::{a}''<out>)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|evenlenapp3([3])
|v0:pnat
|v1:pnat
|a:pnat list
|v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|==>b:pnat list=>even(length(app(``v0::v1::{a}''<out>,\b/)))=even(plus(length(\b/),length(``v0::{``v1::{a}''<out>}''<out>)))in u(1)
|SELECTED METHOD at depth 1: wave([2,1,2,1],[length2,equ(left)])
||evenlenapp3([1,3])
||v0:pnat
||v1:pnat
||a:pnat list
||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||==>b:pnat list=>even(length(app(``v0::v1::{a}''<out>,\b/)))=even(plus(length(\b/),``s({length(``v1::{a}''<out>)})''<out>))in u(1)
||SELECTED METHOD at depth 2: wave([1,2,1,2,1],[length2,equ(left)])
|||evenlenapp3([1,1,3])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||==>b:pnat list=>even(length(app(``v0::v1::{a}''<out>,\b/)))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||evenlenapp3([1,1,3])
|||v0:pnat
|||v1:pnat
|||a:pnat list
|||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||==>b:pnat list=>even(length(app(``v0::{``v1::{a}''<out>}''<out>,\b/)))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[app2,equ(left)])
||||evenlenapp3([1,1,1,3])
||||v0:pnat
||||v1:pnat
||||a:pnat list
||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||||==>b:pnat list=>even(length(``v0::{app(``v1::{a}''<out>,\b/)}''<out>))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
||||SELECTED METHOD at depth 4: wave([2,1,1,1,1],[app2,equ(left)])
|||||evenlenapp3([1,1,1,1,3])
|||||v0:pnat
|||||v1:pnat
|||||a:pnat list
|||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||||==>b:pnat list=>even(length(``v0::{``v1::{app(a,\b/)}''<out>}''<out>))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1],[length2,equ(left)])
||||||evenlenapp3([1,1,1,1,1,3])
||||||v0:pnat
||||||v1:pnat
||||||a:pnat list
||||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||||||==>b:pnat list=>even(``s({length(``v1::{app(a,\b/)}''<out>)})''<out>)=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1],[length2,equ(left)])
|||||||evenlenapp3([1,1,1,1,1,1,3])
|||||||v0:pnat
|||||||v1:pnat
|||||||a:pnat list
|||||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||||||==>b:pnat list=>even(``s({``s({length(app(a,\b/))})''<out>})''<out>)=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
|||||||SELECTED METHOD at depth 7: wave([1,1],[even3,equ(left)])
||||||||evenlenapp3([1,1,1,1,1,1,1,3])
||||||||v0:pnat
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||||||||==>b:pnat list=>even(length(app(a,\b/)))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat]

|- even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1)

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1)
SELECTED METHOD at depth 0: induction([s(v0)],[v0:pnat])
|lemma1([2])
|v0:pnat
|v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|==>v1:pnat=>even(plus(``s({v0})''<out>,s(s(\v1/))))=even(plus(``s({v0})''<out>,\v1/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||v0:pnat
||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
||==>v1:pnat=>even(plus(``s({v0})''<out>,s(s(\v1/))))=even(``s({plus(v0,\v1/)})''<out>)in u(1)
||SELECTED METHOD at depth 2: wave([1,1,1],[plus2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|||==>v1:pnat=>even(``s({plus(v0,s(s(\v1/)))})''<out>)=even(``s({plus(v0,\v1/)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([s(s(v0))],[v0:pnat])
|lemma1([3])
|v0:pnat
|v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|==>v1:pnat=>even(plus(``s(s({v0}))''<out>,s(s(\v1/))))=even(plus(``s(s({v0}))''<out>,\v1/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|lemma1([3])
|v0:pnat
|v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|==>v1:pnat=>even(plus(``s(s({v0}))''<out>,s(s(\v1/))))=even(plus(``s({``s({v0})''<out>})''<out>,\v1/))in u(1)
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||lemma1([1,3])
||v0:pnat
||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
||==>v1:pnat=>even(plus(``s(s({v0}))''<out>,s(s(\v1/))))=even(``s({plus(``s({v0})''<out>,\v1/)})''<out>)in u(1)
||SELECTED METHOD at depth 2: wave([1,1,2,1],[plus2,equ(left)])
|||lemma1([1,1,3])
|||v0:pnat
|||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|||==>v1:pnat=>even(plus(``s(s({v0}))''<out>,s(s(\v1/))))=even(``s({``s({plus(v0,\v1/)})''<out>})''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([2,1],[even3,equ(left)])
||||lemma1([1,1,1,3])
||||v0:pnat
||||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
||||==>v1:pnat=>even(plus(``s(s({v0}))''<out>,s(s(\v1/))))=even(plus(v0,\v1/))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||lemma1([1,1,1,3])
||||v0:pnat
||||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
||||==>v1:pnat=>even(plus(``s({``s({v0})''<out>})''<out>,s(s(\v1/))))=even(plus(v0,\v1/))in u(1)
||||SELECTED METHOD at depth 4: wave([1,1,1],[plus2,equ(left)])
|||||lemma1([1,1,1,1,3])
|||||v0:pnat
|||||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|||||==>v1:pnat=>even(``s({plus(``s({v0})''<out>,s(s(\v1/)))})''<out>)=even(plus(v0,\v1/))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[plus2,equ(left)])
||||||lemma1([1,1,1,1,1,3])
||||||v0:pnat
||||||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
||||||==>v1:pnat=>even(``s({``s({plus(v0,s(s(\v1/)))})''<out>})''<out>)=even(plus(v0,\v1/))in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[even3,equ(left)])
|||||||lemma1([1,1,1,1,1,1,3])
|||||||v0:pnat
|||||||v2:ih(v1:pnat=>even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1))
|||||||==>v1:pnat=>even(plus(v0,s(s(\v1/))))=even(plus(v0,\v1/))in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v2))
|lemma1([2])
|v0:pnat
|==>v1:pnat=>even(plus(s(0),s(s(v1))))=even(plus(s(0),v1))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus2)
||lemma1([1,2])
||v0:pnat
||==>v1:pnat=>even(plus(s(0),s(s(v1))))=even(s(plus(0,v1)))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,2,1],plus1)
|||lemma1([1,1,2])
|||v0:pnat
|||==>v1:pnat=>even(plus(s(0),s(s(v1))))=even(s(v1))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1],plus2)
||||lemma1([1,1,1,2])
||||v0:pnat
||||==>v1:pnat=>even(s(plus(0,s(s(v1)))))=even(s(v1))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1,1],plus1)
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||==>v1:pnat=>even(s(s(s(v1))))=even(s(v1))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even3)
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||==>v1:pnat=>even(s(v1))=even(s(v1))in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v0:pnat
|==>v1:pnat=>even(plus(0,s(s(v1))))=even(plus(0,v1))in u(1)
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus1)
||lemma1([1,1])
||v0:pnat
||==>v1:pnat=>even(plus(0,s(s(v1))))=even(v1)in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,1],plus1)
|||lemma1([1,1,1])
|||v0:pnat
|||==>v1:pnat=>even(s(s(v1)))=even(v1)in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1],even3)
||||lemma1([1,1,1,1])
||||v0:pnat
||||==>v1:pnat=>even(v1)=even(v1)in u(1)
||||TERMINATING METHOD at depth 4: elementary(...)
 adding wave-rules for lemma1:..done
||||||||evenlenapp3([1,1,1,1,1,1,1,3])
||||||||v0:pnat
||||||||v1:pnat
||||||||a:pnat list
||||||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
||||||||==>b:pnat list=>even(length(app(a,\b/)))=even(plus(length(\b/),``s({``s({length(a)})''<out>})''<out>))in u(1)
||||||||SELECTED METHOD at depth 8: wave([2,1],[lemma1,equ(left)])
|||||||||evenlenapp3([1,1,1,1,1,1,1,1,3])
|||||||||v0:pnat
|||||||||v1:pnat
|||||||||a:pnat list
|||||||||v2:ih(b:pnat list=>even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1))
|||||||||==>b:pnat list=>even(length(app(a,\b/)))=even(plus(length(\b/),length(a)))in u(1)
|||||||||TERMINATING METHOD at depth 9: fertilize(strong(v2))
|evenlenapp3([2])
|v0:pnat
|a:pnat list
|==>b:pnat list=>even(length(app(v0::nil,b)))=even(plus(length(b),length(v0::nil)))in u(1)
|SELECTED METHOD at depth 1: eval_def([2,1,2,1],length2)
||evenlenapp3([1,2])
||v0:pnat
||a:pnat list
||==>b:pnat list=>even(length(app(v0::nil,b)))=even(plus(length(b),s(length(nil))))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,2,1,2,1],length1)
|||evenlenapp3([1,1,2])
|||v0:pnat
|||a:pnat list
|||==>b:pnat list=>even(length(app(v0::nil,b)))=even(plus(length(b),s(0)))in u(1)
|||SELECTED METHOD at depth 3: eval_def([1,1,1,1],app2)
||||evenlenapp3([1,1,1,2])
||||v0:pnat
||||a:pnat list
||||==>b:pnat list=>even(length(v0::app(nil,b)))=even(plus(length(b),s(0)))in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1,1],length2)
|||||evenlenapp3([1,1,1,1,2])
|||||v0:pnat
|||||a:pnat list
|||||==>b:pnat list=>even(s(length(app(nil,b))))=even(plus(length(b),s(0)))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1,1,1,1],app1)
||||||evenlenapp3([1,1,1,1,1,2])
||||||v0:pnat
||||||a:pnat list
||||||==>b:pnat list=>even(s(length(b)))=even(plus(length(b),s(0)))in u(1)
||||||SELECTED METHOD at depth 6: generalise(length(b),v1:pnat)
|||||||evenlenapp3([1,1,1,1,1,1,2])
|||||||v0:pnat
|||||||a:pnat list
|||||||==>v1:pnat=>b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1)
|||||||SELECTED METHOD at depth 7: induction([s(v1)],[v1:pnat])
||||||||evenlenapp3([2,1,1,1,1,1,1,2])
||||||||v1:pnat
||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>even(s(``s({v1})''<out>))=even(plus(``s({v1})''<out>,s(0)))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1,1],[ssid,equ(left)])
|||||||||evenlenapp3([1,2,1,1,1,1,1,1,2])
|||||||||v1:pnat
|||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>even(``s({s(v1)})''<out>)=even(plus(``s({v1})''<out>,s(0)))in u(1)
|||||||||SELECTED METHOD at depth 9: wave([1,2,1],[plus2,equ(left)])
||||||||||evenlenapp3([1,1,2,1,1,1,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||==>b:pnat list=>even(``s({s(v1)})''<out>)=even(``s({plus(v1,s(0))})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

|||||||SELECTED METHOD at depth 7: induction([s(s(v1))],[v1:pnat])
||||||||evenlenapp3([3,1,1,1,1,1,1,2])
||||||||v1:pnat
||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>even(s(``s(s({v1}))''<out>))=even(plus(``s(s({v1}))''<out>,s(0)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||||evenlenapp3([3,1,1,1,1,1,1,2])
||||||||v1:pnat
||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>even(s(``s(s({v1}))''<out>))=even(plus(``s({``s({v1})''<out>})''<out>,s(0)))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,2,1],[plus2,equ(left)])
|||||||||evenlenapp3([1,3,1,1,1,1,1,1,2])
|||||||||v1:pnat
|||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>even(s(``s(s({v1}))''<out>))=even(``s({plus(``s({v1})''<out>,s(0))})''<out>)in u(1)
|||||||||SELECTED METHOD at depth 9: wave([1,1,2,1],[plus2,equ(left)])
||||||||||evenlenapp3([1,1,3,1,1,1,1,1,1,2])
||||||||||v1:pnat
||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||==>b:pnat list=>even(s(``s(s({v1}))''<out>))=even(``s({``s({plus(v1,s(0))})''<out>})''<out>)in u(1)
||||||||||SELECTED METHOD at depth 10: wave([2,1],[even3,equ(left)])
|||||||||||evenlenapp3([1,1,1,3,1,1,1,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||==>b:pnat list=>even(s(``s(s({v1}))''<out>))=even(plus(v1,s(0)))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||||||||evenlenapp3([1,1,1,3,1,1,1,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||==>b:pnat list=>even(s(``s({``s({v1})''<out>})''<out>))=even(plus(v1,s(0)))in u(1)
|||||||||||SELECTED METHOD at depth 11: wave([1,1,1],[ssid,equ(left)])
||||||||||||evenlenapp3([1,1,1,1,3,1,1,1,1,1,1,2])
||||||||||||v1:pnat
||||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||||||v0:pnat
||||||||||||a:pnat list
||||||||||||==>b:pnat list=>even(``s({s(``s({v1})''<out>)})''<out>)=even(plus(v1,s(0)))in u(1)
||||||||||||SELECTED METHOD at depth 12: wave([1,1,1,1],[ssid,equ(left)])
|||||||||||||evenlenapp3([1,1,1,1,1,3,1,1,1,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
|||||||||||||v0:pnat
|||||||||||||a:pnat list
|||||||||||||==>b:pnat list=>even(``s({``s({s(v1)})''<out>})''<out>)=even(plus(v1,s(0)))in u(1)
|||||||||||||SELECTED METHOD at depth 13: wave([1,1],[even3,equ(left)])
||||||||||||||evenlenapp3([1,1,1,1,1,1,3,1,1,1,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||v2:ih(b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1))
||||||||||||||v0:pnat
||||||||||||||a:pnat list
||||||||||||||==>b:pnat list=>even(s(v1))=even(plus(v1,s(0)))in u(1)
||||||||||||||TERMINATING METHOD at depth 14: fertilize(strong(v2))
||||||||evenlenapp3([2,1,1,1,1,1,1,2])
||||||||v1:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>even(s(s(0)))=even(plus(s(0),s(0)))in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],even3)
|||||||||evenlenapp3([1,2,1,1,1,1,1,1,2])
|||||||||v1:pnat
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>even(0)=even(plus(s(0),s(0)))in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,1],even1)
||||||||||evenlenapp3([1,1,2,1,1,1,1,1,1,2])
||||||||||v1:pnat
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||==>b:pnat list=>{true}=even(plus(s(0),s(0)))in u(1)
||||||||||SELECTED METHOD at depth 10: eval_def([1,2,1],plus2)
|||||||||||evenlenapp3([1,1,1,2,1,1,1,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||==>b:pnat list=>{true}=even(s(plus(0,s(0))))in u(1)
|||||||||||SELECTED METHOD at depth 11: eval_def([1,1,2,1],plus1)
||||||||||||evenlenapp3([1,1,1,1,2,1,1,1,1,1,1,2])
||||||||||||v1:pnat
||||||||||||v0:pnat
||||||||||||a:pnat list
||||||||||||==>b:pnat list=>{true}=even(s(s(0)))in u(1)
||||||||||||SELECTED METHOD at depth 12: eval_def([2,1],even3)
|||||||||||||evenlenapp3([1,1,1,1,1,2,1,1,1,1,1,1,2])
|||||||||||||v1:pnat
|||||||||||||v0:pnat
|||||||||||||a:pnat list
|||||||||||||==>b:pnat list=>{true}=even(0)in u(1)
|||||||||||||SELECTED METHOD at depth 13: eval_def([2,1],even1)
||||||||||||||evenlenapp3([1,1,1,1,1,1,2,1,1,1,1,1,1,2])
||||||||||||||v1:pnat
||||||||||||||v0:pnat
||||||||||||||a:pnat list
||||||||||||||==>b:pnat list=>{true}={true}in u(1)
||||||||||||||TERMINATING METHOD at depth 14: elementary(...)
||||||||evenlenapp3([1,1,1,1,1,1,1,2])
||||||||v1:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>even(s(0))=even(plus(0,s(0)))in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],even2)
|||||||||evenlenapp3([1,1,1,1,1,1,1,1,2])
|||||||||v1:pnat
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>void=even(plus(0,s(0)))in u(1)
|||||||||SELECTED METHOD at depth 9: eval_def([1,2,1],plus1)
||||||||||evenlenapp3([1,1,1,1,1,1,1,1,1,2])
||||||||||v1:pnat
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||==>b:pnat list=>void=even(s(0))in u(1)
||||||||||SELECTED METHOD at depth 10: eval_def([2,1],even2)
|||||||||||evenlenapp3([1,1,1,1,1,1,1,1,1,1,2])
|||||||||||v1:pnat
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||==>b:pnat list=>void=void in u(1)
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
|evenlenapp3([1])
|a:pnat list
|==>b:pnat list=>even(length(app(nil,b)))=even(plus(length(b),length(nil)))in u(1)
|SELECTED METHOD at depth 1: eval_def([2,1,2,1],length1)
||evenlenapp3([1,1])
||a:pnat list
||==>b:pnat list=>even(length(app(nil,b)))=even(plus(length(b),0))in u(1)
||SELECTED METHOD at depth 2: eval_def([1,1,1,1],app1)
|||evenlenapp3([1,1,1])
|||a:pnat list
|||==>b:pnat list=>even(length(b))=even(plus(length(b),0))in u(1)
|||SELECTED METHOD at depth 3: generalise(length(b),v0:pnat)
||||evenlenapp3([1,1,1,1])
||||a:pnat list
||||==>v0:pnat=>b:pnat list=>even(v0)=even(plus(v0,0))in u(1)
||||SELECTED METHOD at depth 4: induction([s(v0)],[v0:pnat])
|||||evenlenapp3([2,1,1,1,1])
|||||v0:pnat
|||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
|||||a:pnat list
|||||==>b:pnat list=>even(``s({v0})''<out>)=even(plus(``s({v0})''<out>,0))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[plus2,equ(left)])
||||||evenlenapp3([1,2,1,1,1,1])
||||||v0:pnat
||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
||||||a:pnat list
||||||==>b:pnat list=>even(``s({v0})''<out>)=even(``s({plus(v0,0)})''<out>)in u(1)

>>>>> INVOKING induction-revision CRITIC <<<<<

||||SELECTED METHOD at depth 4: induction([s(s(v0))],[v0:pnat])
|||||evenlenapp3([3,1,1,1,1])
|||||v0:pnat
|||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
|||||a:pnat list
|||||==>b:pnat list=>even(``s(s({v0}))''<out>)=even(plus(``s(s({v0}))''<out>,0))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||evenlenapp3([3,1,1,1,1])
|||||v0:pnat
|||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
|||||a:pnat list
|||||==>b:pnat list=>even(``s(s({v0}))''<out>)=even(plus(``s({``s({v0})''<out>})''<out>,0))in u(1)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[plus2,equ(left)])
||||||evenlenapp3([1,3,1,1,1,1])
||||||v0:pnat
||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
||||||a:pnat list
||||||==>b:pnat list=>even(``s(s({v0}))''<out>)=even(``s({plus(``s({v0})''<out>,0)})''<out>)in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1,2,1],[plus2,equ(left)])
|||||||evenlenapp3([1,1,3,1,1,1,1])
|||||||v0:pnat
|||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
|||||||a:pnat list
|||||||==>b:pnat list=>even(``s(s({v0}))''<out>)=even(``s({``s({plus(v0,0)})''<out>})''<out>)in u(1)
|||||||SELECTED METHOD at depth 7: wave([2,1],[even3,equ(left)])
||||||||evenlenapp3([1,1,1,3,1,1,1,1])
||||||||v0:pnat
||||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
||||||||a:pnat list
||||||||==>b:pnat list=>even(``s(s({v0}))''<out>)=even(plus(v0,0))in u(1)

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||||||evenlenapp3([1,1,1,3,1,1,1,1])
||||||||v0:pnat
||||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
||||||||a:pnat list
||||||||==>b:pnat list=>even(``s({``s({v0})''<out>})''<out>)=even(plus(v0,0))in u(1)
||||||||SELECTED METHOD at depth 8: wave([1,1],[even3,equ(left)])
|||||||||evenlenapp3([1,1,1,1,3,1,1,1,1])
|||||||||v0:pnat
|||||||||v1:ih(b:pnat list=>even(v0)=even(plus(v0,0))in u(1))
|||||||||a:pnat list
|||||||||==>b:pnat list=>even(v0)=even(plus(v0,0))in u(1)
|||||||||TERMINATING METHOD at depth 9: fertilize(strong(v1))
|||||evenlenapp3([2,1,1,1,1])
|||||v0:pnat
|||||a:pnat list
|||||==>b:pnat list=>even(s(0))=even(plus(s(0),0))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even2)
||||||evenlenapp3([1,2,1,1,1,1])
||||||v0:pnat
||||||a:pnat list
||||||==>b:pnat list=>void=even(plus(s(0),0))in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,2,1],plus2)
|||||||evenlenapp3([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||a:pnat list
|||||||==>b:pnat list=>void=even(s(plus(0,0)))in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1,2,1],plus1)
||||||||evenlenapp3([1,1,1,2,1,1,1,1])
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>void=even(s(0))in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([2,1],even2)
|||||||||evenlenapp3([1,1,1,1,2,1,1,1,1])
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||==>b:pnat list=>void=void in u(1)
|||||||||TERMINATING METHOD at depth 9: elementary(...)
|||||evenlenapp3([1,1,1,1,1])
|||||v0:pnat
|||||a:pnat list
|||||==>b:pnat list=>even(0)=even(plus(0,0))in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],even1)
||||||evenlenapp3([1,1,1,1,1,1])
||||||v0:pnat
||||||a:pnat list
||||||==>b:pnat list=>{true}=even(plus(0,0))in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,2,1],plus1)
|||||||evenlenapp3([1,1,1,1,1,1,1])
|||||||v0:pnat
|||||||a:pnat list
|||||||==>b:pnat list=>{true}=even(0)in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([2,1],even1)
||||||||evenlenapp3([1,1,1,1,1,1,1,1])
||||||||v0:pnat
||||||||a:pnat list
||||||||==>b:pnat list=>{true}={true}in u(1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
Planning complete for evenlenapp3

------------------------------------------------------------
evenlenapp3:

[a:pnat list,b:pnat list]

|- even(length(app(a,b)))=even(plus(length(b),length(a)))in u(1)

induction([v0::v1::a],[a:pnat list]) then 
  [eval_def([2,1,2,1],length1) then 
     eval_def([1,1,1,1],app1) then 
       generalise(length(b),v0:pnat) then 
         induction([s(s(v0))],[v0:pnat]) then 
           [eval_def([1,1],even1) then 
              eval_def([1,2,1],plus1) then 
                eval_def([2,1],even1) then 
                  elementary(...),
            eval_def([1,1],even2) then 
              eval_def([1,2,1],plus2) then 
                eval_def([1,1,2,1],plus1) then 
                  eval_def([2,1],even2) then 
                    elementary(...),
            wave([1,2,1],[plus2,equ(left)]) then 
              wave([1,1,2,1],[plus2,equ(left)]) then 
                wave([2,1],[even3,equ(left)]) then 
                  wave([1,1],[even3,equ(left)]) then 
                    fertilize(strong(v1))
           ],
   eval_def([2,1,2,1],length2) then 
     eval_def([1,2,1,2,1],length1) then 
       eval_def([1,1,1,1],app2) then 
         eval_def([1,1,1],length2) then 
           eval_def([1,1,1,1,1],app1) then 
             generalise(length(b),v1:pnat) then 
               induction([s(s(v1))],[v1:pnat]) then 
                 [eval_def([1,1],even2) then 
                    eval_def([1,2,1],plus1) then 
                      eval_def([2,1],even2) then 
                        elementary(...),
                  eval_def([1,1],even3) then 
                    eval_def([1,1],even1) then 
                      eval_def([1,2,1],plus2) then 
                        eval_def([1,1,2,1],plus1) then 
                          eval_def([2,1],even3) then 
                            eval_def([2,1],even1) then 
                              elementary(...),
                  wave([1,2,1],[plus2,equ(left)]) then 
                    wave([1,1,2,1],[plus2,equ(left)]) then 
                      wave([2,1],[even3,equ(left)]) then 
                        wave([1,1,1],[ssid,equ(left)]) then 
                          wave([1,1,1,1],[ssid,equ(left)]) then 
                            wave([1,1],[even3,equ(left)]) then 
                              fertilize(strong(v2))
                 ],
   wave([2,1,2,1],[length2,equ(left)]) then 
     wave([1,2,1,2,1],[length2,equ(left)]) then 
       wave([1,1,1,1],[app2,equ(left)]) then 
         wave([2,1,1,1,1],[app2,equ(left)]) then 
           wave([1,1,1],[length2,equ(left)]) then 
             wave([1,1,1,1],[length2,equ(left)]) then 
               wave([1,1],[even3,equ(left)]) then 
                 wave([2,1],[lemma1,equ(left)]) then 
                   fertilize(strong(v2))
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat]

|- even(plus(v0,s(s(v1))))=even(plus(v0,v1))in u(1)

induction([s(s(v0))],[v0:pnat]) then 
  [eval_def([1,2,1],plus1) then 
     eval_def([1,1,1],plus1) then 
       eval_def([1,1],even3) then 
         elementary(...),
   eval_def([1,2,1],plus2) then 
     eval_def([1,1,2,1],plus1) then 
       eval_def([1,1,1],plus2) then 
         eval_def([1,1,1,1],plus1) then 
           eval_def([1,1],even3) then 
             elementary(...),
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1,2,1],[plus2,equ(left)]) then 
       wave([2,1],[even3,equ(left)]) then 
         wave([1,1,1],[plus2,equ(left)]) then 
           wave([1,1,1,1],[plus2,equ(left)]) then 
             wave([1,1],[even3,equ(left)]) then 
               fertilize(strong(v2))
  ]


PLANNING for evenlenapp3 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for even...done
deleting synth(even)...done
deleting def(even)...done
deleting theorem record for even3...done
deleting wave record for even3...done
deleting wave record for even3...done
deleting func_defeqn record for even3...done
deleting wave(even3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave(ssid)...done
deleting theorem record for evenlenapp3...done
deleting thm(evenlenapp3)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading synth(half)...done
loading synth(half)...done
loading def(half)...done
loading eqn(half1)...done
loading eqn(half2)...done
loading eqn(half3)...done
 adding wave-rules for half1:..done
 adding wave-rules for half2:..done
 adding wave-rules for half3:..............done
 adding defeqn-record for half1...done 
 adding defeqn-record for half2...done 
 adding defeqn-record for half3...done 
loading thm(cnc_s)...done
 adding wave-rules for cnc_s:done
 adding cancel-record for cnc_s...done
loading thm(cnc_half)...done
 adding wave-rules for cnc_half:done
 adding cancel-record for cnc_half...done
loading thm(ssid)...done
 adding wave-rules for ssid:......done
loading thm(halfplus2)...done
halfplus2([])
==>x:pnat=>y:pnat=>half(plus(x,y))=half(plus(y,x))in pnat
SELECTED METHOD at depth 0: induction([s(y)],[y:pnat])
|halfplus2([2])
|y:pnat
|v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|==>x:pnat=>half(plus(\x/,``s({y})''<out>))=half(plus(``s({y})''<out>,\x/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||halfplus2([1,2])
||y:pnat
||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||==>x:pnat=>half(plus(\x/,``s({y})''<out>))=half(``s({plus(y,\x/)})''<out>)in pnat

>>>>> INVOKING induction-revision CRITIC <<<<<

SELECTED METHOD at depth 0: induction([s(s(y))],[y:pnat])
|halfplus2([3])
|y:pnat
|v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=half(plus(``s(s({y}))''<out>,\x/))in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|halfplus2([3])
|y:pnat
|v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=half(plus(``s({``s({y})''<out>})''<out>,\x/))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[plus2,equ(left)])
||halfplus2([1,3])
||y:pnat
||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=half(``s({plus(``s({y})''<out>,\x/)})''<out>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,2,1],[plus2,equ(left)])
|||halfplus2([1,1,3])
|||y:pnat
|||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|||==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=half(``s({``s({plus(y,\x/)})''<out>})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[half3,equ(left)])
||||halfplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||||==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=``s({half(plus(y,\x/))})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[x:pnat,y:pnat]

|- plus(x,s(s(y)))=s(s(plus(x,y)))in pnat

saving thm(lemma1)...done
lemma1([])
==>x:pnat=>y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
|==>y:pnat=>plus(``s({x})''<out>,s(s(\y/)))=s(s(plus(``s({x})''<out>,\y/)))in pnat
|SELECTED METHOD at depth 1: wave([1,1,2,1],[plus2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
||==>y:pnat=>plus(``s({x})''<out>,s(s(\y/)))=s(s(``s({plus(x,\y/)})''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[ssid,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
|||==>y:pnat=>plus(``s({x})''<out>,s(s(\y/)))=s(``s({s(plus(x,\y/))})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[ssid,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
||||==>y:pnat=>plus(``s({x})''<out>,s(s(\y/)))=``s({s(s(plus(x,\y/)))})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[plus2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
|||||==>y:pnat=>``s({plus(x,s(s(\y/)))})''<out> =``s({s(s(plus(x,\y/)))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v0))
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(y:pnat=>plus(x,s(s(y)))=s(s(plus(x,y)))in pnat)
||||||==>s(plus(x,s(s(y))))=s(plus(x,s(s(y))))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|x:pnat
|==>y:pnat=>plus(0,s(s(y)))=s(s(plus(0,y)))in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],plus1)
||lemma1([1,1])
||x:pnat
||==>y:pnat=>s(s(y))=s(s(plus(0,y)))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,2,1],plus1)
|||lemma1([1,1,1])
|||x:pnat
|||==>y:pnat=>s(s(y))=s(s(y))in pnat
|||TERMINATING METHOD at depth 3: elementary(...)
 adding wave-rules for lemma1:................................done
||||halfplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||||==>x:pnat=>half(plus(\x/,``s(s({y}))''<out>))=``s({half(plus(y,\x/))})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||halfplus2([1,1,1,3])
||||y:pnat
||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||||==>x:pnat=>half(plus(\x/,``s({``s({y})''<out>})''<out>))=``s({half(plus(y,\x/))})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[lemma1,equ(left)])
|||||halfplus2([1,1,1,1,3])
|||||y:pnat
|||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|||||==>x:pnat=>half(``s({``s({plus(\x/,y)})''<out>})''<out>)=``s({half(plus(y,\x/))})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[half3,equ(left)])
||||||halfplus2([1,1,1,1,1,3])
||||||y:pnat
||||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
||||||==>x:pnat=>``s({half(plus(\x/,y))})''<out> =``s({half(plus(y,\x/))})''<out>in pnat
||||||SELECTED METHOD at depth 6: fertilize(weak(v0))
|||||||halfplus2([1,1,1,1,1,1,3])
|||||||y:pnat
|||||||v0:ih(x:pnat=>half(plus(x,y))=half(plus(y,x))in pnat)
|||||||==>s(half(plus(x,y)))=s(half(plus(x,y)))in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|halfplus2([2])
|y:pnat
|==>x:pnat=>half(plus(x,s(0)))=half(plus(s(0),x))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus2)
||halfplus2([1,2])
||y:pnat
||==>x:pnat=>half(plus(x,s(0)))=half(s(plus(0,x)))in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,2,1],plus1)
|||halfplus2([1,1,2])
|||y:pnat
|||==>x:pnat=>half(plus(x,s(0)))=half(s(x))in pnat
|||SELECTED METHOD at depth 3: induction([s(x)],[x:pnat])
||||halfplus2([2,1,1,2])
||||x:pnat
||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||y:pnat
||||==>half(plus(``s({x})''<out>,s(0)))=half(s(``s({x})''<out>))in pnat
||||SELECTED METHOD at depth 4: wave([1,2,1],[ssid,equ(left)])
|||||halfplus2([1,2,1,1,2])
|||||x:pnat
|||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||y:pnat
|||||==>half(plus(``s({x})''<out>,s(0)))=half(``s({s(x)})''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1],[plus2,equ(left)])
||||||halfplus2([1,1,2,1,1,2])
||||||x:pnat
||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||||y:pnat
||||||==>half(``s({plus(x,s(0))})''<out>)=half(``s({s(x)})''<out>)in pnat

>>>>> INVOKING induction-revision CRITIC <<<<<

|||SELECTED METHOD at depth 3: induction([s(s(x))],[x:pnat])
||||halfplus2([3,1,1,2])
||||x:pnat
||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||y:pnat
||||==>half(plus(``s(s({x}))''<out>,s(0)))=half(s(``s(s({x}))''<out>))in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||halfplus2([3,1,1,2])
||||x:pnat
||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||y:pnat
||||==>half(plus(``s(s({x}))''<out>,s(0)))=half(s(``s({``s({x})''<out>})''<out>))in pnat
||||SELECTED METHOD at depth 4: wave([1,2,1],[ssid,equ(left)])
|||||halfplus2([1,3,1,1,2])
|||||x:pnat
|||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||y:pnat
|||||==>half(plus(``s(s({x}))''<out>,s(0)))=half(``s({s(``s({x})''<out>)})''<out>)in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,2,1],[ssid,equ(left)])
||||||halfplus2([1,1,3,1,1,2])
||||||x:pnat
||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||||y:pnat
||||||==>half(plus(``s(s({x}))''<out>,s(0)))=half(``s({``s({s(x)})''<out>})''<out>)in pnat
||||||SELECTED METHOD at depth 6: wave([2,1],[half3,equ(left)])
|||||||halfplus2([1,1,1,3,1,1,2])
|||||||x:pnat
|||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||||y:pnat
|||||||==>half(plus(``s(s({x}))''<out>,s(0)))=``s({half(s(x))})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||||||halfplus2([1,1,1,3,1,1,2])
|||||||x:pnat
|||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||||y:pnat
|||||||==>half(plus(``s({``s({x})''<out>})''<out>,s(0)))=``s({half(s(x))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: wave([1,1,1],[plus2,equ(left)])
||||||||halfplus2([1,1,1,1,3,1,1,2])
||||||||x:pnat
||||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||||||y:pnat
||||||||==>half(``s({plus(``s({x})''<out>,s(0))})''<out>)=``s({half(s(x))})''<out>in pnat
||||||||SELECTED METHOD at depth 8: wave([1,1,1,1],[plus2,equ(left)])
|||||||||halfplus2([1,1,1,1,1,3,1,1,2])
|||||||||x:pnat
|||||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||||||y:pnat
|||||||||==>half(``s({``s({plus(x,s(0))})''<out>})''<out>)=``s({half(s(x))})''<out>in pnat
|||||||||SELECTED METHOD at depth 9: wave([1,1],[half3,equ(left)])
||||||||||halfplus2([1,1,1,1,1,1,3,1,1,2])
||||||||||x:pnat
||||||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
||||||||||y:pnat
||||||||||==>``s({half(plus(x,s(0)))})''<out> =``s({half(s(x))})''<out>in pnat
||||||||||SELECTED METHOD at depth 10: fertilize(weak(v0))
|||||||||||halfplus2([1,1,1,1,1,1,1,3,1,1,2])
|||||||||||x:pnat
|||||||||||v0:ih(half(plus(x,s(0)))=half(s(x))in pnat)
|||||||||||y:pnat
|||||||||||==>s(half(plus(x,s(0))))=s(half(plus(x,s(0))))in pnat
|||||||||||TERMINATING METHOD at depth 11: elementary(...)
||||halfplus2([2,1,1,2])
||||x:pnat
||||y:pnat
||||==>half(plus(s(0),s(0)))=half(s(s(0)))in pnat
||||SELECTED METHOD at depth 4: eval_def([2,1],half3)
|||||halfplus2([1,2,1,1,2])
|||||x:pnat
|||||y:pnat
|||||==>half(plus(s(0),s(0)))=s(half(0))in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,2,1],half1)
||||||halfplus2([1,1,2,1,1,2])
||||||x:pnat
||||||y:pnat
||||||==>half(plus(s(0),s(0)))=s(0)in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],plus2)
|||||||halfplus2([1,1,1,2,1,1,2])
|||||||x:pnat
|||||||y:pnat
|||||||==>half(s(plus(0,s(0))))=s(0)in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1,1],plus1)
||||||||halfplus2([1,1,1,1,2,1,1,2])
||||||||x:pnat
||||||||y:pnat
||||||||==>half(s(s(0)))=s(0)in pnat
||||||||SELECTED METHOD at depth 8: eval_def([1,1],half3)
|||||||||halfplus2([1,1,1,1,1,2,1,1,2])
|||||||||x:pnat
|||||||||y:pnat
|||||||||==>s(half(0))=s(0)in pnat
|||||||||SELECTED METHOD at depth 9: eval_def([1,1,1],half1)
||||||||||halfplus2([1,1,1,1,1,1,2,1,1,2])
||||||||||x:pnat
||||||||||y:pnat
||||||||||==>s(0)=s(0)in pnat
||||||||||TERMINATING METHOD at depth 10: elementary(...)
||||halfplus2([1,1,1,2])
||||x:pnat
||||y:pnat
||||==>half(plus(0,s(0)))=half(s(0))in pnat
||||SELECTED METHOD at depth 4: eval_def([2,1],half2)
|||||halfplus2([1,1,1,1,2])
|||||x:pnat
|||||y:pnat
|||||==>half(plus(0,s(0)))=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],plus1)
||||||halfplus2([1,1,1,1,1,2])
||||||x:pnat
||||||y:pnat
||||||==>half(s(0))=0 in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1],half2)
|||||||halfplus2([1,1,1,1,1,1,2])
|||||||x:pnat
|||||||y:pnat
|||||||==>0=0 in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|halfplus2([1])
|y:pnat
|==>x:pnat=>half(plus(x,0))=half(plus(0,x))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],plus1)
||halfplus2([1,1])
||y:pnat
||==>x:pnat=>half(plus(x,0))=half(x)in pnat
||SELECTED METHOD at depth 2: induction([s(s(x))],[x:pnat])
|||halfplus2([3,1,1])
|||x:pnat
|||v0:ih(half(plus(x,0))=half(x)in pnat)
|||y:pnat
|||==>half(plus(``s(s({x}))''<out>,0))=half(``s(s({x}))''<out>)in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

|||halfplus2([3,1,1])
|||x:pnat
|||v0:ih(half(plus(x,0))=half(x)in pnat)
|||y:pnat
|||==>half(plus(``s(s({x}))''<out>,0))=half(``s({``s({x})''<out>})''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[half3,equ(left)])
||||halfplus2([1,3,1,1])
||||x:pnat
||||v0:ih(half(plus(x,0))=half(x)in pnat)
||||y:pnat
||||==>half(plus(``s(s({x}))''<out>,0))=``s({half(x)})''<out>in pnat

>>>>> INVOKING split-wave-fronts CRITIC <<<<<

||||halfplus2([1,3,1,1])
||||x:pnat
||||v0:ih(half(plus(x,0))=half(x)in pnat)
||||y:pnat
||||==>half(plus(``s({``s({x})''<out>})''<out>,0))=``s({half(x)})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[plus2,equ(left)])
|||||halfplus2([1,1,3,1,1])
|||||x:pnat
|||||v0:ih(half(plus(x,0))=half(x)in pnat)
|||||y:pnat
|||||==>half(``s({plus(``s({x})''<out>,0)})''<out>)=``s({half(x)})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[plus2,equ(left)])
||||||halfplus2([1,1,1,3,1,1])
||||||x:pnat
||||||v0:ih(half(plus(x,0))=half(x)in pnat)
||||||y:pnat
||||||==>half(``s({``s({plus(x,0)})''<out>})''<out>)=``s({half(x)})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1],[half3,equ(left)])
|||||||halfplus2([1,1,1,1,3,1,1])
|||||||x:pnat
|||||||v0:ih(half(plus(x,0))=half(x)in pnat)
|||||||y:pnat
|||||||==>``s({half(plus(x,0))})''<out> =``s({half(x)})''<out>in pnat
|||||||SELECTED METHOD at depth 7: fertilize(weak(v0))
||||||||halfplus2([1,1,1,1,1,3,1,1])
||||||||x:pnat
||||||||v0:ih(half(plus(x,0))=half(x)in pnat)
||||||||y:pnat
||||||||==>s(half(plus(x,0)))=s(half(plus(x,0)))in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||halfplus2([2,1,1])
|||x:pnat
|||y:pnat
|||==>half(plus(s(0),0))=half(s(0))in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1],half2)
||||halfplus2([1,2,1,1])
||||x:pnat
||||y:pnat
||||==>half(plus(s(0),0))=0 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],plus2)
|||||halfplus2([1,1,2,1,1])
|||||x:pnat
|||||y:pnat
|||||==>half(s(plus(0,0)))=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,1,1],plus1)
||||||halfplus2([1,1,1,2,1,1])
||||||x:pnat
||||||y:pnat
||||||==>half(s(0))=0 in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1],half2)
|||||||halfplus2([1,1,1,1,2,1,1])
|||||||x:pnat
|||||||y:pnat
|||||||==>0=0 in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||halfplus2([1,1,1])
|||x:pnat
|||y:pnat
|||==>half(plus(0,0))=half(0)in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1],half1)
||||halfplus2([1,1,1,1])
||||x:pnat
||||y:pnat
||||==>half(plus(0,0))=0 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],plus1)
|||||halfplus2([1,1,1,1,1])
|||||x:pnat
|||||y:pnat
|||||==>half(0)=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],half1)
||||||halfplus2([1,1,1,1,1,1])
||||||x:pnat
||||||y:pnat
||||||==>0=0 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for halfplus2

------------------------------------------------------------
halfplus2:

[x:pnat,y:pnat]

|- half(plus(x,y))=half(plus(y,x))in pnat

induction([s(s(y))],[y:pnat]) then 
  [eval_def([1,2,1],plus1) then 
     induction([s(s(x))],[x:pnat]) then 
       [eval_def([2,1],half1) then 
          eval_def([1,1,1],plus1) then 
            eval_def([1,1],half1) then 
              elementary(...),
        eval_def([2,1],half2) then 
          eval_def([1,1,1],plus2) then 
            eval_def([1,1,1,1],plus1) then 
              eval_def([1,1],half2) then 
                elementary(...),
        wave([2,1],[half3,equ(left)]) then 
          wave([1,1,1],[plus2,equ(left)]) then 
            wave([1,1,1,1],[plus2,equ(left)]) then 
              wave([1,1],[half3,equ(left)]) then 
                fertilize(weak(v0)) then 
                  elementary(...)
       ],
   eval_def([1,2,1],plus2) then 
     eval_def([1,1,2,1],plus1) then 
       induction([s(s(x))],[x:pnat]) then 
         [eval_def([2,1],half2) then 
            eval_def([1,1,1],plus1) then 
              eval_def([1,1],half2) then 
                elementary(...),
          eval_def([2,1],half3) then 
            eval_def([1,2,1],half1) then 
              eval_def([1,1,1],plus2) then 
                eval_def([1,1,1,1],plus1) then 
                  eval_def([1,1],half3) then 
                    eval_def([1,1,1],half1) then 
                      elementary(...),
          wave([1,2,1],[ssid,equ(left)]) then 
            wave([1,1,2,1],[ssid,equ(left)]) then 
              wave([2,1],[half3,equ(left)]) then 
                wave([1,1,1],[plus2,equ(left)]) then 
                  wave([1,1,1,1],[plus2,equ(left)]) then 
                    wave([1,1],[half3,equ(left)]) then 
                      fertilize(weak(v0)) then 
                        elementary(...)
         ],
   wave([1,2,1],[plus2,equ(left)]) then 
     wave([1,1,2,1],[plus2,equ(left)]) then 
       wave([2,1],[half3,equ(left)]) then 
         wave([1,1,1],[lemma1,equ(left)]) then 
           wave([1,1],[half3,equ(left)]) then 
             fertilize(weak(v0)) then 
               elementary(...)
  ]

------------------------------------------------------------
lemma1:

[x:pnat,y:pnat]

|- plus(x,s(s(y)))=s(s(plus(x,y)))in pnat

induction([s(x)],[x:pnat]) then 
  [eval_def([1,1],plus1) then 
     eval_def([1,1,2,1],plus1) then 
       elementary(...),
   wave([1,1,2,1],[plus2,equ(left)]) then 
     wave([1,2,1],[ssid,equ(left)]) then 
       wave([2,1],[ssid,equ(left)]) then 
         wave([1,1],[plus2,equ(left)]) then 
           fertilize(weak(v0)) then 
             elementary(...)
  ]


PLANNING for halfplus2 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
deleting theorem record for half...done
deleting synth(half)...done
deleting def(half)...done
deleting theorem record for half1...done
deleting wave record for half1...done
deleting wave record for half1...done
deleting func_defeqn record for half1...done
deleting wave(half1)...done
deleting theorem record for half2...done
deleting wave record for half2...done
deleting wave record for half2...done
deleting func_defeqn record for half2...done
deleting wave(half2)...done
deleting theorem record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting wave record for half3...done
deleting func_defeqn record for half3...done
deleting wave(half3)...done
deleting theorem record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave record for ssid...done
deleting wave(ssid)...done
deleting theorem record for halfplus2...done
deleting thm(halfplus2)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading synth(qrev)...done
loading def(qrev)...done
loading eqn(qrev1)...done
loading eqn(qrev2)...done
 adding wave-rules for qrev1:..done
 adding wave-rules for qrev2:..done
 adding defeqn-record for qrev1...done 
 adding defeqn-record for qrev2...done 
loading thm(assapp)...done
 adding wave-rules for assapp:........done
loading thm(revqrevnil1)...done
revqrevnil1([])
==>l:pnat list=>rev(l)=qrev(l,nil)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|revqrevnil1([2])
|v0:pnat
|l:pnat list
|v1:ih(rev(l)=qrev(l,nil)in pnat list)
|==>rev(``v0::{l}''<out>)=qrev(``v0::{l}''<out>,nil)in pnat list
|SELECTED METHOD at depth 1: wave([1,1],[rev2,equ(left)])
||revqrevnil1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(rev(l)=qrev(l,nil)in pnat list)
||==>``app({rev(l)},v0::nil)''<out> =qrev(``v0::{l}''<out>,nil)in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- M11(rev(l),v2)=qrev(l,M12(v2))in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l:pnat list=>v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
|==>v2:pnat list=>M11(rev(``v0::{l}''<out>),\v2/)=qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>app(Var39(rev(l),v2),rev(l))=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>``app({app(Var39(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>Var42(rev(l),v2)::rev(l)=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>``app({Var42(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>app(rev(l),Var49(rev(l),v2))=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>app(rev(l),``app(v0::nil,{Var49(rev(l),\v2/)})''<in>)=qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|||SELECTED METHOD at depth 3: eval_def([2,1,1],app2)

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[qrev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
||==>v2:pnat list=>M11(rev(``v0::{l}''<out>),\v2/)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[rev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,2,1],[app2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,app(Var73(v2),Var74(v2)))in pnat list)
|||==>v2:pnat list=>M11(rev(``v0::{l}''<out>),\v2/)=qrev(l,app(``v0::{Var73(\v2/)}''<in>,Var74(\v2/)))in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[rev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[app2,equ(right)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>l:pnat list=>v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
|==>v2:pnat list=>M11(rev(``v0::{l}''<out>),\v2/)=qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>app(Var100(rev(l),v2),rev(l))=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>``app({app(Var100(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(``v0::{l}''<out>,M12(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>app(Var100(rev(l),v2),rev(l))=qrev(l,M12(v2))in pnat list)
||||==>v2:pnat list=>``app({app(Var100(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>app(Var100(rev(l),v2),rev(l))=qrev(l,app(Var115(v2),Var116(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var100(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(``v0::{Var115(\v2/)}''<in>,Var116(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(Var100(rev(l),v2),rev(l))=qrev(l,app(app(Var119(v2),Var120(v2)),Var116(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var100(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(app(``v0::{Var119(\v2/)}''<in>,Var120(\v2/)),Var116(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,M12(v2))in pnat list)
|||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,app(Var127(v2),Var128(v2)))in pnat list)
||||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,app(``v0::{Var127(\v2/)}''<in>,Var128(\v2/)))in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,2,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,app(app(Var146(v2),Var147(v2)),Var128(v2)))in pnat list)
|||||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,app(app(``v0::{Var146(\v2/)}''<in>,Var147(\v2/)),Var128(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>M11(rev(l),v2)=qrev(l,app(app(app(Var165(v2),Var166(v2)),Var147(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>M11(``app({rev(l)},v0::nil)''<out>,\v2/)=qrev(l,app(app(app(``v0::{Var165(\v2/)}''<in>,Var166(\v2/)),Var147(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(Var169(rev(l),v2),rev(l))=qrev(l,app(app(Var146(v2),Var147(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var169(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(app(``v0::{Var146(\v2/)}''<in>,Var147(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>Var172(rev(l),v2)::rev(l)=qrev(l,app(app(Var146(v2),Var147(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var172(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,app(app(``v0::{Var146(\v2/)}''<in>,Var147(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(rev(l),Var179(rev(l),v2))=qrev(l,app(app(Var146(v2),Var147(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>app(rev(l),``app(v0::nil,{Var179(rev(l),\v2/)})''<in>)=qrev(l,app(app(``v0::{Var146(\v2/)}''<in>,Var147(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: eval_def([2,1,1],app2)

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>app(Var150(rev(l),v2),rev(l))=qrev(l,app(Var127(v2),Var128(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var150(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(``v0::{Var127(\v2/)}''<in>,Var128(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(Var150(rev(l),v2),rev(l))=qrev(l,app(app(Var211(v2),Var212(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var150(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(app(``v0::{Var211(\v2/)}''<in>,Var212(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>Var153(rev(l),v2)::rev(l)=qrev(l,app(Var127(v2),Var128(v2)))in pnat list)
|||||==>v2:pnat list=>``app({Var153(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,app(``v0::{Var127(\v2/)}''<in>,Var128(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>Var153(rev(l),v2)::rev(l)=qrev(l,app(app(Var219(v2),Var220(v2)),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var153(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,app(app(``v0::{Var219(\v2/)}''<in>,Var220(\v2/)),Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assapp,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>app(rev(l),Var160(rev(l),v2))=qrev(l,app(Var127(v2),Var128(v2)))in pnat list)
|||||==>v2:pnat list=>app(rev(l),``app(v0::nil,{Var160(rev(l),\v2/)})''<in>)=qrev(l,app(``v0::{Var127(\v2/)}''<in>,Var128(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1,1],app2)
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(rev(l),Var160(rev(l),v2))=qrev(l,app(Var127(v2),Var128(v2)))in pnat list)
||||||==>v2:pnat list=>app(rev(l),``v0::app(nil,{Var160(rev(l),\v2/)})''<in>)=qrev(l,app(``v0::{Var127(\v2/)}''<in>,Var128(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: eval_def([2,1,1,2],app1)

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>app(Var131(rev(l),v2),rev(l))=qrev(l,M12(v2))in pnat list)
||||==>v2:pnat list=>``app({app(Var131(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>app(Var131(rev(l),v2),rev(l))=qrev(l,app(Var227(v2),Var228(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var131(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(``v0::{Var227(\v2/)}''<in>,Var228(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(Var131(rev(l),v2),rev(l))=qrev(l,app(app(Var231(v2),Var232(v2)),Var228(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var131(rev(l),\v2/),rev(l))},v0::nil)''<out> =qrev(l,app(app(``v0::{Var231(\v2/)}''<in>,Var232(\v2/)),Var228(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>Var134(rev(l),v2)::rev(l)=qrev(l,M12(v2))in pnat list)
||||==>v2:pnat list=>``app({Var134(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>Var134(rev(l),v2)::rev(l)=qrev(l,app(Var239(v2),Var240(v2)))in pnat list)
|||||==>v2:pnat list=>``app({Var134(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,app(``v0::{Var239(\v2/)}''<in>,Var240(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>Var134(rev(l),v2)::rev(l)=qrev(l,app(app(Var243(v2),Var244(v2)),Var240(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var134(rev(l),\v2/)::rev(l)},v0::nil)''<out> =qrev(l,app(app(``v0::{Var243(\v2/)}''<in>,Var244(\v2/)),Var240(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>app(rev(l),Var141(rev(l),v2))=qrev(l,M12(v2))in pnat list)
||||==>v2:pnat list=>app(rev(l),``app(v0::nil,{Var141(rev(l),\v2/)})''<in>)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
||||SELECTED METHOD at depth 4: eval_def([2,1,1],app2)
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>app(rev(l),Var141(rev(l),v2))=qrev(l,M12(v2))in pnat list)
|||||==>v2:pnat list=>app(rev(l),``v0::app(nil,{Var141(rev(l),\v2/)})''<in>)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1,1,2],app1)
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>app(rev(l),Var141(rev(l),v2))=qrev(l,M12(v2))in pnat list)
||||||==>v2:pnat list=>app(rev(l),``v0::{Var141(rev(l),\v2/)}''<in>)=qrev(l,``v0::{M12(\v2/)}''<in>)in pnat list
[v0:pnat,l:pnat list,v1:ih(v2:pnat list=>app(rev(l),v2)=qrev(l,v2)in pnat list)]==>v2:pnat list=>app(rev(l),v0::v2)=qrev(l,v0::v2)in pnat list
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
|lemma1([1])
|l:pnat list
|==>v2:pnat list=>app(rev(nil),v2)=qrev(nil,v2)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],qrev1)
||lemma1([1,1])
||l:pnat list
||==>v2:pnat list=>app(rev(nil),v2)=v2 in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],rev1)
|||lemma1([1,1,1])
|||l:pnat list
|||==>v2:pnat list=>app(nil,v2)=v2 in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app1)
||||lemma1([1,1,1,1])
||||l:pnat list
||||==>v2:pnat list=>v2=v2 in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- app(rev(l),v2)=qrev(l,v2)in pnat list

WARNING: generalization requires verifying.

Planning complete for revqrevnil1

------------------------------------------------------------
revqrevnil1:

[l:pnat list]

|- rev(l)=qrev(l,nil)in pnat list

generalize(lemma1)


PLANNING for revqrevnil1 COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for qrev...done
deleting synth(qrev)...done
deleting def(qrev)...done
deleting theorem record for qrev1...done
deleting wave record for qrev1...done
deleting wave record for qrev1...done
deleting func_defeqn record for qrev1...done
deleting wave(qrev1)...done
deleting theorem record for qrev2...done
deleting wave record for qrev2...done
deleting wave record for qrev2...done
deleting func_defeqn record for qrev2...done
deleting wave(qrev2)...done
deleting theorem record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave(assapp)...done
deleting theorem record for revqrevnil1...done
deleting thm(revqrevnil1)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev_flatten)...done
loading eqn(rev_flatten1)...done
loading eqn(rev_flatten2)...done
 adding wave-rules for rev_flatten1:..done
 adding wave-rules for rev_flatten2:..............done
 adding defeqn-record for rev_flatten1...done 
 adding defeqn-record for rev_flatten2...done 
loading def(qrev_flatten)...done
loading eqn(qrev_flatten1)...done
loading eqn(qrev_flatten2)...done
 adding wave-rules for qrev_flatten1:..done
 adding wave-rules for qrev_flatten2:..done
 adding defeqn-record for qrev_flatten1...done 
 adding defeqn-record for qrev_flatten2...done 
loading thm(assapp)...done
 adding wave-rules for assapp:........done
loading thm(revflatqrev)...done
revflatqrev([])
==>l: (pnat list)list=>rev_flatten(l)=qrev_flatten(l,nil)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l: (pnat list)list])
|revflatqrev([2])
|v0:pnat list
|l: (pnat list)list
|v1:ih(rev_flatten(l)=qrev_flatten(l,nil)in pnat list)
|==>rev_flatten(``v0::{l}''<out>)=qrev_flatten(``v0::{l}''<out>,nil)in pnat list
|SELECTED METHOD at depth 1: wave([1,1],[rev_flatten2,equ(left)])
||revflatqrev([1,2])
||v0:pnat list
||l: (pnat list)list
||v1:ih(rev_flatten(l)=qrev_flatten(l,nil)in pnat list)
||==>``app({rev_flatten(l)},v0)''<out> =qrev_flatten(``v0::{l}''<out>,nil)in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l: (pnat list)list,v2:pnat list]

|- M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l: (pnat list)list=>v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l: (pnat list)list])
|lemma1([2])
|v0:pnat list
|l: (pnat list)list
|v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
|==>v2:pnat list=>M13(rev_flatten(``v0::{l}''<out>),\v2/)=qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev_flatten2,equ(left)])
||lemma1([1,2])
||v0:pnat list
||l: (pnat list)list
||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>app(Var251(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>``app({app(Var251(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev_flatten2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev_flatten2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>Var254(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>``app({Var254(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev_flatten2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>app(rev_flatten(l),Var261(rev_flatten(l),v2))=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>app(rev_flatten(l),``app(v0,{Var261(rev_flatten(l),\v2/)})''<in>)=qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev_flatten2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[qrev_flatten2,equ(left)])
||lemma1([1,2])
||v0:pnat list
||l: (pnat list)list
||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
||==>v2:pnat list=>M13(rev_flatten(``v0::{l}''<out>),\v2/)=qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[rev_flatten2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,2,1],[assapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,app(Var289(v2),Var290(v2)))in pnat list)
|||==>v2:pnat list=>M13(rev_flatten(``v0::{l}''<out>),\v2/)=qrev_flatten(l,app(``app(v0,{Var289(\v2/)})''<in>,Var290(\v2/)))in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[rev_flatten2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[assapp,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>l: (pnat list)list=>v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l: (pnat list)list])
|lemma1([2])
|v0:pnat list
|l: (pnat list)list
|v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
|==>v2:pnat list=>M13(rev_flatten(``v0::{l}''<out>),\v2/)=qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev_flatten2,equ(left)])
||lemma1([1,2])
||v0:pnat list
||l: (pnat list)list
||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[assapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>app(Var316(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>``app({app(Var316(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(``v0::{l}''<out>,M14(\v2/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev_flatten2,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat list
||||l: (pnat list)list
||||v1:ih(v2:pnat list=>app(Var316(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,M14(v2))in pnat list)
||||==>v2:pnat list=>``app({app(Var316(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>app(Var316(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(Var331(v2),Var332(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var316(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(``app(v0,{Var331(\v2/)})''<in>,Var332(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(Var316(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(app(Var335(v2),Var336(v2)),Var332(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var316(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var335(\v2/)})''<in>,Var336(\v2/)),Var332(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev_flatten2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat list
|||l: (pnat list)list
|||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,M14(v2))in pnat list)
|||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[assapp,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat list
||||l: (pnat list)list
||||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,app(Var343(v2),Var344(v2)))in pnat list)
||||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,app(``app(v0,{Var343(\v2/)})''<in>,Var344(\v2/)))in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,2,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,app(app(Var362(v2),Var363(v2)),Var344(v2)))in pnat list)
|||||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,app(app(``app(v0,{Var362(\v2/)})''<in>,Var363(\v2/)),Var344(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>M13(rev_flatten(l),v2)=qrev_flatten(l,app(app(app(Var381(v2),Var382(v2)),Var363(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>M13(``app({rev_flatten(l)},v0)''<out>,\v2/)=qrev_flatten(l,app(app(app(``app(v0,{Var381(\v2/)})''<in>,Var382(\v2/)),Var363(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(Var385(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(app(Var362(v2),Var363(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var385(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var362(\v2/)})''<in>,Var363(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>Var388(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,app(app(Var362(v2),Var363(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var388(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var362(\v2/)})''<in>,Var363(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(rev_flatten(l),Var395(rev_flatten(l),v2))=qrev_flatten(l,app(app(Var362(v2),Var363(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>app(rev_flatten(l),``app(v0,{Var395(rev_flatten(l),\v2/)})''<in>)=qrev_flatten(l,app(app(``app(v0,{Var362(\v2/)})''<in>,Var363(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assapp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>app(Var366(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(Var343(v2),Var344(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var366(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(``app(v0,{Var343(\v2/)})''<in>,Var344(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(Var366(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(app(Var435(v2),Var436(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var366(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var435(\v2/)})''<in>,Var436(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>Var369(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,app(Var343(v2),Var344(v2)))in pnat list)
|||||==>v2:pnat list=>``app({Var369(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,app(``app(v0,{Var343(\v2/)})''<in>,Var344(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>Var369(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,app(app(Var443(v2),Var444(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var369(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var443(\v2/)})''<in>,Var444(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assapp,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>app(rev_flatten(l),Var376(rev_flatten(l),v2))=qrev_flatten(l,app(Var343(v2),Var344(v2)))in pnat list)
|||||==>v2:pnat list=>app(rev_flatten(l),``app(v0,{Var376(rev_flatten(l),\v2/)})''<in>)=qrev_flatten(l,app(``app(v0,{Var343(\v2/)})''<in>,Var344(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(rev_flatten(l),Var376(rev_flatten(l),v2))=qrev_flatten(l,app(app(Var451(v2),Var452(v2)),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>app(rev_flatten(l),``app(v0,{Var376(rev_flatten(l),\v2/)})''<in>)=qrev_flatten(l,app(app(``app(v0,{Var451(\v2/)})''<in>,Var452(\v2/)),Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(rev_flatten(l),app(Var455(rev_flatten(l),v2),Var456(rev_flatten(l),v2)))=qrev_flatten(l,app(Var343(v2),Var344(v2)))in pnat list)
||||||==>v2:pnat list=>app(rev_flatten(l),app(``app(v0,{Var455(rev_flatten(l),\v2/)})''<in>,Var456(rev_flatten(l),\v2/)))=qrev_flatten(l,app(``app(v0,{Var343(\v2/)})''<in>,Var344(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat list
||||l: (pnat list)list
||||v1:ih(v2:pnat list=>app(Var347(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,M14(v2))in pnat list)
||||==>v2:pnat list=>``app({app(Var347(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>app(Var347(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(Var475(v2),Var476(v2)))in pnat list)
|||||==>v2:pnat list=>``app({app(Var347(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(``app(v0,{Var475(\v2/)})''<in>,Var476(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>app(Var347(rev_flatten(l),v2),rev_flatten(l))=qrev_flatten(l,app(app(Var479(v2),Var480(v2)),Var476(v2)))in pnat list)
||||||==>v2:pnat list=>``app({app(Var347(rev_flatten(l),\v2/),rev_flatten(l))},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var479(\v2/)})''<in>,Var480(\v2/)),Var476(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat list
||||l: (pnat list)list
||||v1:ih(v2:pnat list=>Var350(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,M14(v2))in pnat list)
||||==>v2:pnat list=>``app({Var350(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[assapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat list
|||||l: (pnat list)list
|||||v1:ih(v2:pnat list=>Var350(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,app(Var487(v2),Var488(v2)))in pnat list)
|||||==>v2:pnat list=>``app({Var350(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,app(``app(v0,{Var487(\v2/)})''<in>,Var488(\v2/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat list
||||||l: (pnat list)list
||||||v1:ih(v2:pnat list=>Var350(rev_flatten(l),v2)::rev_flatten(l)=qrev_flatten(l,app(app(Var491(v2),Var492(v2)),Var488(v2)))in pnat list)
||||||==>v2:pnat list=>``app({Var350(rev_flatten(l),\v2/)::rev_flatten(l)},v0)''<out> =qrev_flatten(l,app(app(``app(v0,{Var491(\v2/)})''<in>,Var492(\v2/)),Var488(\v2/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assapp,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat list
||||l: (pnat list)list
||||v1:ih(v2:pnat list=>app(rev_flatten(l),Var357(rev_flatten(l),v2))=qrev_flatten(l,M14(v2))in pnat list)
||||==>v2:pnat list=>app(rev_flatten(l),``app(v0,{Var357(rev_flatten(l),\v2/)})''<in>)=qrev_flatten(l,``app(v0,{M14(\v2/)})''<in>)in pnat list
[v0:pnat list,l: (pnat list)list,v1:ih(v2:pnat list=>app(rev_flatten(l),v2)=qrev_flatten(l,v2)in pnat list)]==>v2:pnat list=>app(rev_flatten(l),app(v0,v2))=qrev_flatten(l,app(v0,v2))in pnat list
||||TERMINATING METHOD at depth 4: fertilize(strong(v1))
|lemma1([1])
|l: (pnat list)list
|==>v2:pnat list=>app(rev_flatten(nil),v2)=qrev_flatten(nil,v2)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],qrev_flatten1)
||lemma1([1,1])
||l: (pnat list)list
||==>v2:pnat list=>app(rev_flatten(nil),v2)=v2 in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],rev_flatten1)
|||lemma1([1,1,1])
|||l: (pnat list)list
|||==>v2:pnat list=>app(nil,v2)=v2 in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app1)
||||lemma1([1,1,1,1])
||||l: (pnat list)list
||||==>v2:pnat list=>v2=v2 in pnat list
||||TERMINATING METHOD at depth 4: elementary(...)
------------------------------------------------------------
lemma1:

[l: (pnat list)list,v2:pnat list]

|- app(rev_flatten(l),v2)=qrev_flatten(l,v2)in pnat list

WARNING: generalization requires verifying.

Planning complete for revflatqrev

------------------------------------------------------------
revflatqrev:

[l: (pnat list)list]

|- rev_flatten(l)=qrev_flatten(l,nil)in pnat list

generalize(lemma1)


PLANNING for revflatqrev COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev_flatten) not present, so cannot be deleted
deleting def(rev_flatten)...done
deleting theorem record for rev_flatten1...done
deleting wave record for rev_flatten1...done
deleting wave record for rev_flatten1...done
deleting func_defeqn record for rev_flatten1...done
deleting wave(rev_flatten1)...done
deleting theorem record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting wave record for rev_flatten2...done
deleting func_defeqn record for rev_flatten2...done
deleting wave(rev_flatten2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(qrev_flatten) not present, so cannot be deleted
deleting def(qrev_flatten)...done
deleting theorem record for qrev_flatten1...done
deleting wave record for qrev_flatten1...done
deleting wave record for qrev_flatten1...done
deleting func_defeqn record for qrev_flatten1...done
deleting wave(qrev_flatten1)...done
deleting theorem record for qrev_flatten2...done
deleting wave record for qrev_flatten2...done
deleting wave record for qrev_flatten2...done
deleting func_defeqn record for qrev_flatten2...done
deleting wave(qrev_flatten2)...done
deleting theorem record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave(assapp)...done
deleting theorem record for revflatqrev...done
deleting thm(revflatqrev)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading synth(qrev)...done
loading def(qrev)...done
loading eqn(qrev1)...done
loading eqn(qrev2)...done
 adding wave-rules for qrev1:..done
 adding wave-rules for qrev2:..done
 adding defeqn-record for qrev1...done 
 adding defeqn-record for qrev2...done 
loading thm(assconsapp)...done
 adding wave-rules for assconsapp:.....done
loading thm(tailrev1)...done
 adding wave-rules for tailrev1:..............done
loading thm(revqrevnil2)...done
revqrevnil2([])
==>l:pnat list=>rev(qrev(l,nil))=l in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|revqrevnil2([2])
|v0:pnat
|l:pnat list
|v1:ih(rev(qrev(l,nil))=l in pnat list)
|==>rev(qrev(``v0::{l}''<out>,nil))=``v0::{l}''<out>in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rev(qrev(l,M15(v2)))=M16(l,v2)in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l:pnat list=>v2:pnat list=>rev(qrev(l,M15(v2)))=M16(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=M16(l,v2)in pnat list)
|==>v2:pnat list=>rev(qrev(``v0::{l}''<out>,M15(\v2/)))=M16(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([2,1],[app2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=app(l,Var501(l,v2))in pnat list)
||==>v2:pnat list=>rev(qrev(``v0::{l}''<out>,M15(\v2/)))=``v0::{app(l,Var501(l,\v2/))}''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=app(l,Var501(l,v2))in pnat list)
|||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=``v0::{app(l,Var501(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([1,1,1],[qrev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=M16(l,v2)in pnat list)
||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=M16(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1,1,1],[tailrev1,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,rev(Var517(v2))))=M16(l,v2)in pnat list)
|||==>v2:pnat list=>rev(qrev(l,rev(``app({Var517(\v2/)},v0::nil)''<in>)))=M16(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1,1],[app2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,app(Var518(v2),Var519(v2))))=M16(l,v2)in pnat list)
|||==>v2:pnat list=>rev(qrev(l,app(``v0::{Var518(\v2/)}''<in>,Var519(\v2/))))=M16(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=app(l,Var523(l,v2))in pnat list)
|||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=``v0::{app(l,Var523(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=app(Var527(l,v2),l)in pnat list)
|||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=app(``app({Var527(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=qrev(l,Var530(l,v2))in pnat list)
|||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=qrev(l,``v0::{Var530(l,\v2/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(qrev(l,M15(v2)))=qrev(Var531(l,v2),l)in pnat list)
|||==>v2:pnat list=>rev(qrev(l,``v0::{M15(\v2/)}''<in>))=qrev(``v0::{Var531(l,\v2/)}''<in>,l)in pnat list
[v0:pnat,l:pnat list,v1:ih(v2:pnat list=>rev(qrev(l,v2))=qrev(v2,l)in pnat list)]==>v2:pnat list=>rev(qrev(l,v0::v2))=qrev(v0::v2,l)in pnat list
|||TERMINATING METHOD at depth 3: fertilize(strong(v1))
|lemma1([1])
|l:pnat list
|==>v2:pnat list=>rev(qrev(nil,v2))=qrev(v2,nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,1],qrev1)
||lemma1([1,1])
||l:pnat list
||==>v2:pnat list=>rev(v2)=qrev(v2,nil)in pnat list
||SELECTED METHOD at depth 2: induction([v0::v2],[v2:pnat list])
|||lemma1([2,1,1])
|||v0:pnat
|||v2:pnat list
|||v1:ih(rev(v2)=qrev(v2,nil)in pnat list)
|||l:pnat list
|||==>rev(``v0::{v2}''<out>)=qrev(``v0::{v2}''<out>,nil)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1],[rev2,equ(left)])
||||lemma1([1,2,1,1])
||||v0:pnat
||||v2:pnat list
||||v1:ih(rev(v2)=qrev(v2,nil)in pnat list)
||||l:pnat list
||||==>``app({rev(v2)},v0::nil)''<out> =qrev(``v0::{v2}''<out>,nil)in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma2:

[v2:pnat list,v3:pnat list]

|- M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list

saving thm(lemma2)...done
Depth bound set to 4
lemma2([])
==>v2:pnat list=>v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list
SELECTED METHOD at depth 0: induction([v0::v2],[v2:pnat list])
|lemma2([2])
|v0:pnat
|v2:pnat list
|v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
|==>v3:pnat list=>M17(rev(``v0::{v2}''<out>),\v3/)=qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||lemma2([1,2])
||v0:pnat
||v2:pnat list
||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(right)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>Var593(rev(v2),v3)::rev(v2)=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>``app({Var593(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,``v0::{M18(\v3/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assconsapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assconsapp,equ(right)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>app(rev(v2),Var602(rev(v2),v3))=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>app(rev(v2),``v0::{Var602(rev(v2),\v3/)}''<in>)=qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(right)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[qrev2,equ(left)])
||lemma2([1,2])
||v0:pnat
||v2:pnat list
||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
||==>v3:pnat list=>M17(rev(``v0::{v2}''<out>),\v3/)=qrev(v2,``v0::{M18(\v3/)}''<in>)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[rev2,equ(left)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,``v0::{M18(\v3/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assconsapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,2,1],[tailrev1,equ(right)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,rev(Var631(v3)))in pnat list)
|||==>v3:pnat list=>M17(rev(``v0::{v2}''<out>),\v3/)=qrev(v2,rev(``app({Var631(\v3/)},v0::nil)''<in>))in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[rev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,2,1],[app2,equ(right)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,app(Var632(v3),Var633(v3)))in pnat list)
|||==>v3:pnat list=>M17(rev(``v0::{v2}''<out>),\v3/)=qrev(v2,app(``v0::{Var632(\v3/)}''<in>,Var633(\v3/)))in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[rev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[app2,equ(right)])

Failed at depth 4
Depth bound set to 7
lemma2([])
==>v2:pnat list=>v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list
SELECTED METHOD at depth 0: induction([v0::v2],[v2:pnat list])
|lemma2([2])
|v0:pnat
|v2:pnat list
|v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
|==>v3:pnat list=>M17(rev(``v0::{v2}''<out>),\v3/)=qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[rev2,equ(left)])
||lemma2([1,2])
||v0:pnat
||v2:pnat list
||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
||SELECTED METHOD at depth 2: wave([1,1],[app2,equ(right)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(``v0::{v2}''<out>,M18(\v3/))in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])
||||lemma2([1,1,1,2])
||||v0:pnat
||||v2:pnat list
||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,M18(v3))in pnat list)
||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,``v0::{M18(\v3/)}''<in>)in pnat list
||||SELECTED METHOD at depth 4: wave([2,2,1],[tailrev1,equ(right)])
|||||lemma2([1,1,1,1,2])
|||||v0:pnat
|||||v2:pnat list
|||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,rev(Var679(v3)))in pnat list)
|||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,rev(``app({Var679(\v3/)},v0::nil)''<in>))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[rev2,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,rev(rev(Var683(v3))))in pnat list)
||||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,rev(rev(``v0::{Var683(\v3/)}''<in>)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(left)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,rev(Var684(v3)::Var685(v3)))in pnat list)
||||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,rev(Var684(\v3/)::``app({Var685(\v3/)},v0::nil)''<in>))in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1,2,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,2,2,1],[app2,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([2,2,1],[app2,equ(right)])
|||||lemma2([1,1,1,1,2])
|||||v0:pnat
|||||v2:pnat list
|||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,app(Var680(v3),Var681(v3)))in pnat list)
|||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,app(``v0::{Var680(\v3/)}''<in>,Var681(\v3/)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[tailrev1,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,app(rev(Var695(v3)),Var681(v3)))in pnat list)
||||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,app(rev(``app({Var695(\v3/)},v0::nil)''<in>),Var681(\v3/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[app2,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>Var665(rev(v2),v3)::rev(v2)=qrev(v2,app(app(Var696(v3),Var697(v3)),Var681(v3)))in pnat list)
||||||==>v3:pnat list=>``app({Var665(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,app(app(``v0::{Var696(\v3/)}''<in>,Var697(\v3/)),Var681(\v3/)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma2([1,1,2])
|||v0:pnat
|||v2:pnat list
|||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,M18(v3))in pnat list)
|||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,``v0::{M18(\v3/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,2,1],[tailrev1,equ(right)])
||||lemma2([1,1,1,2])
||||v0:pnat
||||v2:pnat list
||||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,rev(Var707(v3)))in pnat list)
||||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,rev(``app({Var707(\v3/)},v0::nil)''<in>))in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,2,1],[rev2,equ(right)])
|||||lemma2([1,1,1,1,2])
|||||v0:pnat
|||||v2:pnat list
|||||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,rev(rev(Var727(v3))))in pnat list)
|||||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,rev(rev(``v0::{Var727(\v3/)}''<in>)))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,2,2,1],[tailrev1,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,rev(rev(rev(Var747(v3)))))in pnat list)
||||||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,rev(rev(rev(``app({Var747(\v3/)},v0::nil)''<in>))))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assconsapp,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1,2,2,1],[app2,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>M17(rev(v2),v3)=qrev(v2,rev(rev(app(Var748(v3),Var749(v3)))))in pnat list)
||||||==>v3:pnat list=>M17(``app({rev(v2)},v0::nil)''<out>,\v3/)=qrev(v2,rev(rev(app(``v0::{Var748(\v3/)}''<in>,Var749(\v3/)))))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assconsapp,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[app2,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>Var753(rev(v2),v3)::rev(v2)=qrev(v2,rev(rev(Var727(v3))))in pnat list)
||||||==>v3:pnat list=>``app({Var753(rev(v2),\v3/)::rev(v2)},v0::nil)''<out> =qrev(v2,rev(rev(``v0::{Var727(\v3/)}''<in>)))in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assconsapp,equ(right)])
||||||lemma2([1,1,1,1,1,2])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v3:pnat list=>app(rev(v2),Var762(rev(v2),v3))=qrev(v2,rev(rev(Var727(v3))))in pnat list)
||||||==>v3:pnat list=>app(rev(v2),``v0::{Var762(rev(v2),\v3/)}''<in>)=qrev(v2,rev(rev(``v0::{Var727(\v3/)}''<in>)))in pnat list
[v0:pnat,v2:pnat list,v1:ih(v3:pnat list=>app(rev(v2),v3)=qrev(v2,rev(rev(v3)))in pnat list)]==>v3:pnat list=>app(rev(v2),v0::v3)=qrev(v2,rev(rev(v0::v3)))in pnat list
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
|lemma2([1])
|v2:pnat list
|==>v3:pnat list=>app(rev(nil),v3)=qrev(nil,rev(rev(v3)))in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1],qrev1)
||lemma2([1,1])
||v2:pnat list
||==>v3:pnat list=>app(rev(nil),v3)=rev(rev(v3))in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],rev1)
|||lemma2([1,1,1])
|||v2:pnat list
|||==>v3:pnat list=>app(nil,v3)=rev(rev(v3))in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],app1)
||||lemma2([1,1,1,1])
||||v2:pnat list
||||==>v3:pnat list=>v3=rev(rev(v3))in pnat list
||||SELECTED METHOD at depth 4: induction([v0::v3],[v3:pnat list])
|||||lemma2([2,1,1,1,1])
|||||v0:pnat
|||||v3:pnat list
|||||v1:ih(v3=rev(rev(v3))in pnat list)
|||||v2:pnat list
|||||==>``v0::{v3}''<out> =rev(rev(``v0::{v3}''<out>))in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1],[rev2,equ(left)])
||||||lemma2([1,2,1,1,1,1])
||||||v0:pnat
||||||v3:pnat list
||||||v1:ih(v3=rev(rev(v3))in pnat list)
||||||v2:pnat list
||||||==>``v0::{v3}''<out> =rev(``app({rev(v3)},v0::nil)''<out>)in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1],[tailrev1,equ(left)])
|||||||lemma2([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||v3:pnat list
|||||||v1:ih(v3=rev(rev(v3))in pnat list)
|||||||v2:pnat list
|||||||==>``v0::{v3}''<out> =``v0::{rev(rev(v3))}''<out>in pnat list
|||||||SELECTED METHOD at depth 7: fertilize(weak(v1))
Depth bound set to 10
|||||||lemma2([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||v3:pnat list
|||||||v1:ih(v3=rev(rev(v3))in pnat list)
|||||||v2:pnat list
|||||||==>``v0::{v3}''<out> =``v0::{rev(rev(v3))}''<out>in pnat list
|||||||SELECTED METHOD at depth 7: fertilize(weak(v1))
||||||||lemma2([1,1,1,2,1,1,1,1])
||||||||v0:pnat
||||||||v3:pnat list
||||||||v1:ih(v3=rev(rev(v3))in pnat list)
||||||||v2:pnat list
||||||||==>v0::v3=v0::v3 in pnat list
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||lemma2([1,1,1,1,1])
|||||v3:pnat list
|||||v2:pnat list
|||||==>nil=rev(rev(nil))in pnat list
|||||SELECTED METHOD at depth 5: eval_def([1,2,1],rev1)
||||||lemma2([1,1,1,1,1,1])
||||||v3:pnat list
||||||v2:pnat list
||||||==>nil=rev(nil)in pnat list
||||||SELECTED METHOD at depth 6: eval_def([2,1],rev1)
|||||||lemma2([1,1,1,1,1,1,1])
|||||||v3:pnat list
|||||||v2:pnat list
|||||||==>nil=nil in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
------------------------------------------------------------
lemma2:

[v2:pnat list,v3:pnat list]

|- app(rev(v2),v3)=qrev(v2,rev(rev(v3)))in pnat list

WARNING: generalization requires verifying.

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rev(qrev(l,v2))=qrev(v2,l)in pnat list

WARNING: generalization requires verifying.

Planning complete for revqrevnil2

------------------------------------------------------------
revqrevnil2:

[l:pnat list]

|- rev(qrev(l,nil))=l in pnat list

generalize(lemma1)


PLANNING for revqrevnil2 COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for lemma2...done
deleting thm(lemma2)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for qrev...done
deleting synth(qrev)...done
deleting def(qrev)...done
deleting theorem record for qrev1...done
deleting wave record for qrev1...done
deleting wave record for qrev1...done
deleting func_defeqn record for qrev1...done
deleting wave(qrev1)...done
deleting theorem record for qrev2...done
deleting wave record for qrev2...done
deleting wave record for qrev2...done
deleting func_defeqn record for qrev2...done
deleting wave(qrev2)...done
deleting theorem record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave(assconsapp)...done
deleting theorem record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave(tailrev1)...done
deleting theorem record for revqrevnil2...done
deleting thm(revqrevnil2)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(assconsapp)...done
 adding wave-rules for assconsapp:.....done
loading thm(revrevnil1)...done
revrevnil1([])
==>l:pnat list=>rev(app(rev(l),nil))=l in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|revrevnil1([2])
|v0:pnat
|l:pnat list
|v1:ih(rev(app(rev(l),nil))=l in pnat list)
|==>rev(app(rev(``v0::{l}''<out>),nil))=``v0::{l}''<out>in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1,1],[rev2,equ(left)])
||revrevnil1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(rev(app(rev(l),nil))=l in pnat list)
||==>rev(app(``app({rev(l)},v0::nil)''<out>,nil))=``v0::{l}''<out>in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l:pnat list=>v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
|==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=M20(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1,1],[rev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=M20(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var823(l,v2))in pnat list)
|||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=``v0::{app(l,Var823(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[assconsapp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1,1],[assconsapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
|||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=M20(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(Var827(l,v2),l)in pnat list)
|||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=app(``app({Var827(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1],[assconsapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[app2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var813(l,v2))in pnat list)
||==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=``v0::{app(l,Var813(l,\v2/))}''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1,1],[rev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var813(l,v2))in pnat list)
|||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=``v0::{app(l,Var813(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[assconsapp,equ(right)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[assconsapp,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(Var817(l,v2),l)in pnat list)
||==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=app(``app({Var817(l,\v2/)},v0::nil)''<in>,l)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1,1],[rev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(Var817(l,v2),l)in pnat list)
|||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=app(``app({Var817(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1],[assconsapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1],[rev2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(rev(Var849(l,v2)),l)in pnat list)
|||==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=app(rev(``v0::{Var849(l,\v2/)}''<in>),l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[rev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,2,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(Var850(l,v2)::Var851(l,v2),l)in pnat list)
|||==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=app(Var850(l,\v2/)::``app({Var851(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[rev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[app2,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>l:pnat list=>v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
|==>v2:pnat list=>rev(app(rev(``v0::{l}''<out>),M19(\v2/)))=M20(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1,1],[rev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=M20(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var877(l,v2))in pnat list)
|||==>v2:pnat list=>rev(app(``app({rev(l)},v0::nil)''<out>,M19(\v2/)))=``v0::{app(l,Var877(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[assconsapp,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var877(l,v2))in pnat list)
||||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=``v0::{app(l,Var877(l,\v2/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([2,1,1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var885(v2),Var886(v2))))=app(l,Var877(l,v2))in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var885(\v2/)}''<in>,Var886(\v2/))))=``v0::{app(l,Var877(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var889(v2),Var890(v2)),Var886(v2))))=app(l,Var877(l,v2))in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var889(\v2/)}''<in>,Var890(\v2/)),Var886(\v2/))))=``v0::{app(l,Var877(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1,1],[assconsapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=M20(l,v2)in pnat list)
|||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=M20(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var897(v2),Var898(v2))))=M20(l,v2)in pnat list)
||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var897(\v2/)}''<in>,Var898(\v2/))))=M20(``v0::{l}''<out>,\v2/)in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,1,1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var911(v2),Var912(v2)),Var898(v2))))=M20(l,v2)in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var911(\v2/)}''<in>,Var912(\v2/)),Var898(\v2/))))=M20(``v0::{l}''<out>,\v2/)in pnat list
|||||SELECTED METHOD at depth 5: wave([1,1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(app(Var925(v2),Var926(v2)),Var912(v2)),Var898(v2))))=M20(l,v2)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(app(``v0::{Var925(\v2/)}''<in>,Var926(\v2/)),Var912(\v2/)),Var898(\v2/))))=M20(``v0::{l}''<out>,\v2/)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var911(v2),Var912(v2)),Var898(v2))))=app(l,Var931(l,v2))in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var911(\v2/)}''<in>,Var912(\v2/)),Var898(\v2/))))=``v0::{app(l,Var931(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1],[assconsapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var911(v2),Var912(v2)),Var898(v2))))=app(Var935(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var911(\v2/)}''<in>,Var912(\v2/)),Var898(\v2/))))=app(``app({Var935(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([2,1],[app2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var897(v2),Var898(v2))))=app(l,Var917(l,v2))in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var897(\v2/)}''<in>,Var898(\v2/))))=``v0::{app(l,Var917(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var965(v2),Var966(v2)),Var898(v2))))=app(l,Var917(l,v2))in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var965(\v2/)}''<in>,Var966(\v2/)),Var898(\v2/))))=``v0::{app(l,Var917(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([2,1],[assconsapp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var897(v2),Var898(v2))))=app(Var921(l,v2),l)in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var897(\v2/)}''<in>,Var898(\v2/))))=app(``app({Var921(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var973(v2),Var974(v2)),Var898(v2))))=app(Var921(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var973(\v2/)}''<in>,Var974(\v2/)),Var898(\v2/))))=app(``app({Var921(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[rev2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var897(v2),Var898(v2))))=app(rev(Var977(l,v2)),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var897(\v2/)}''<in>,Var898(\v2/))))=app(rev(``v0::{Var977(l,\v2/)}''<in>),l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var897(v2),Var898(v2))))=app(Var978(l,v2)::Var979(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var897(\v2/)}''<in>,Var898(\v2/))))=app(Var978(l,\v2/)::``app({Var979(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(l,Var903(l,v2))in pnat list)
||||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=``v0::{app(l,Var903(l,\v2/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([2,1,1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var1005(v2),Var1006(v2))))=app(l,Var903(l,v2))in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var1005(\v2/)}''<in>,Var1006(\v2/))))=``v0::{app(l,Var903(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var1009(v2),Var1010(v2)),Var1006(v2))))=app(l,Var903(l,v2))in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var1009(\v2/)}''<in>,Var1010(\v2/)),Var1006(\v2/))))=``v0::{app(l,Var903(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(Var907(l,v2),l)in pnat list)
||||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=app(``app({Var907(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||SELECTED METHOD at depth 4: wave([2,1,1,1],[app2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var1017(v2),Var1018(v2))))=app(Var907(l,v2),l)in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var1017(\v2/)}''<in>,Var1018(\v2/))))=app(``app({Var907(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||||SELECTED METHOD at depth 5: wave([1,2,1,1,1],[app2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(app(Var1025(v2),Var1026(v2)),Var1018(v2))))=app(Var907(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(app(``v0::{Var1025(\v2/)}''<in>,Var1026(\v2/)),Var1018(\v2/))))=app(``app({Var907(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[rev2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var1017(v2),Var1018(v2))))=app(rev(Var1029(l,v2)),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var1017(\v2/)}''<in>,Var1018(\v2/))))=app(rev(``v0::{Var1029(l,\v2/)}''<in>),l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,2,1],[app2,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,2,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rev(app(rev(l),app(Var1017(v2),Var1018(v2))))=app(Var1030(l,v2)::Var1031(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rev(app(rev(l),app(``v0::{Var1017(\v2/)}''<in>,Var1018(\v2/))))=app(Var1030(l,\v2/)::``app({Var1031(l,\v2/)},v0::nil)''<in>,l)in pnat list
||||||SELECTED METHOD at depth 6: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,2,1],[rev2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,2,1],[app2,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,2,1],[rev2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rev(app(rev(l),M19(v2)))=app(rev(Var1021(l,v2)),l)in pnat list)
|||||==>v2:pnat list=>rev(app(rev(l),``v0::{M19(\v2/)}''<in>))=app(rev(``v0::{Var1021(l,\v2/)}''<in>),l)in pnat list
[v0:pnat,l:pnat list,v1:ih(v2:pnat list=>rev(app(rev(l),v2))=app(rev(v2),l)in pnat list)]==>v2:pnat list=>rev(app(rev(l),v0::v2))=app(rev(v0::v2),l)in pnat list
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|lemma1([1])
|l:pnat list
|==>v2:pnat list=>rev(app(rev(nil),v2))=app(rev(v2),nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,1,1],rev1)
||lemma1([1,1])
||l:pnat list
||==>v2:pnat list=>rev(app(nil,v2))=app(rev(v2),nil)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],app1)
|||lemma1([1,1,1])
|||l:pnat list
|||==>v2:pnat list=>rev(v2)=app(rev(v2),nil)in pnat list
|||SELECTED METHOD at depth 3: generalise(rev(v2),v0:pnat list)
||||lemma1([1,1,1,1])
||||l:pnat list
||||==>v0:pnat list=>v2:pnat list=>v0=app(v0,nil)in pnat list
||||SELECTED METHOD at depth 4: induction([v1::v0],[v0:pnat list])
|||||lemma1([2,1,1,1,1])
|||||v1:pnat
|||||v0:pnat list
|||||v3:ih(v2:pnat list=>v0=app(v0,nil)in pnat list)
|||||l:pnat list
|||||==>v2:pnat list=>``v1::{v0}''<out> =app(``v1::{v0}''<out>,nil)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||lemma1([1,2,1,1,1,1])
||||||v1:pnat
||||||v0:pnat list
||||||v3:ih(v2:pnat list=>v0=app(v0,nil)in pnat list)
||||||l:pnat list
||||||==>v2:pnat list=>``v1::{v0}''<out> =``v1::{app(v0,nil)}''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v3))
|||||||lemma1([1,1,2,1,1,1,1])
|||||||v1:pnat
|||||||v0:pnat list
|||||||v3:ih(v2:pnat list=>v0=app(v0,nil)in pnat list)
|||||||l:pnat list
|||||||==>v1::v0=v1::v0 in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||||lemma1([1,1,1,1,1])
|||||v0:pnat list
|||||l:pnat list
|||||==>v2:pnat list=>nil=app(nil,nil)in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v0:pnat list
||||||l:pnat list
||||||==>v2:pnat list=>nil=nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rev(app(rev(l),v2))=app(rev(v2),l)in pnat list

WARNING: generalization requires verifying.

Planning complete for revrevnil1

------------------------------------------------------------
revrevnil1:

[l:pnat list]

|- rev(app(rev(l),nil))=l in pnat list

generalize(lemma1)


PLANNING for revrevnil1 COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave(assconsapp)...done
deleting theorem record for revrevnil1...done
deleting thm(revrevnil1)...done
loading synth(qrev)...done
loading def(qrev)...done
loading eqn(qrev1)...done
loading eqn(qrev2)...done
 adding wave-rules for qrev1:..done
 adding wave-rules for qrev2:..done
 adding defeqn-record for qrev1...done 
 adding defeqn-record for qrev2...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading def(rev)...done
loading eqn(rev1)...done
loading eqn(rev2)...done
 adding wave-rules for rev1:..done
 adding wave-rules for rev2:...............done
 adding defeqn-record for rev1...done 
 adding defeqn-record for rev2...done 
loading thm(tailrev1)...done
 adding wave-rules for tailrev1:..............done
loading thm(qrevqrevnil1)...done
qrevqrevnil1([])
==>l:pnat list=>qrev(qrev(l,nil),nil)=l in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|qrevqrevnil1([2])
|v0:pnat
|l:pnat list
|v1:ih(qrev(qrev(l,nil),nil)=l in pnat list)
|==>qrev(qrev(``v0::{l}''<out>,nil),nil)=``v0::{l}''<out>in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- qrev(qrev(l,M21(v2)),nil)=M22(l,v2)in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l:pnat list=>v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=M22(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=M22(l,v2)in pnat list)
|==>v2:pnat list=>qrev(qrev(``v0::{l}''<out>,M21(\v2/)),nil)=M22(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([2,1],[app2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=app(l,Var1059(l,v2))in pnat list)
||==>v2:pnat list=>qrev(qrev(``v0::{l}''<out>,M21(\v2/)),nil)=``v0::{app(l,Var1059(l,\v2/))}''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=app(l,Var1059(l,v2))in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,``v0::{M21(\v2/)}''<in>),nil)=``v0::{app(l,Var1059(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([1,1,1],[qrev2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=M22(l,v2)in pnat list)
||==>v2:pnat list=>qrev(qrev(l,``v0::{M21(\v2/)}''<in>),nil)=M22(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1,1,1],[tailrev1,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,rev(Var1073(v2))),nil)=M22(l,v2)in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,rev(``app({Var1073(\v2/)},v0::nil)''<in>)),nil)=M22(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[rev2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1,1],[app2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,app(Var1074(v2),Var1075(v2))),nil)=M22(l,v2)in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,app(``v0::{Var1074(\v2/)}''<in>,Var1075(\v2/))),nil)=M22(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qrev2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=app(l,Var1079(l,v2))in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,``v0::{M21(\v2/)}''<in>),nil)=``v0::{app(l,Var1079(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=qrev(l,Var1084(l,v2))in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,``v0::{M21(\v2/)}''<in>),nil)=qrev(l,``v0::{Var1084(l,\v2/)}''<in>)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1,1],[app2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[tailrev1,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[app2,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qrev2,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>qrev(qrev(l,M21(v2)),nil)=qrev(Var1085(l,v2),l)in pnat list)
|||==>v2:pnat list=>qrev(qrev(l,``v0::{M21(\v2/)}''<in>),nil)=qrev(``v0::{Var1085(l,\v2/)}''<in>,l)in pnat list
[v0:pnat,l:pnat list,v1:ih(v2:pnat list=>qrev(qrev(l,v2),nil)=qrev(v2,l)in pnat list)]==>v2:pnat list=>qrev(qrev(l,v0::v2),nil)=qrev(v0::v2,l)in pnat list
|||TERMINATING METHOD at depth 3: fertilize(strong(v1))
|lemma1([1])
|l:pnat list
|==>v2:pnat list=>qrev(qrev(nil,v2),nil)=qrev(v2,nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([1,1,1],qrev1)
||lemma1([1,1])
||l:pnat list
||==>v2:pnat list=>qrev(v2,nil)=qrev(v2,nil)in pnat list
||TERMINATING METHOD at depth 2: elementary(...)
------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- qrev(qrev(l,v2),nil)=qrev(v2,l)in pnat list

WARNING: generalization requires verifying.

Planning complete for qrevqrevnil1

------------------------------------------------------------
qrevqrevnil1:

[l:pnat list]

|- qrev(qrev(l,nil),nil)=l in pnat list

generalize(lemma1)


PLANNING for qrevqrevnil1 COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for qrev...done
deleting synth(qrev)...done
deleting def(qrev)...done
deleting theorem record for qrev1...done
deleting wave record for qrev1...done
deleting wave record for qrev1...done
deleting func_defeqn record for qrev1...done
deleting wave(qrev1)...done
deleting theorem record for qrev2...done
deleting wave record for qrev2...done
deleting wave record for qrev2...done
deleting func_defeqn record for qrev2...done
deleting wave(qrev2)...done
deleting theorem record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave record for tailrev1...done
deleting wave(tailrev1)...done
CLaM WARNING: synth(rev) not present, so cannot be deleted
deleting def(rev)...done
deleting theorem record for rev1...done
deleting wave record for rev1...done
deleting wave record for rev1...done
deleting func_defeqn record for rev1...done
deleting wave(rev1)...done
deleting theorem record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting wave record for rev2...done
deleting func_defeqn record for rev2...done
deleting wave(rev2)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for qrevqrevnil1...done
deleting thm(qrevqrevnil1)...done
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading synth(rotate)...done
loading def(rotate)...done
loading eqn(rotate1)...done
loading eqn(rotate2)...done
loading eqn(rotate3)...done
 adding wave-rules for rotate1:..done
 adding wave-rules for rotate2:..done
 adding wave-rules for rotate3:...........done
 adding defeqn-record for rotate1...done 
 adding defeqn-record for rotate2...done 
 adding defeqn-record for rotate3...done 
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading thm(assapp)...done
 adding wave-rules for assapp:........done
loading thm(assconsapp)...done
 adding wave-rules for assconsapp:.....done
loading thm(rotlen)...done
rotlen([])
==>l:pnat list=>rotate(length(l),l)=l in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|rotlen([2])
|v0:pnat
|l:pnat list
|v1:ih(rotate(length(l),l)=l in pnat list)
|==>rotate(length(``v0::{l}''<out>),``v0::{l}''<out>)=``v0::{l}''<out>in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[length2,equ(left)])
||rotlen([1,2])
||v0:pnat
||l:pnat list
||v1:ih(rotate(length(l),l)=l in pnat list)
||==>rotate(``s({length(l)})''<out>,``v0::{l}''<out>)=``v0::{l}''<out>in pnat list

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>l:pnat list=>v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list)
|==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=M24(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[length2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list)
||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=M24(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(l,Var1155(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=``v0::{app(l,Var1155(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1161(l,v2)))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,Var1161(l,\v2/))}''<out>)=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[rotate3,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(Var1165(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=app(``app({Var1165(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1169(l,v2),l))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(``app({Var1169(l,\v2/)},v0::nil)''<in>,l))=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[app2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(l,Var1135(l,v2))in pnat list)
||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=``v0::{app(l,Var1135(l,\v2/))}''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(l,Var1135(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=``v0::{app(l,Var1135(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1227(l,v2)))=app(l,Var1135(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),``v0::{app(l,Var1227(l,\v2/))}''<out>)=``v0::{app(l,Var1135(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1231(l,v2),l))=app(l,Var1135(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(``app({Var1231(l,\v2/)},v0::nil)''<in>,l))=``v0::{app(l,Var1135(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1,1],[app2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1141(l,v2)))=M24(l,v2)in pnat list)
||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),``v0::{app(l,Var1141(l,\v2/))}''<out>)=M24(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1141(l,v2)))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,Var1141(l,\v2/))}''<out>)=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[rotate3,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1141(l,v2)))=app(l,Var1253(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),``v0::{app(l,Var1141(l,\v2/))}''<out>)=``v0::{app(l,Var1253(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1141(l,v2)))=app(Var1257(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),``v0::{app(l,Var1141(l,\v2/))}''<out>)=app(``app({Var1257(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[assconsapp,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(Var1145(l,v2),l)in pnat list)
||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=app(``app({Var1145(l,\v2/)},v0::nil)''<in>,l)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(Var1145(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=app(``app({Var1145(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1279(l,v2)))=app(Var1145(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),``v0::{app(l,Var1279(l,\v2/))}''<out>)=app(``app({Var1145(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1],[assapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(app(Var1283(l,v2),Var1284(l,v2)),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=app(app(Var1283(l,\v2/),``app({Var1284(l,\v2/)},v0::nil)''<in>),l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(Var1285(l,v2)::Var1286(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=app(Var1285(l,\v2/)::``app({Var1286(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1289(l,v2),l))=app(Var1145(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(``app({Var1289(l,\v2/)},v0::nil)''<in>,l))=app(``app({Var1145(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1,1],[assconsapp,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),app(Var1149(l,v2),l))=M24(l,v2)in pnat list)
||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(``app({Var1149(l,\v2/)},v0::nil)''<in>,l))=M24(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([1,1,1],[length2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1149(l,v2),l))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(``app({Var1149(l,\v2/)},v0::nil)''<in>,l))=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1149(l,v2),l))=app(l,Var1361(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(``app({Var1149(l,\v2/)},v0::nil)''<in>,l))=``v0::{app(l,Var1361(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1,1],[assapp,equ(right)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(app(Var1365(l,v2),Var1366(l,v2)),l))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(app(Var1365(l,\v2/),``app({Var1366(l,\v2/)},v0::nil)''<in>),l))=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,2,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1367(l,v2)::Var1368(l,v2),l))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(Var1367(l,\v2/)::``app({Var1368(l,\v2/)},v0::nil)''<in>,l))=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assconsapp,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(Var1149(l,v2),l))=app(Var1371(l,v2),l)in pnat list)
|||==>v2:pnat list=>rotate(length(``v0::{l}''<out>),app(``app({Var1149(l,\v2/)},v0::nil)''<in>,l))=app(``app({Var1371(l,\v2/)},v0::nil)''<in>,l)in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,1],[length2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,1,1],[app2,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>l:pnat list=>v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|lemma1([2])
|v0:pnat
|l:pnat list
|v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list)
|==>v2:pnat list=>rotate(length(``v0::{l}''<out>),M23(``v0::{l}''<out>,\v2/))=M24(``v0::{l}''<out>,\v2/)in pnat list
|SELECTED METHOD at depth 1: wave([1,1,1],[length2,equ(left)])
||lemma1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=M24(l,v2)in pnat list)
||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=M24(``v0::{l}''<out>,\v2/)in pnat list
||SELECTED METHOD at depth 2: wave([2,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),M23(l,v2))=app(l,Var1463(l,v2))in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,M23(``v0::{l}''<out>,\v2/))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([2,1,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1483(l,v2)))=app(l,Var1463(l,v2))in pnat list)
||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,Var1483(l,\v2/))}''<out>)=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[rotate3,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1483(l,v2)))=app(l,Var1463(l,v2))in pnat list)
|||||==>v2:pnat list=>rotate(length(l),``app({app(l,Var1483(l,\v2/))},v0::nil)''<in>)=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1483(l,v2)))=app(l,Var1463(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,``app({Var1483(l,\v2/)},v0::nil)''<in>))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1,1],[assconsapp,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rotate(length(l),app(Var1487(l,v2),l))=app(l,Var1463(l,v2))in pnat list)
||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(``app({Var1487(l,\v2/)},v0::nil)''<in>,l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,2,1,1],[assapp,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rotate(length(l),app(app(Var1497(l,v2),Var1498(l,v2)),l))=app(l,Var1463(l,v2))in pnat list)
|||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(app(Var1497(l,\v2/),``app({Var1498(l,\v2/)},v0::nil)''<in>),l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1,2,1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(app(Var1497(l,v2),app(Var1503(l,v2),Var1504(l,v2))),l))=app(l,Var1463(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(app(Var1497(l,\v2/),app(Var1503(l,\v2/),``app({Var1504(l,\v2/)},v0::nil)''<in>)),l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,2,1,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(app(Var1497(l,v2),Var1505(l,v2)::Var1506(l,v2)),l))=app(l,Var1463(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(app(Var1497(l,\v2/),Var1505(l,\v2/)::``app({Var1506(l,\v2/)},v0::nil)''<in>),l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,2,1,1],[app2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rotate(length(l),app(Var1499(l,v2)::Var1500(l,v2),l))=app(l,Var1463(l,v2))in pnat list)
|||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(Var1499(l,\v2/)::``app({Var1500(l,\v2/)},v0::nil)''<in>,l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1,2,1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(Var1499(l,v2)::app(Var1521(l,v2),Var1522(l,v2)),l))=app(l,Var1463(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(Var1499(l,\v2/)::app(Var1521(l,\v2/),``app({Var1522(l,\v2/)},v0::nil)''<in>),l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,2,1,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(Var1499(l,v2)::Var1523(l,v2)::Var1524(l,v2),l))=app(l,Var1463(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,app(Var1499(l,\v2/)::Var1523(l,\v2/)::``app({Var1524(l,\v2/)},v0::nil)''<in>,l))=``v0::{app(l,Var1463(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,2,1,1],[app2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1,1],[app2,equ(left)])
|||lemma1([1,1,2])
|||v0:pnat
|||l:pnat list
|||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=M24(l,v2)in pnat list)
|||==>v2:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,Var1469(l,\v2/))}''<out>)=M24(``v0::{l}''<out>,\v2/)in pnat list
|||SELECTED METHOD at depth 3: wave([2,1],[app2,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=app(l,Var1541(l,v2))in pnat list)
||||==>v2:pnat list=>rotate(``s({length(l)})''<out>,``v0::{app(l,Var1469(l,\v2/))}''<out>)=``v0::{app(l,Var1541(l,\v2/))}''<out>in pnat list
||||SELECTED METHOD at depth 4: wave([1,1],[rotate3,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=app(l,Var1541(l,v2))in pnat list)
|||||==>v2:pnat list=>rotate(length(l),``app({app(l,Var1469(l,\v2/))},v0::nil)''<in>)=``v0::{app(l,Var1541(l,\v2/))}''<out>in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=app(l,Var1541(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,``app({Var1469(l,\v2/)},v0::nil)''<in>))=``v0::{app(l,Var1541(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[app2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[rotate3,equ(left)])
||||lemma1([1,1,1,2])
||||v0:pnat
||||l:pnat list
||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=M24(l,v2)in pnat list)
||||==>v2:pnat list=>rotate(length(l),``app({app(l,Var1469(l,\v2/))},v0::nil)''<in>)=M24(``v0::{l}''<out>,\v2/)in pnat list
||||SELECTED METHOD at depth 4: wave([2,1,1],[assapp,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=M24(l,v2)in pnat list)
|||||==>v2:pnat list=>rotate(length(l),app(l,``app({Var1469(l,\v2/)},v0::nil)''<in>))=M24(``v0::{l}''<out>,\v2/)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=app(l,Var1567(l,v2))in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,``app({Var1469(l,\v2/)},v0::nil)''<in>))=``v0::{app(l,Var1567(l,\v2/))}''<out>in pnat list
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,2,1,1],[assapp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,app(Var1571(l,v2),Var1572(l,v2))))=M24(l,v2)in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,app(Var1571(l,\v2/),``app({Var1572(l,\v2/)},v0::nil)''<in>)))=M24(``v0::{l}''<out>,\v2/)in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,2,1,1],[app2,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1573(l,v2)::Var1574(l,v2)))=M24(l,v2)in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,Var1573(l,\v2/)::``app({Var1574(l,\v2/)},v0::nil)''<in>))=M24(``v0::{l}''<out>,\v2/)in pnat list
||||||SELECTED METHOD at depth 6: wave([2,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,2,1,1],[assapp,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,2,2,1,1],[app2,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1],[assconsapp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1],[assconsapp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(v2:pnat list=>rotate(length(l),app(l,Var1469(l,v2)))=app(Var1577(l,v2),l)in pnat list)
||||||==>v2:pnat list=>rotate(length(l),app(l,``app({Var1469(l,\v2/)},v0::nil)''<in>))=app(``app({Var1577(l,\v2/)},v0::nil)''<in>,l)in pnat list
[v0:pnat,l:pnat list,v1:ih(v2:pnat list=>rotate(length(l),app(l,v2))=app(v2,l)in pnat list)]==>v2:pnat list=>rotate(length(l),app(l,app(v2,v0::nil)))=app(app(v2,v0::nil),l)in pnat list
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
|lemma1([1])
|l:pnat list
|==>v2:pnat list=>rotate(length(nil),app(nil,v2))=app(v2,nil)in pnat list
|SELECTED METHOD at depth 1: eval_def([2,1,1],app1)
||lemma1([1,1])
||l:pnat list
||==>v2:pnat list=>rotate(length(nil),v2)=app(v2,nil)in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1,1],length1)
|||lemma1([1,1,1])
|||l:pnat list
|||==>v2:pnat list=>rotate(0,v2)=app(v2,nil)in pnat list
|||SELECTED METHOD at depth 3: eval_def([1,1],rotate1)
||||lemma1([1,1,1,1])
||||l:pnat list
||||==>v2:pnat list=>v2=app(v2,nil)in pnat list
||||SELECTED METHOD at depth 4: induction([v0::v2],[v2:pnat list])
|||||lemma1([2,1,1,1,1])
|||||v0:pnat
|||||v2:pnat list
|||||v1:ih(v2=app(v2,nil)in pnat list)
|||||l:pnat list
|||||==>``v0::{v2}''<out> =app(``v0::{v2}''<out>,nil)in pnat list
|||||SELECTED METHOD at depth 5: wave([2,1],[app2,equ(left)])
||||||lemma1([1,2,1,1,1,1])
||||||v0:pnat
||||||v2:pnat list
||||||v1:ih(v2=app(v2,nil)in pnat list)
||||||l:pnat list
||||||==>``v0::{v2}''<out> =``v0::{app(v2,nil)}''<out>in pnat list
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||lemma1([1,1,2,1,1,1,1])
|||||||v0:pnat
|||||||v2:pnat list
|||||||v1:ih(v2=app(v2,nil)in pnat list)
|||||||l:pnat list
|||||||==>v0::v2=v0::v2 in pnat list
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||||lemma1([1,1,1,1,1])
|||||v2:pnat list
|||||l:pnat list
|||||==>nil=app(nil,nil)in pnat list
|||||SELECTED METHOD at depth 5: eval_def([2,1],app1)
||||||lemma1([1,1,1,1,1,1])
||||||v2:pnat list
||||||l:pnat list
||||||==>nil=nil in pnat list
||||||TERMINATING METHOD at depth 6: elementary(...)
------------------------------------------------------------
lemma1:

[l:pnat list,v2:pnat list]

|- rotate(length(l),app(l,v2))=app(v2,l)in pnat list

WARNING: generalization requires verifying.

Planning complete for rotlen

------------------------------------------------------------
rotlen:

[l:pnat list]

|- rotate(length(l),l)=l in pnat list

generalize(lemma1)


PLANNING for rotlen COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for rotate...done
deleting synth(rotate)...done
deleting def(rotate)...done
deleting theorem record for rotate1...done
deleting wave record for rotate1...done
deleting wave record for rotate1...done
deleting func_defeqn record for rotate1...done
deleting wave(rotate1)...done
deleting theorem record for rotate2...done
deleting wave record for rotate2...done
deleting wave record for rotate2...done
deleting func_defeqn record for rotate2...done
deleting wave(rotate2)...done
deleting theorem record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting wave record for rotate3...done
deleting func_defeqn record for rotate3...done
deleting wave(rotate3)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
deleting theorem record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave record for assapp...done
deleting wave(assapp)...done
deleting theorem record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave record for assconsapp...done
deleting wave(assconsapp)...done
deleting theorem record for rotlen...done
deleting thm(rotlen)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading def(times)...done
loading eqn(times1)...done
loading eqn(times2)...done
 adding wave-rules for times1:..done
 adding wave-rules for times2:......................done
 adding defeqn-record for times1...done 
 adding defeqn-record for times2...done 
loading synth(fac)...done
loading def(fac)...done
loading eqn(fac1)...done
loading eqn(fac2)...done
 adding wave-rules for fac1:..done
 adding wave-rules for fac2:...............done
 adding defeqn-record for fac1...done 
 adding defeqn-record for fac2...done 
loading def(qfac)...done
loading eqn(qfac1)...done
loading eqn(qfac2)...done
 adding wave-rules for qfac1:..done
 adding wave-rules for qfac2:..done
 adding defeqn-record for qfac1...done 
 adding defeqn-record for qfac2...done 
loading thm(assm)...done
 adding wave-rules for assm:........done
loading thm(facqfac)...done
facqfac([])
==>x:pnat=>fac(x)=qfac(x,s(0))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|facqfac([2])
|x:pnat
|v0:ih(fac(x)=qfac(x,s(0))in pnat)
|==>fac(``s({x})''<out>)=qfac(``s({x})''<out>,s(0))in pnat
|SELECTED METHOD at depth 1: wave([1,1],[fac2,equ(left)])
||facqfac([1,2])
||x:pnat
||v0:ih(fac(x)=qfac(x,s(0))in pnat)
||==>``times({fac(x)},s(x))''<out> =qfac(``s({x})''<out>,s(0))in pnat

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat]

|- M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>v1:pnat=>x:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
|==>v1:pnat=>M25(fac(``s({x})''<out>),\v1/)=qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[fac2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>times(Var1619(fac(x),v1),fac(x))=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>``times({times(Var1619(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[qfac2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qfac2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(right)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>times(fac(x),Var1626(fac(x),v1))=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>times(fac(x),``times(s(x),{Var1626(fac(x),\v1/)})''<in>)=qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qfac2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[qfac2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
||==>v1:pnat=>M25(fac(``s({x})''<out>),\v1/)=qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[fac2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,2,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,times(Var1651(s(0),v1),Var1652(s(0),v1)))in pnat)
|||==>v1:pnat=>M25(fac(``s({x})''<out>),\v1/)=qfac(x,times(``times(s(x),{Var1651(s(0),\v1/)})''<in>,Var1652(s(0),\v1/)))in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[fac2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,2,2,1],[assm,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>v1:pnat=>x:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
|==>v1:pnat=>M25(fac(``s({x})''<out>),\v1/)=qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[fac2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>times(Var1675(fac(x),v1),fac(x))=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>``times({times(Var1675(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(``s({x})''<out>,M26(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[qfac2,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>times(Var1675(fac(x),v1),fac(x))=qfac(x,M26(s(0),v1))in pnat)
||||==>v1:pnat=>``times({times(Var1675(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([2,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>times(Var1675(fac(x),v1),fac(x))=qfac(x,times(Var1687(s(0),v1),Var1688(s(0),v1)))in pnat)
|||||==>v1:pnat=>``times({times(Var1675(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(``times(s(x),{Var1687(s(0),\v1/)})''<in>,Var1688(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(Var1675(fac(x),v1),fac(x))=qfac(x,times(times(Var1691(s(0),v1),Var1692(s(0),v1)),Var1688(s(0),v1)))in pnat)
||||||==>v1:pnat=>``times({times(Var1675(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(times(``times(s(x),{Var1691(s(0),\v1/)})''<in>,Var1692(s(0),\v1/)),Var1688(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qfac2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,M26(s(0),v1))in pnat)
|||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>times(Var1699(fac(x),v1),fac(x))=qfac(x,M26(s(0),v1))in pnat)
||||==>v1:pnat=>``times({times(Var1699(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([2,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>times(Var1699(fac(x),v1),fac(x))=qfac(x,times(Var1715(s(0),v1),Var1716(s(0),v1)))in pnat)
|||||==>v1:pnat=>``times({times(Var1699(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(``times(s(x),{Var1715(s(0),\v1/)})''<in>,Var1716(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(Var1699(fac(x),v1),fac(x))=qfac(x,times(times(Var1719(s(0),v1),Var1720(s(0),v1)),Var1716(s(0),v1)))in pnat)
||||||==>v1:pnat=>``times({times(Var1699(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(times(``times(s(x),{Var1719(s(0),\v1/)})''<in>,Var1720(s(0),\v1/)),Var1716(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,2,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,times(Var1705(s(0),v1),Var1706(s(0),v1)))in pnat)
||||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,times(``times(s(x),{Var1705(s(0),\v1/)})''<in>,Var1706(s(0),\v1/)))in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>times(Var1727(fac(x),v1),fac(x))=qfac(x,times(Var1705(s(0),v1),Var1706(s(0),v1)))in pnat)
|||||==>v1:pnat=>``times({times(Var1727(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(``times(s(x),{Var1705(s(0),\v1/)})''<in>,Var1706(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(Var1727(fac(x),v1),fac(x))=qfac(x,times(times(Var1743(s(0),v1),Var1744(s(0),v1)),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>``times({times(Var1727(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(times(``times(s(x),{Var1743(s(0),\v1/)})''<in>,Var1744(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,2,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,times(times(Var1733(s(0),v1),Var1734(s(0),v1)),Var1706(s(0),v1)))in pnat)
|||||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,times(times(``times(s(x),{Var1733(s(0),\v1/)})''<in>,Var1734(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(Var1751(fac(x),v1),fac(x))=qfac(x,times(times(Var1733(s(0),v1),Var1734(s(0),v1)),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>``times({times(Var1751(fac(x),\v1/),fac(x))},s(x))''<out> =qfac(x,times(times(``times(s(x),{Var1733(s(0),\v1/)})''<in>,Var1734(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1,2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>M25(fac(x),v1)=qfac(x,times(times(times(Var1757(s(0),v1),Var1758(s(0),v1)),Var1734(s(0),v1)),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>M25(``times({fac(x)},s(x))''<out>,\v1/)=qfac(x,times(times(times(``times(s(x),{Var1757(s(0),\v1/)})''<in>,Var1758(s(0),\v1/)),Var1734(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assm,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assm,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(fac(x),Var1762(fac(x),v1))=qfac(x,times(times(Var1733(s(0),v1),Var1734(s(0),v1)),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>times(fac(x),``times(s(x),{Var1762(fac(x),\v1/)})''<in>)=qfac(x,times(times(``times(s(x),{Var1733(s(0),\v1/)})''<in>,Var1734(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assm,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>times(fac(x),Var1738(fac(x),v1))=qfac(x,times(Var1705(s(0),v1),Var1706(s(0),v1)))in pnat)
|||||==>v1:pnat=>times(fac(x),``times(s(x),{Var1738(fac(x),\v1/)})''<in>)=qfac(x,times(``times(s(x),{Var1705(s(0),\v1/)})''<in>,Var1706(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(fac(x),Var1738(fac(x),v1))=qfac(x,times(times(Var1795(s(0),v1),Var1796(s(0),v1)),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>times(fac(x),``times(s(x),{Var1738(fac(x),\v1/)})''<in>)=qfac(x,times(times(``times(s(x),{Var1795(s(0),\v1/)})''<in>,Var1796(s(0),\v1/)),Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>times(fac(x),times(Var1799(fac(x),v1),Var1800(fac(x),v1)))=qfac(x,times(Var1705(s(0),v1),Var1706(s(0),v1)))in pnat)
||||||==>v1:pnat=>times(fac(x),times(``times(s(x),{Var1799(fac(x),\v1/)})''<in>,Var1800(fac(x),\v1/)))=qfac(x,times(``times(s(x),{Var1705(s(0),\v1/)})''<in>,Var1706(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>times(fac(x),Var1710(fac(x),v1))=qfac(x,M26(s(0),v1))in pnat)
||||==>v1:pnat=>times(fac(x),``times(s(x),{Var1710(fac(x),\v1/)})''<in>)=qfac(x,``times(s(x),{M26(s(0),\v1/)})''<in>)in pnat
[x:pnat,v0:ih(v1:pnat=>times(fac(x),v1)=qfac(x,v1)in pnat)]==>v1:pnat=>times(fac(x),times(s(x),v1))=qfac(x,times(s(x),v1))in pnat
||||TERMINATING METHOD at depth 4: fertilize(strong(v0))
|lemma1([1])
|x:pnat
|==>v1:pnat=>times(fac(0),v1)=qfac(0,v1)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],qfac1)
||lemma1([1,1])
||x:pnat
||==>v1:pnat=>times(fac(0),v1)=v1 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],fac1)
|||lemma1([1,1,1])
|||x:pnat
|||==>v1:pnat=>times(s(0),v1)=v1 in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],times2)
||||lemma1([1,1,1,1])
||||x:pnat
||||==>v1:pnat=>plus(times(0,v1),v1)=v1 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],times1)
|||||lemma1([1,1,1,1,1])
|||||x:pnat
|||||==>v1:pnat=>plus(0,v1)=v1 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],plus1)
||||||lemma1([1,1,1,1,1,1])
||||||x:pnat
||||||==>v1:pnat=>v1=v1 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat]

|- times(fac(x),v1)=qfac(x,v1)in pnat

WARNING: generalization requires verifying.

Planning complete for facqfac

------------------------------------------------------------
facqfac:

[x:pnat]

|- fac(x)=qfac(x,s(0))in pnat

generalize(lemma1)


PLANNING for facqfac COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for fac...done
deleting synth(fac)...done
deleting def(fac)...done
deleting theorem record for fac1...done
deleting wave record for fac1...done
deleting wave record for fac1...done
deleting func_defeqn record for fac1...done
deleting wave(fac1)...done
deleting theorem record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting func_defeqn record for fac2...done
deleting wave(fac2)...done
CLaM WARNING: synth(times) not present, so cannot be deleted
deleting def(times)...done
deleting theorem record for times1...done
deleting wave record for times1...done
deleting wave record for times1...done
deleting func_defeqn record for times1...done
deleting wave(times1)...done
deleting theorem record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting func_defeqn record for times2...done
deleting wave(times2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
CLaM WARNING: synth(qfac) not present, so cannot be deleted
deleting def(qfac)...done
deleting theorem record for qfac1...done
deleting wave record for qfac1...done
deleting wave record for qfac1...done
deleting func_defeqn record for qfac1...done
deleting wave(qfac1)...done
deleting theorem record for qfac2...done
deleting wave record for qfac2...done
deleting wave record for qfac2...done
deleting func_defeqn record for qfac2...done
deleting wave(qfac2)...done
deleting theorem record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave(assm)...done
deleting theorem record for facqfac...done
deleting thm(facqfac)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading def(times)...done
loading eqn(times1)...done
loading eqn(times2)...done
 adding wave-rules for times1:..done
 adding wave-rules for times2:......................done
 adding defeqn-record for times1...done 
 adding defeqn-record for times2...done 
loading def(mult)...done
loading eqn(mult1)...done
loading eqn(mult2)...done
 adding wave-rules for mult1:..done
 adding wave-rules for mult2:..done
 adding defeqn-record for mult1...done 
 adding defeqn-record for mult2...done 
loading thm(assp)...done
 adding wave-rules for assp:........done
loading thm(timesmult)...done
timesmult([])
==>x:pnat=>y:pnat=>times(x,y)=mult(x,y,0)in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|timesmult([2])
|x:pnat
|v0:ih(y:pnat=>times(x,y)=mult(x,y,0)in pnat)
|==>y:pnat=>times(``s({x})''<out>,\y/)=mult(``s({x})''<out>,\y/,0)in pnat
|SELECTED METHOD at depth 1: wave([1,1],[times2,equ(left)])
||timesmult([1,2])
||x:pnat
||v0:ih(y:pnat=>times(x,y)=mult(x,y,0)in pnat)
||==>y:pnat=>``plus({times(x,\y/)},\y/)''<out> =mult(``s({x})''<out>,\y/,0)in pnat

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat,y:pnat]

|- M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>v1:pnat=>x:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
|==>v1:pnat=>y:pnat=>M27(times(``s({x})''<out>,\y/),\v1/)=mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[times2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assp,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>plus(Var1819(times(x,y),v1),times(x,y))=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>``plus({plus(Var1819(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[mult2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[mult2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[plus2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[plus2,equ(right)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[mult2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assp,equ(right)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),Var1834(times(x,y),v1))=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>plus(times(x,\y/),``plus(\y/,{Var1834(times(x,\y/),\v1/)})''<in>)=mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[mult2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[mult2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
||==>v1:pnat=>y:pnat=>M27(times(``s({x})''<out>,\y/),\v1/)=mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[times2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[plus2,equ(right)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([3,2,1],[assp,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,plus(Var1875(v1),Var1876(v1)))in pnat)
|||==>v1:pnat=>y:pnat=>M27(times(``s({x})''<out>,\y/),\v1/)=mult(x,\y/,plus(``plus(\y/,{Var1875(\v1/)})''<in>,Var1876(\v1/)))in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[times2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,3,2,1],[assp,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>v1:pnat=>x:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat
SELECTED METHOD at depth 0: induction([s(x)],[x:pnat])
|lemma1([2])
|x:pnat
|v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
|==>v1:pnat=>y:pnat=>M27(times(``s({x})''<out>,\y/),\v1/)=mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[times2,equ(left)])
||lemma1([1,2])
||x:pnat
||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assp,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>plus(Var1911(times(x,y),v1),times(x,y))=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>``plus({plus(Var1911(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(``s({x})''<out>,\y/,M28(\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[mult2,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>y:pnat=>plus(Var1911(times(x,y),v1),times(x,y))=mult(x,y,M28(v1))in pnat)
||||==>v1:pnat=>y:pnat=>``plus({plus(Var1911(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([3,2,1],[assp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>plus(Var1911(times(x,y),v1),times(x,y))=mult(x,y,plus(Var1935(v1),Var1936(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>``plus({plus(Var1911(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(``plus(\y/,{Var1935(\v1/)})''<in>,Var1936(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(Var1911(times(x,y),v1),times(x,y))=mult(x,y,plus(plus(Var1939(v1),Var1940(v1)),Var1936(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({plus(Var1911(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var1939(\v1/)})''<in>,Var1940(\v1/)),Var1936(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[mult2,equ(left)])
|||lemma1([1,1,2])
|||x:pnat
|||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,M28(v1))in pnat)
|||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assp,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,plus(Var1947(v1),Var1948(v1)))in pnat)
||||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,plus(``plus(\y/,{Var1947(\v1/)})''<in>,Var1948(\v1/)))in pnat
||||SELECTED METHOD at depth 4: wave([1,3,2,1],[assp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,plus(plus(Var1975(v1),Var1976(v1)),Var1948(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,plus(plus(``plus(\y/,{Var1975(\v1/)})''<in>,Var1976(\v1/)),Var1948(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>M27(times(x,y),v1)=mult(x,y,plus(plus(plus(Var2003(v1),Var2004(v1)),Var1976(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>M27(``plus({times(x,\y/)},\y/)''<out>,\v1/)=mult(x,\y/,plus(plus(plus(``plus(\y/,{Var2003(\v1/)})''<in>,Var2004(\v1/)),Var1976(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[plus2,equ(right)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assp,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(Var2007(times(x,y),v1),times(x,y))=mult(x,y,plus(plus(Var1975(v1),Var1976(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({plus(Var2007(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var1975(\v1/)})''<in>,Var1976(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[plus2,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,plus(plus(Var1975(v1),Var1976(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var1975(\v1/)})''<in>,Var1976(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assp,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),Var2022(times(x,y),v1))=mult(x,y,plus(plus(Var1975(v1),Var1976(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>plus(times(x,\y/),``plus(\y/,{Var2022(times(x,\y/),\v1/)})''<in>)=mult(x,\y/,plus(plus(``plus(\y/,{Var1975(\v1/)})''<in>,Var1976(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>plus(Var1979(times(x,y),v1),times(x,y))=mult(x,y,plus(Var1947(v1),Var1948(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>``plus({plus(Var1979(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(``plus(\y/,{Var1947(\v1/)})''<in>,Var1948(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(Var1979(times(x,y),v1),times(x,y))=mult(x,y,plus(plus(Var2075(v1),Var2076(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({plus(Var1979(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var2075(\v1/)})''<in>,Var2076(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[plus2,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,plus(Var1947(v1),Var1948(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(``plus(\y/,{Var1947(\v1/)})''<in>,Var1948(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,plus(plus(Var2083(v1),Var2084(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var2083(\v1/)})''<in>,Var2084(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assp,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),Var1994(times(x,y),v1))=mult(x,y,plus(Var1947(v1),Var1948(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>plus(times(x,\y/),``plus(\y/,{Var1994(times(x,\y/),\v1/)})''<in>)=mult(x,\y/,plus(``plus(\y/,{Var1947(\v1/)})''<in>,Var1948(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),Var1994(times(x,y),v1))=mult(x,y,plus(plus(Var2091(v1),Var2092(v1)),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>plus(times(x,\y/),``plus(\y/,{Var1994(times(x,\y/),\v1/)})''<in>)=mult(x,\y/,plus(plus(``plus(\y/,{Var2091(\v1/)})''<in>,Var2092(\v1/)),Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assp,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),plus(Var2095(times(x,y),v1),Var2096(times(x,y),v1)))=mult(x,y,plus(Var1947(v1),Var1948(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>plus(times(x,\y/),plus(``plus(\y/,{Var2095(times(x,\y/),\v1/)})''<in>,Var2096(times(x,\y/),\v1/)))=mult(x,\y/,plus(``plus(\y/,{Var1947(\v1/)})''<in>,Var1948(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(left)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>y:pnat=>plus(Var1951(times(x,y),v1),times(x,y))=mult(x,y,M28(v1))in pnat)
||||==>v1:pnat=>y:pnat=>``plus({plus(Var1951(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([3,2,1],[assp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>plus(Var1951(times(x,y),v1),times(x,y))=mult(x,y,plus(Var2115(v1),Var2116(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>``plus({plus(Var1951(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(``plus(\y/,{Var2115(\v1/)})''<in>,Var2116(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>plus(Var1951(times(x,y),v1),times(x,y))=mult(x,y,plus(plus(Var2119(v1),Var2120(v1)),Var2116(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({plus(Var1951(times(x,\y/),\v1/),times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var2119(\v1/)})''<in>,Var2120(\v1/)),Var2116(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[plus2,equ(right)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,M28(v1))in pnat)
||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([3,2,1],[assp,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||x:pnat
|||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,plus(Var2127(v1),Var2128(v1)))in pnat)
|||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(``plus(\y/,{Var2127(\v1/)})''<in>,Var2128(\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assp,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||x:pnat
||||||v0:ih(v1:pnat=>y:pnat=>s(times(x,y))=mult(x,y,plus(plus(Var2131(v1),Var2132(v1)),Var2128(v1)))in pnat)
||||||==>v1:pnat=>y:pnat=>``plus({s(times(x,\y/))},\y/)''<out> =mult(x,\y/,plus(plus(``plus(\y/,{Var2131(\v1/)})''<in>,Var2132(\v1/)),Var2128(\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assp,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assp,equ(right)])
||||lemma1([1,1,1,2])
||||x:pnat
||||v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),Var1966(times(x,y),v1))=mult(x,y,M28(v1))in pnat)
||||==>v1:pnat=>y:pnat=>plus(times(x,\y/),``plus(\y/,{Var1966(times(x,\y/),\v1/)})''<in>)=mult(x,\y/,``plus(\y/,{M28(\v1/)})''<in>)in pnat
[x:pnat,v0:ih(v1:pnat=>y:pnat=>plus(times(x,y),v1)=mult(x,y,v1)in pnat)]==>v1:pnat=>y:pnat=>plus(times(x,y),plus(y,v1))=mult(x,y,plus(y,v1))in pnat
||||TERMINATING METHOD at depth 4: fertilize(strong(v0))
|lemma1([1])
|x:pnat
|==>v1:pnat=>y:pnat=>plus(times(0,y),v1)=mult(0,y,v1)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],mult1)
||lemma1([1,1])
||x:pnat
||==>v1:pnat=>y:pnat=>plus(times(0,y),v1)=v1 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],times1)
|||lemma1([1,1,1])
|||x:pnat
|||==>v1:pnat=>y:pnat=>plus(0,v1)=v1 in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],plus1)
||||lemma1([1,1,1,1])
||||x:pnat
||||==>v1:pnat=>y:pnat=>v1=v1 in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat,y:pnat]

|- plus(times(x,y),v1)=mult(x,y,v1)in pnat

WARNING: generalization requires verifying.

Planning complete for timesmult

------------------------------------------------------------
timesmult:

[x:pnat,y:pnat]

|- times(x,y)=mult(x,y,0)in pnat

generalize(lemma1)


PLANNING for timesmult COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(times) not present, so cannot be deleted
deleting def(times)...done
deleting theorem record for times1...done
deleting wave record for times1...done
deleting wave record for times1...done
deleting func_defeqn record for times1...done
deleting wave(times1)...done
deleting theorem record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting func_defeqn record for times2...done
deleting wave(times2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
CLaM WARNING: synth(mult) not present, so cannot be deleted
deleting def(mult)...done
deleting theorem record for mult1...done
deleting wave record for mult1...done
deleting wave record for mult1...done
deleting func_defeqn record for mult1...done
deleting wave(mult1)...done
deleting theorem record for mult2...done
deleting wave record for mult2...done
deleting wave record for mult2...done
deleting func_defeqn record for mult2...done
deleting wave(mult2)...done
deleting theorem record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave record for assp...done
deleting wave(assp)...done
deleting theorem record for timesmult...done
deleting thm(timesmult)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading def(times)...done
loading eqn(times1)...done
loading eqn(times2)...done
 adding wave-rules for times1:..done
 adding wave-rules for times2:......................done
 adding defeqn-record for times1...done 
 adding defeqn-record for times2...done 
loading def(exp)...done
loading eqn(exp1)...done
loading eqn(exp2)...done
 adding wave-rules for exp1:..done
 adding wave-rules for exp2:......................done
 adding defeqn-record for exp1...done 
 adding defeqn-record for exp2...done 
loading def(qexp)...done
loading eqn(qexp1)...done
loading eqn(qexp2)...done
 adding wave-rules for qexp1:..done
 adding wave-rules for qexp2:..done
 adding defeqn-record for qexp1...done 
 adding defeqn-record for qexp2...done 
loading thm(assm)...done
 adding wave-rules for assm:........done
loading thm(expqexp)...done
expqexp([])
==>x:pnat=>y:pnat=>exp(x,y)=qexp(x,y,s(0))in pnat
SELECTED METHOD at depth 0: induction([s(y)],[y:pnat])
|expqexp([2])
|y:pnat
|v0:ih(x:pnat=>exp(x,y)=qexp(x,y,s(0))in pnat)
|==>x:pnat=>exp(\x/,``s({y})''<out>)=qexp(\x/,``s({y})''<out>,s(0))in pnat
|SELECTED METHOD at depth 1: wave([1,1],[exp2,equ(left)])
||expqexp([1,2])
||y:pnat
||v0:ih(x:pnat=>exp(x,y)=qexp(x,y,s(0))in pnat)
||==>x:pnat=>``times({exp(\x/,y)},\x/)''<out> =qexp(\x/,``s({y})''<out>,s(0))in pnat

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat,y:pnat]

|- M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>v1:pnat=>x:pnat=>y:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat
SELECTED METHOD at depth 0: induction([s(y)],[y:pnat])
|lemma1([2])
|y:pnat
|v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
|==>v1:pnat=>x:pnat=>M29(exp(\x/,``s({y})''<out>),\v1/)=qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[exp2,equ(left)])
||lemma1([1,2])
||y:pnat
||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>times(Var2139(exp(x,y),v1),exp(x,y))=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>``times({times(Var2139(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[qexp2,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qexp2,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(right)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),Var2150(exp(x,y),v1))=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>times(exp(\x/,y),``times(\x/,{Var2150(exp(\x/,y),\v1/)})''<in>)=qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[qexp2,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([2,1],[qexp2,equ(left)])
||lemma1([1,2])
||y:pnat
||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
||==>v1:pnat=>x:pnat=>M29(exp(\x/,``s({y})''<out>),\v1/)=qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[exp2,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([3,2,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,times(Var2187(s(0),v1),Var2188(s(0),v1)))in pnat)
|||==>v1:pnat=>x:pnat=>M29(exp(\x/,``s({y})''<out>),\v1/)=qexp(\x/,y,times(``times(\x/,{Var2187(s(0),\v1/)})''<in>,Var2188(s(0),\v1/)))in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[exp2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,3,2,1],[assm,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>v1:pnat=>x:pnat=>y:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat
SELECTED METHOD at depth 0: induction([s(y)],[y:pnat])
|lemma1([2])
|y:pnat
|v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
|==>v1:pnat=>x:pnat=>M29(exp(\x/,``s({y})''<out>),\v1/)=qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
|SELECTED METHOD at depth 1: wave([1,1,1],[exp2,equ(left)])
||lemma1([1,2])
||y:pnat
||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
||SELECTED METHOD at depth 2: wave([1,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>times(Var2219(exp(x,y),v1),exp(x,y))=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>``times({times(Var2219(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,``s({y})''<out>,M30(s(0),\v1/))in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[qexp2,equ(left)])
||||lemma1([1,1,1,2])
||||y:pnat
||||v0:ih(v1:pnat=>x:pnat=>times(Var2219(exp(x,y),v1),exp(x,y))=qexp(x,y,M30(s(0),v1))in pnat)
||||==>v1:pnat=>x:pnat=>``times({times(Var2219(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([3,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||y:pnat
|||||v0:ih(v1:pnat=>x:pnat=>times(Var2219(exp(x,y),v1),exp(x,y))=qexp(x,y,times(Var2239(s(0),v1),Var2240(s(0),v1)))in pnat)
|||||==>v1:pnat=>x:pnat=>``times({times(Var2219(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(``times(\x/,{Var2239(s(0),\v1/)})''<in>,Var2240(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(Var2219(exp(x,y),v1),exp(x,y))=qexp(x,y,times(times(Var2243(s(0),v1),Var2244(s(0),v1)),Var2240(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>``times({times(Var2219(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(times(``times(\x/,{Var2243(s(0),\v1/)})''<in>,Var2244(s(0),\v1/)),Var2240(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[qexp2,equ(left)])
|||lemma1([1,1,2])
|||y:pnat
|||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,M30(s(0),v1))in pnat)
|||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([3,2,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||y:pnat
||||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,times(Var2251(s(0),v1),Var2252(s(0),v1)))in pnat)
||||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,times(``times(\x/,{Var2251(s(0),\v1/)})''<in>,Var2252(s(0),\v1/)))in pnat
||||SELECTED METHOD at depth 4: wave([1,3,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||y:pnat
|||||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,times(times(Var2275(s(0),v1),Var2276(s(0),v1)),Var2252(s(0),v1)))in pnat)
|||||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,times(times(``times(\x/,{Var2275(s(0),\v1/)})''<in>,Var2276(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,3,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>M29(exp(x,y),v1)=qexp(x,y,times(times(times(Var2299(s(0),v1),Var2300(s(0),v1)),Var2276(s(0),v1)),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>M29(``times({exp(\x/,y)},\x/)''<out>,\v1/)=qexp(\x/,y,times(times(times(``times(\x/,{Var2299(s(0),\v1/)})''<in>,Var2300(s(0),\v1/)),Var2276(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1],[assm,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(Var2303(exp(x,y),v1),exp(x,y))=qexp(x,y,times(times(Var2275(s(0),v1),Var2276(s(0),v1)),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>``times({times(Var2303(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(times(``times(\x/,{Var2275(s(0),\v1/)})''<in>,Var2276(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1],[assm,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),Var2314(exp(x,y),v1))=qexp(x,y,times(times(Var2275(s(0),v1),Var2276(s(0),v1)),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>times(exp(\x/,y),``times(\x/,{Var2314(exp(\x/,y),\v1/)})''<in>)=qexp(\x/,y,times(times(``times(\x/,{Var2275(s(0),\v1/)})''<in>,Var2276(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||y:pnat
|||||v0:ih(v1:pnat=>x:pnat=>times(Var2279(exp(x,y),v1),exp(x,y))=qexp(x,y,times(Var2251(s(0),v1),Var2252(s(0),v1)))in pnat)
|||||==>v1:pnat=>x:pnat=>``times({times(Var2279(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(``times(\x/,{Var2251(s(0),\v1/)})''<in>,Var2252(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(Var2279(exp(x,y),v1),exp(x,y))=qexp(x,y,times(times(Var2359(s(0),v1),Var2360(s(0),v1)),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>``times({times(Var2279(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(times(``times(\x/,{Var2359(s(0),\v1/)})''<in>,Var2360(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1],[assm,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||y:pnat
|||||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),Var2290(exp(x,y),v1))=qexp(x,y,times(Var2251(s(0),v1),Var2252(s(0),v1)))in pnat)
|||||==>v1:pnat=>x:pnat=>times(exp(\x/,y),``times(\x/,{Var2290(exp(\x/,y),\v1/)})''<in>)=qexp(\x/,y,times(``times(\x/,{Var2251(s(0),\v1/)})''<in>,Var2252(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),Var2290(exp(x,y),v1))=qexp(x,y,times(times(Var2367(s(0),v1),Var2368(s(0),v1)),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>times(exp(\x/,y),``times(\x/,{Var2290(exp(\x/,y),\v1/)})''<in>)=qexp(\x/,y,times(times(``times(\x/,{Var2367(s(0),\v1/)})''<in>,Var2368(s(0),\v1/)),Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),times(Var2371(exp(x,y),v1),Var2372(exp(x,y),v1)))=qexp(x,y,times(Var2251(s(0),v1),Var2252(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>times(exp(\x/,y),times(``times(\x/,{Var2371(exp(\x/,y),\v1/)})''<in>,Var2372(exp(\x/,y),\v1/)))=qexp(\x/,y,times(``times(\x/,{Var2251(s(0),\v1/)})''<in>,Var2252(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,2,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||y:pnat
||||v0:ih(v1:pnat=>x:pnat=>times(Var2255(exp(x,y),v1),exp(x,y))=qexp(x,y,M30(s(0),v1))in pnat)
||||==>v1:pnat=>x:pnat=>``times({times(Var2255(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
||||SELECTED METHOD at depth 4: wave([3,2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||y:pnat
|||||v0:ih(v1:pnat=>x:pnat=>times(Var2255(exp(x,y),v1),exp(x,y))=qexp(x,y,times(Var2391(s(0),v1),Var2392(s(0),v1)))in pnat)
|||||==>v1:pnat=>x:pnat=>``times({times(Var2255(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(``times(\x/,{Var2391(s(0),\v1/)})''<in>,Var2392(s(0),\v1/)))in pnat
|||||SELECTED METHOD at depth 5: wave([1,3,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||y:pnat
||||||v0:ih(v1:pnat=>x:pnat=>times(Var2255(exp(x,y),v1),exp(x,y))=qexp(x,y,times(times(Var2395(s(0),v1),Var2396(s(0),v1)),Var2392(s(0),v1)))in pnat)
||||||==>v1:pnat=>x:pnat=>``times({times(Var2255(exp(\x/,y),\v1/),exp(\x/,y))},\x/)''<out> =qexp(\x/,y,times(times(``times(\x/,{Var2395(s(0),\v1/)})''<in>,Var2396(s(0),\v1/)),Var2392(s(0),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,3,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[assm,equ(right)])
||||lemma1([1,1,1,2])
||||y:pnat
||||v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),Var2266(exp(x,y),v1))=qexp(x,y,M30(s(0),v1))in pnat)
||||==>v1:pnat=>x:pnat=>times(exp(\x/,y),``times(\x/,{Var2266(exp(\x/,y),\v1/)})''<in>)=qexp(\x/,y,``times(\x/,{M30(s(0),\v1/)})''<in>)in pnat
[y:pnat,v0:ih(v1:pnat=>x:pnat=>times(exp(x,y),v1)=qexp(x,y,v1)in pnat)]==>v1:pnat=>x:pnat=>times(exp(x,y),times(x,v1))=qexp(x,y,times(x,v1))in pnat
||||TERMINATING METHOD at depth 4: fertilize(strong(v0))
|lemma1([1])
|y:pnat
|==>v1:pnat=>x:pnat=>times(exp(x,0),v1)=qexp(x,0,v1)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],qexp1)
||lemma1([1,1])
||y:pnat
||==>v1:pnat=>x:pnat=>times(exp(x,0),v1)=v1 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],exp1)
|||lemma1([1,1,1])
|||y:pnat
|||==>v1:pnat=>x:pnat=>times(s(0),v1)=v1 in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],times2)
||||lemma1([1,1,1,1])
||||y:pnat
||||==>v1:pnat=>x:pnat=>plus(times(0,v1),v1)=v1 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],times1)
|||||lemma1([1,1,1,1,1])
|||||y:pnat
|||||==>v1:pnat=>x:pnat=>plus(0,v1)=v1 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],plus1)
||||||lemma1([1,1,1,1,1,1])
||||||y:pnat
||||||==>v1:pnat=>x:pnat=>v1=v1 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
------------------------------------------------------------
lemma1:

[v1:pnat,x:pnat,y:pnat]

|- times(exp(x,y),v1)=qexp(x,y,v1)in pnat

WARNING: generalization requires verifying.

Planning complete for expqexp

------------------------------------------------------------
expqexp:

[x:pnat,y:pnat]

|- exp(x,y)=qexp(x,y,s(0))in pnat

generalize(lemma1)


PLANNING for expqexp COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(exp) not present, so cannot be deleted
deleting def(exp)...done
deleting theorem record for exp1...done
deleting wave record for exp1...done
deleting wave record for exp1...done
deleting func_defeqn record for exp1...done
deleting wave(exp1)...done
deleting theorem record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting wave record for exp2...done
deleting func_defeqn record for exp2...done
deleting wave(exp2)...done
CLaM WARNING: synth(times) not present, so cannot be deleted
deleting def(times)...done
deleting theorem record for times1...done
deleting wave record for times1...done
deleting wave record for times1...done
deleting func_defeqn record for times1...done
deleting wave(times1)...done
deleting theorem record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting func_defeqn record for times2...done
deleting wave(times2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
CLaM WARNING: synth(qexp) not present, so cannot be deleted
deleting def(qexp)...done
deleting theorem record for qexp1...done
deleting wave record for qexp1...done
deleting wave record for qexp1...done
deleting func_defeqn record for qexp1...done
deleting wave(qexp1)...done
deleting theorem record for qexp2...done
deleting wave record for qexp2...done
deleting wave record for qexp2...done
deleting func_defeqn record for qexp2...done
deleting wave(qexp2)...done
deleting theorem record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave(assm)...done
deleting theorem record for expqexp...done
deleting thm(expqexp)...done
loading def(plus)...done
loading eqn(plus1)...done
loading eqn(plus2)...done
 adding wave-rules for plus1:..done
 adding wave-rules for plus2:.................done
 adding defeqn-record for plus1...done 
 adding defeqn-record for plus2...done 
loading def(times)...done
loading eqn(times1)...done
loading eqn(times2)...done
 adding wave-rules for times1:..done
 adding wave-rules for times2:......................done
 adding defeqn-record for times1...done 
 adding defeqn-record for times2...done 
loading synth(fac)...done
loading def(fac)...done
loading eqn(fac1)...done
loading eqn(fac2)...done
 adding wave-rules for fac1:..done
 adding wave-rules for fac2:...............done
 adding defeqn-record for fac1...done 
 adding defeqn-record for fac2...done 
loading def(out)...done
loading eqn(out1)...done
loading eqn(out2)...done
loading eqn(out3)...done
 adding wave-rules for out1:..done
 adding wave-rules for out2:done
 adding wave-rules for out3:...done
 adding defeqn-record for out1...done 
 adding defeqn-record for out2...done 
 adding defeqn-record for out3...done 
loading thm(assm)...done
 adding wave-rules for assm:........done
loading thm(facout)...done
facout([])
==>j:pnat=>out(s(0),j,j)=fac(j)in pnat
SELECTED METHOD at depth 0: induction([s(j)],[j:pnat])
|facout([2])
|j:pnat
|v0:ih(out(s(0),j,j)=fac(j)in pnat)
|==>out(s(0),``s({j})''<out>,``s({j})''<out>)=fac(``s({j})''<out>)in pnat
|SELECTED METHOD at depth 1: wave([2,1],[fac2,equ(left)])
||facout([1,2])
||j:pnat
||v0:ih(out(s(0),j,j)=fac(j)in pnat)
||==>out(s(0),``s({j})''<out>,``s({j})''<out>)=``times({fac(j)},s(j))''<out>in pnat

>>>>> INVOKING generalize CRITIC <<<<<

------------------------------------------------------------
lemma1:

[j:pnat,v1:pnat]

|- out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat

saving thm(lemma1)...done
Depth bound set to 4
lemma1([])
==>j:pnat=>v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat
SELECTED METHOD at depth 0: induction([s(j)],[j:pnat])
|lemma1([2])
|j:pnat
|v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
|==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=M32(fac(``s({j})''<out>),\v1/)in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[fac2,equ(left)])
||lemma1([1,2])
||j:pnat
||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
||==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
||SELECTED METHOD at depth 2: wave([2,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(Var2403(fac(j),v1),fac(j))in pnat)
|||==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=``times({times(Var2403(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[out3,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[out3,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
|||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([2,1],[assm,equ(right)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(fac(j),Var2410(fac(j),v1))in pnat)
|||==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=times(fac(j),``times(s(j),{Var2410(fac(j),\v1/)})''<in>)in pnat
|||SELECTED METHOD at depth 3: wave([2,2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1],[out3,equ(left)])

Backtracking to [2] (choice point)
|SELECTED METHOD at depth 1: wave([1,1],[out3,equ(left)])
||lemma1([1,2])
||j:pnat
||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=M32(fac(``s({j})''<out>),\v1/)in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[fac2,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
|||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(right)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(times(Var2435(s(0),v1),Var2436(s(0),v1)),j,j)=M32(fac(j),v1)in pnat)
|||==>v1:pnat=>out(times(``times(s(j),{Var2435(s(0),\v1/)})''<in>,Var2436(s(0),\v1/)),j,j)=M32(fac(``s({j})''<out>),\v1/)in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[fac2,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1,1],[assm,equ(left)])

Failed at depth 4
Depth bound set to 7
lemma1([])
==>j:pnat=>v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat
SELECTED METHOD at depth 0: induction([s(j)],[j:pnat])
|lemma1([2])
|j:pnat
|v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
|==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=M32(fac(``s({j})''<out>),\v1/)in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[fac2,equ(left)])
||lemma1([1,2])
||j:pnat
||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
||==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
||SELECTED METHOD at depth 2: wave([2,1],[assm,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(Var2459(fac(j),v1),fac(j))in pnat)
|||==>v1:pnat=>out(M31(s(0),\v1/),``s({j})''<out>,``s({j})''<out>)=``times({times(Var2459(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[out3,equ(left)])
||||lemma1([1,1,1,2])
||||j:pnat
||||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(Var2459(fac(j),v1),fac(j))in pnat)
||||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=``times({times(Var2459(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||j:pnat
|||||v0:ih(v1:pnat=>out(times(Var2471(s(0),v1),Var2472(s(0),v1)),j,j)=times(Var2459(fac(j),v1),fac(j))in pnat)
|||||==>v1:pnat=>out(times(``times(s(j),{Var2471(s(0),\v1/)})''<in>,Var2472(s(0),\v1/)),j,j)=``times({times(Var2459(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2475(s(0),v1),Var2476(s(0),v1)),Var2472(s(0),v1)),j,j)=times(Var2459(fac(j),v1),fac(j))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2475(s(0),\v1/)})''<in>,Var2476(s(0),\v1/)),Var2472(s(0),\v1/)),j,j)=``times({times(Var2459(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,2] (choice point)
||SELECTED METHOD at depth 2: wave([1,1],[out3,equ(left)])
|||lemma1([1,1,2])
|||j:pnat
|||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=M32(fac(j),v1)in pnat)
|||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||j:pnat
||||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(Var2483(fac(j),v1),fac(j))in pnat)
||||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=``times({times(Var2483(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||j:pnat
|||||v0:ih(v1:pnat=>out(times(Var2499(s(0),v1),Var2500(s(0),v1)),j,j)=times(Var2483(fac(j),v1),fac(j))in pnat)
|||||==>v1:pnat=>out(times(``times(s(j),{Var2499(s(0),\v1/)})''<in>,Var2500(s(0),\v1/)),j,j)=``times({times(Var2483(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2503(s(0),v1),Var2504(s(0),v1)),Var2500(s(0),v1)),j,j)=times(Var2483(fac(j),v1),fac(j))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2503(s(0),\v1/)})''<in>,Var2504(s(0),\v1/)),Var2500(s(0),\v1/)),j,j)=``times({times(Var2483(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([1,1,1],[assm,equ(left)])
||||lemma1([1,1,1,2])
||||j:pnat
||||v0:ih(v1:pnat=>out(times(Var2489(s(0),v1),Var2490(s(0),v1)),j,j)=M32(fac(j),v1)in pnat)
||||==>v1:pnat=>out(times(``times(s(j),{Var2489(s(0),\v1/)})''<in>,Var2490(s(0),\v1/)),j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||j:pnat
|||||v0:ih(v1:pnat=>out(times(Var2489(s(0),v1),Var2490(s(0),v1)),j,j)=times(Var2511(fac(j),v1),fac(j))in pnat)
|||||==>v1:pnat=>out(times(``times(s(j),{Var2489(s(0),\v1/)})''<in>,Var2490(s(0),\v1/)),j,j)=``times({times(Var2511(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2527(s(0),v1),Var2528(s(0),v1)),Var2490(s(0),v1)),j,j)=times(Var2511(fac(j),v1),fac(j))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2527(s(0),\v1/)})''<in>,Var2528(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=``times({times(Var2511(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([1,1,1,1],[assm,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||j:pnat
|||||v0:ih(v1:pnat=>out(times(times(Var2517(s(0),v1),Var2518(s(0),v1)),Var2490(s(0),v1)),j,j)=M32(fac(j),v1)in pnat)
|||||==>v1:pnat=>out(times(times(``times(s(j),{Var2517(s(0),\v1/)})''<in>,Var2518(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2517(s(0),v1),Var2518(s(0),v1)),Var2490(s(0),v1)),j,j)=times(Var2535(fac(j),v1),fac(j))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2517(s(0),\v1/)})''<in>,Var2518(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=``times({times(Var2535(fac(j),\v1/),fac(j))},s(j))''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1,1,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(times(Var2541(s(0),v1),Var2542(s(0),v1)),Var2518(s(0),v1)),Var2490(s(0),v1)),j,j)=M32(fac(j),v1)in pnat)
||||||==>v1:pnat=>out(times(times(times(``times(s(j),{Var2541(s(0),\v1/)})''<in>,Var2542(s(0),\v1/)),Var2518(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=M32(``times({fac(j)},s(j))''<out>,\v1/)in pnat
||||||SELECTED METHOD at depth 6: wave([2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([2,1],[assm,equ(right)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([2,1],[assm,equ(right)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2517(s(0),v1),Var2518(s(0),v1)),Var2490(s(0),v1)),j,j)=times(fac(j),Var2546(fac(j),v1))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2517(s(0),\v1/)})''<in>,Var2518(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=times(fac(j),``times(s(j),{Var2546(fac(j),\v1/)})''<in>)in pnat
||||||SELECTED METHOD at depth 6: wave([2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,1,2] (choice point)
||||SELECTED METHOD at depth 4: wave([2,1],[assm,equ(right)])
|||||lemma1([1,1,1,1,2])
|||||j:pnat
|||||v0:ih(v1:pnat=>out(times(Var2489(s(0),v1),Var2490(s(0),v1)),j,j)=times(fac(j),Var2522(fac(j),v1))in pnat)
|||||==>v1:pnat=>out(times(``times(s(j),{Var2489(s(0),\v1/)})''<in>,Var2490(s(0),\v1/)),j,j)=times(fac(j),``times(s(j),{Var2522(fac(j),\v1/)})''<in>)in pnat
|||||SELECTED METHOD at depth 5: wave([2,2,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(Var2489(s(0),v1),Var2490(s(0),v1)),j,j)=times(fac(j),times(Var2579(fac(j),v1),Var2580(fac(j),v1)))in pnat)
||||||==>v1:pnat=>out(times(``times(s(j),{Var2489(s(0),\v1/)})''<in>,Var2490(s(0),\v1/)),j,j)=times(fac(j),times(``times(s(j),{Var2579(fac(j),\v1/)})''<in>,Var2580(fac(j),\v1/)))in pnat
||||||SELECTED METHOD at depth 6: wave([1,2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,1,1,2] (choice point)
|||||SELECTED METHOD at depth 5: wave([1,1,1,1],[assm,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||j:pnat
||||||v0:ih(v1:pnat=>out(times(times(Var2583(s(0),v1),Var2584(s(0),v1)),Var2490(s(0),v1)),j,j)=times(fac(j),Var2522(fac(j),v1))in pnat)
||||||==>v1:pnat=>out(times(times(``times(s(j),{Var2583(s(0),\v1/)})''<in>,Var2584(s(0),\v1/)),Var2490(s(0),\v1/)),j,j)=times(fac(j),``times(s(j),{Var2522(fac(j),\v1/)})''<in>)in pnat
||||||SELECTED METHOD at depth 6: wave([2,2,1],[assm,equ(left)])

Backtracking to [1,1,1,1,1,2] (choice point)
||||||SELECTED METHOD at depth 6: wave([1,1,1,1,1],[assm,equ(left)])

Backtracking to [1,1,2] (choice point)
|||SELECTED METHOD at depth 3: wave([2,1],[assm,equ(right)])
||||lemma1([1,1,1,2])
||||j:pnat
||||v0:ih(v1:pnat=>out(M31(s(0),v1),j,j)=times(fac(j),Var2494(fac(j),v1))in pnat)
||||==>v1:pnat=>out(``times(s(j),{M31(s(0),\v1/)})''<in>,j,j)=times(fac(j),``times(s(j),{Var2494(fac(j),\v1/)})''<in>)in pnat
[j:pnat,v0:ih(v1:pnat=>out(v1,j,j)=times(fac(j),v1)in pnat)]==>v1:pnat=>out(times(s(j),v1),j,j)=times(fac(j),times(s(j),v1))in pnat
||||TERMINATING METHOD at depth 4: fertilize(strong(v0))
|lemma1([1])
|j:pnat
|==>v1:pnat=>out(v1,0,0)=times(fac(0),v1)in pnat
|SELECTED METHOD at depth 1: eval_def([1,1],out1)
||lemma1([1,1])
||j:pnat
||==>v1:pnat=>v1=times(fac(0),v1)in pnat
||SELECTED METHOD at depth 2: eval_def([1,2,1],fac1)
|||lemma1([1,1,1])
|||j:pnat
|||==>v1:pnat=>v1=times(s(0),v1)in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1],times2)
||||lemma1([1,1,1,1])
||||j:pnat
||||==>v1:pnat=>v1=plus(times(0,v1),v1)in pnat
||||SELECTED METHOD at depth 4: eval_def([1,2,1],times1)
|||||lemma1([1,1,1,1,1])
|||||j:pnat
|||||==>v1:pnat=>v1=plus(0,v1)in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1],plus1)
||||||lemma1([1,1,1,1,1,1])
||||||j:pnat
||||||==>v1:pnat=>v1=v1 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
------------------------------------------------------------
lemma1:

[j:pnat,v1:pnat]

|- out(v1,j,j)=times(fac(j),v1)in pnat

WARNING: generalization requires verifying.

Planning complete for facout

------------------------------------------------------------
facout:

[j:pnat]

|- out(s(0),j,j)=fac(j)in pnat

generalize(lemma1)


PLANNING for facout COMPLETE. 

deleting theorem record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for fac...done
deleting synth(fac)...done
deleting def(fac)...done
deleting theorem record for fac1...done
deleting wave record for fac1...done
deleting wave record for fac1...done
deleting func_defeqn record for fac1...done
deleting wave(fac1)...done
deleting theorem record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting wave record for fac2...done
deleting func_defeqn record for fac2...done
deleting wave(fac2)...done
CLaM WARNING: synth(times) not present, so cannot be deleted
deleting def(times)...done
deleting theorem record for times1...done
deleting wave record for times1...done
deleting wave record for times1...done
deleting func_defeqn record for times1...done
deleting wave(times1)...done
deleting theorem record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting wave record for times2...done
deleting func_defeqn record for times2...done
deleting wave(times2)...done
CLaM WARNING: synth(plus) not present, so cannot be deleted
deleting def(plus)...done
deleting theorem record for plus1...done
deleting wave record for plus1...done
deleting wave record for plus1...done
deleting func_defeqn record for plus1...done
deleting wave(plus1)...done
deleting theorem record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting wave record for plus2...done
deleting func_defeqn record for plus2...done
deleting wave(plus2)...done
CLaM WARNING: synth(out) not present, so cannot be deleted
deleting def(out)...done
deleting theorem record for out1...done
deleting wave record for out1...done
deleting wave record for out1...done
deleting func_defeqn record for out1...done
deleting wave(out1)...done
deleting theorem record for out3...done
deleting wave record for out3...done
deleting wave record for out3...done
deleting wave record for out3...done
deleting func_defeqn record for out3...done
deleting wave(out3)...done
deleting theorem record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave record for assm...done
deleting wave(assm)...done
deleting theorem record for facout...done
deleting thm(facout)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(memapp1)...done
memapp1([])
==>x:pnat=>y:pnat list=>z:pnat list=>member(x,y)=>member(x,app(y,z))
SELECTED METHOD at depth 0: induction([v0::y],[y:pnat list])
|memapp1([2])
|v0:pnat
|y:pnat list
|v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|==>x:pnat=>z:pnat list=>member(\x/,``v0::{y}''<out>)=>member(\x/,app(``v0::{y}''<out>,\z/))
|SELECTED METHOD at depth 1: wave([2,2],[app2,equ(left)])
||memapp1([1,2])
||v0:pnat
||y:pnat list
||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
||==>x:pnat=>z:pnat list=>member(\x/,``v0::{y}''<out>)=>member(\x/,``v0::{app(y,\z/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||memapp1([2,1,2])
|||v2:x=v0 in pnat
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|||==>z:pnat list=>member(x,v0::y)=>member(\x/,``v0::{app(y,\z/)}''<out>)
|||SELECTED METHOD at depth 3: equal(v2,right)
||||memapp1([1,2,1,2])
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
||||==>z:pnat list=>member(v0,v0::y)=>member(\v0/,``v0::{app(y,\z/)}''<out>)
||||SELECTED METHOD at depth 4: eval_def([1],member2)
|||||memapp1([1,1,2,1,2])
|||||x:pnat
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|||||==>z:pnat list=>{true}=>member(\v0/,``v0::{app(y,\z/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||memapp1([2,1,1,2,1,2])
||||||v2:v0=v0 in pnat
||||||x:pnat
||||||v0:pnat
||||||y:pnat list
||||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
||||||==>z:pnat list=>{true}=>member(v0,v0::app(y,z))
||||||SELECTED METHOD at depth 6: eval_def([2],member2)
|||||||memapp1([1,2,1,1,2,1,2])
|||||||v2:v0=v0 in pnat
|||||||x:pnat
|||||||v0:pnat
|||||||y:pnat list
|||||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|||||||==>z:pnat list=>{true}=>{true}
|||||||TERMINATING METHOD at depth 7: elementary(...)
||||||memapp1([1,1,1,2,1,2])
||||||v2:v0=v0 in pnat=>void
||||||x:pnat
||||||v0:pnat
||||||y:pnat list
||||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
||||||==>z:pnat list=>{true}=>member(\v0/,``v0::{app(y,\z/)}''<out>)
||||||TERMINATING METHOD at depth 6: elementary(...)
|||memapp1([1,1,2])
|||v2:x=v0 in pnat=>void
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|||==>z:pnat list=>member(\x/,``v0::{y}''<out>)=>member(\x/,``v0::{app(y,\z/)}''<out>)
|||SELECTED METHOD at depth 3: wave([1],[member3,equ(left)])
||||memapp1([1,1,1,2])
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
||||==>z:pnat list=>member(\x/,y)=>member(\x/,``v0::{app(y,\z/)}''<out>)
||||SELECTED METHOD at depth 4: wave([2],[member3,equ(left)])
|||||memapp1([1,1,1,1,2])
|||||v2:x=v0 in pnat=>void
|||||x:pnat
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat=>z:pnat list=>member(x,y)=>member(x,app(y,z)))
|||||==>z:pnat list=>member(\x/,y)=>member(\x/,app(y,\z/))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memapp1([1])
|y:pnat list
|==>x:pnat=>z:pnat list=>member(x,nil)=>member(x,app(nil,z))
|SELECTED METHOD at depth 1: eval_def([1],member1)
||memapp1([1,1])
||y:pnat list
||==>x:pnat=>z:pnat list=>void=>member(x,app(nil,z))
||TERMINATING METHOD at depth 2: elementary(...)
Planning complete for memapp1

------------------------------------------------------------
memapp1:

[x:pnat,y:pnat list,z:pnat list]

|- member(x,y)=>member(x,app(y,z))

induction([v0::y],[y:pnat list]) then 
  [eval_def([1],member1) then 
     elementary(...),
   wave([2,2],[app2,equ(left)]) then 
     casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
       [wave([1],[member3,equ(left)]) then 
          wave([2],[member3,equ(left)]) then 
            fertilize(strong(v1)),
        equal(v2,right) then 
          eval_def([1],member2) then 
            casesplit([[[v0=v0 in pnat=>void]],[[v0=v0 in pnat]]]) then 
              [elementary(...),
               eval_def([2],member2) then 
                 elementary(...)
              ]
       ]
  ]


PLANNING for memapp1 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for memapp1...done
deleting thm(memapp1)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(memapp2)...done
memapp2([])
==>x:pnat=>y:pnat list=>z:pnat list=>member(x,z)=>member(x,app(y,z))
SELECTED METHOD at depth 0: induction([v0::y],[y:pnat list])
|memapp2([2])
|v0:pnat
|y:pnat list
|v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
|==>x:pnat=>z:pnat list=>member(\x/,\z/)=>member(\x/,app(``v0::{y}''<out>,\z/))
|SELECTED METHOD at depth 1: wave([2,2],[app2,equ(left)])
||memapp2([1,2])
||v0:pnat
||y:pnat list
||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
||==>x:pnat=>z:pnat list=>member(\x/,\z/)=>member(\x/,``v0::{app(y,\z/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||memapp2([2,1,2])
|||v2:x=v0 in pnat
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
|||==>z:pnat list=>member(\x/,\z/)=>member(x,v0::app(y,z))
|||SELECTED METHOD at depth 3: equal(v2,right)
||||memapp2([1,2,1,2])
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
||||==>z:pnat list=>member(\v0/,\z/)=>member(v0,v0::app(y,z))
||||SELECTED METHOD at depth 4: eval_def([2],member2)
|||||memapp2([1,1,2,1,2])
|||||x:pnat
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
|||||==>z:pnat list=>member(\v0/,\z/)=>{true}
|||||TERMINATING METHOD at depth 5: elementary(...)
|||memapp2([1,1,2])
|||v2:x=v0 in pnat=>void
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
|||==>z:pnat list=>member(\x/,\z/)=>member(\x/,``v0::{app(y,\z/)}''<out>)
|||SELECTED METHOD at depth 3: wave([2],[member3,equ(left)])
||||memapp2([1,1,1,2])
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>z:pnat list=>member(x,z)=>member(x,app(y,z)))
||||==>z:pnat list=>member(\x/,\z/)=>member(\x/,app(y,\z/))
||||TERMINATING METHOD at depth 4: fertilize(strong(v1))
|memapp2([1])
|y:pnat list
|==>x:pnat=>z:pnat list=>member(x,z)=>member(x,app(nil,z))
|SELECTED METHOD at depth 1: eval_def([2,2],app1)
||memapp2([1,1])
||y:pnat list
||==>x:pnat=>z:pnat list=>member(x,z)=>member(x,z)
||TERMINATING METHOD at depth 2: elementary(...)
Planning complete for memapp2

------------------------------------------------------------
memapp2:

[x:pnat,y:pnat list,z:pnat list]

|- member(x,z)=>member(x,app(y,z))

induction([v0::y],[y:pnat list]) then 
  [eval_def([2,2],app1) then 
     elementary(...),
   wave([2,2],[app2,equ(left)]) then 
     casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
       [wave([2],[member3,equ(left)]) then 
          fertilize(strong(v1)),
        equal(v2,right) then 
          eval_def([2],member2) then 
            elementary(...)
       ]
  ]


PLANNING for memapp2 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for memapp2...done
deleting thm(memapp2)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(app)...done
loading eqn(app1)...done
loading eqn(app2)...done
 adding wave-rules for app1:..done
 adding wave-rules for app2:..............................done
 adding defeqn-record for app1...done 
 adding defeqn-record for app2...done 
loading thm(memapp3)...done
memapp3([])
==>e:pnat=>l1:pnat list=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2))
SELECTED METHOD at depth 0: induction([v0::l1],[l1:pnat list])
|memapp3([2])
|v0:pnat
|l1:pnat list
|v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|==>e:pnat=>l2:pnat list=>member(\e/,``v0::{l1}''<out>)\member(\e/,\l2/)=>member(\e/,app(``v0::{l1}''<out>,\l2/))
|SELECTED METHOD at depth 1: wave([2,2],[app2,equ(left)])
||memapp3([1,2])
||v0:pnat
||l1:pnat list
||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
||==>e:pnat=>l2:pnat list=>member(\e/,``v0::{l1}''<out>)\member(\e/,\l2/)=>member(\e/,``v0::{app(l1,\l2/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||memapp3([2,1,2])
|||v2:e=v0 in pnat
|||e:pnat
|||v0:pnat
|||l1:pnat list
|||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|||==>l2:pnat list=>member(e,v0::l1)\member(\e/,\l2/)=>member(\e/,``v0::{app(l1,\l2/)}''<out>)
|||SELECTED METHOD at depth 3: equal(v2,left)
||||memapp3([1,2,1,2])
||||e:pnat
||||v0:pnat
||||l1:pnat list
||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
||||==>l2:pnat list=>member(e,\e/ ::l1)\member(\e/,\l2/)=>member(\e/,``\e/ ::{app(l1,\l2/)}''<out>)
||||SELECTED METHOD at depth 4: eval_def([1,1],member2)
|||||memapp3([1,1,2,1,2])
|||||e:pnat
|||||v0:pnat
|||||l1:pnat list
|||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|||||==>l2:pnat list=>{true}\member(\e/,\l2/)=>member(\e/,``\e/ ::{app(l1,\l2/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||memapp3([2,1,1,2,1,2])
||||||v2:e=e in pnat
||||||e:pnat
||||||v0:pnat
||||||l1:pnat list
||||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
||||||==>l2:pnat list=>{true}\member(\e/,\l2/)=>member(e,e::app(l1,l2))
||||||SELECTED METHOD at depth 6: eval_def([2],member2)
|||||||memapp3([1,2,1,1,2,1,2])
|||||||v2:e=e in pnat
|||||||e:pnat
|||||||v0:pnat
|||||||l1:pnat list
|||||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|||||||==>l2:pnat list=>{true}\member(\e/,\l2/)=>{true}
|||||||TERMINATING METHOD at depth 7: elementary(...)
||||||memapp3([1,1,1,2,1,2])
||||||v2:e=e in pnat=>void
||||||e:pnat
||||||v0:pnat
||||||l1:pnat list
||||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
||||||==>l2:pnat list=>{true}\member(\e/,\l2/)=>member(\e/,``\e/ ::{app(l1,\l2/)}''<out>)
||||||TERMINATING METHOD at depth 6: elementary(...)
|||memapp3([1,1,2])
|||v2:e=v0 in pnat=>void
|||e:pnat
|||v0:pnat
|||l1:pnat list
|||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|||==>l2:pnat list=>member(\e/,``v0::{l1}''<out>)\member(\e/,\l2/)=>member(\e/,``v0::{app(l1,\l2/)}''<out>)
|||SELECTED METHOD at depth 3: wave([1,1],[member3,equ(left)])
||||memapp3([1,1,1,2])
||||v2:e=v0 in pnat=>void
||||e:pnat
||||v0:pnat
||||l1:pnat list
||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
||||==>l2:pnat list=>member(\e/,l1)\member(\e/,\l2/)=>member(\e/,``v0::{app(l1,\l2/)}''<out>)
||||SELECTED METHOD at depth 4: wave([2],[member3,equ(left)])
|||||memapp3([1,1,1,1,2])
|||||v2:e=v0 in pnat=>void
|||||e:pnat
|||||v0:pnat
|||||l1:pnat list
|||||v1:ih(e:pnat=>l2:pnat list=>member(e,l1)\member(e,l2)=>member(e,app(l1,l2)))
|||||==>l2:pnat list=>member(\e/,l1)\member(\e/,\l2/)=>member(\e/,app(l1,\l2/))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memapp3([1])
|l1:pnat list
|==>e:pnat=>l2:pnat list=>member(e,nil)\member(e,l2)=>member(e,app(nil,l2))
|SELECTED METHOD at depth 1: eval_def([2,2],app1)
||memapp3([1,1])
||l1:pnat list
||==>e:pnat=>l2:pnat list=>member(e,nil)\member(e,l2)=>member(e,l2)
||SELECTED METHOD at depth 2: eval_def([1,1],member1)
|||memapp3([1,1,1])
|||l1:pnat list
|||==>e:pnat=>l2:pnat list=>void\member(e,l2)=>member(e,l2)
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for memapp3

------------------------------------------------------------
memapp3:

[e:pnat,l1:pnat list,l2:pnat list]

|- member(e,l1)\member(e,l2)=>member(e,app(l1,l2))

induction([v0::l1],[l1:pnat list]) then 
  [eval_def([2,2],app1) then 
     eval_def([1,1],member1) then 
       elementary(...),
   wave([2,2],[app2,equ(left)]) then 
     casesplit([[[e=v0 in pnat=>void]],[[e=v0 in pnat]]]) then 
       [wave([1,1],[member3,equ(left)]) then 
          wave([2],[member3,equ(left)]) then 
            fertilize(strong(v1)),
        equal(v2,left) then 
          eval_def([1,1],member2) then 
            casesplit([[[e=e in pnat=>void]],[[e=e in pnat]]]) then 
              [elementary(...),
               eval_def([2],member2) then 
                 elementary(...)
              ]
       ]
  ]


PLANNING for memapp3 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(app) not present, so cannot be deleted
deleting def(app)...done
deleting theorem record for app1...done
deleting wave record for app1...done
deleting wave record for app1...done
deleting func_defeqn record for app1...done
deleting wave(app1)...done
deleting theorem record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting wave record for app2...done
deleting func_defeqn record for app2...done
deleting wave(app2)...done
deleting theorem record for memapp3...done
deleting thm(memapp3)...done
loading synth(nth)...done
loading synth(nth)...done
loading def(nth)...done
loading eqn(nth1)...done
loading eqn(nth2)...done
loading eqn(nth3)...done
 adding wave-rules for nth1:..done
 adding wave-rules for nth2:..done
 adding wave-rules for nth3:..done
 adding defeqn-record for nth1...done 
 adding defeqn-record for nth2...done 
 adding defeqn-record for nth3...done 
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading thm(nthmem)...done
nthmem([])
==>x:pnat=>n:pnat=>l:pnat list=>member(x,nth(n,l))=>member(x,l)
SELECTED METHOD at depth 0: induction([s(v2),v0::v1],[n:pnat,l:pnat list])
|nthmem([3])
|v0:pnat
|v1:pnat list
|v2:pnat
|v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
|l:pnat list
|n:pnat
|==>x:pnat=>member(\x/,nth(``s({v2})''<out>,``v0::{v1}''<out>))=>member(\x/,``v0::{v1}''<out>)
|SELECTED METHOD at depth 1: wave([2,1],[nth3,equ(left)])
||nthmem([1,3])
||v0:pnat
||v1:pnat list
||v2:pnat
||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
||l:pnat list
||n:pnat
||==>x:pnat=>member(\x/,nth(v2,v1))=>member(\x/,``v0::{v1}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||nthmem([2,1,3])
|||v4:x=v0 in pnat
|||x:pnat
|||v0:pnat
|||v1:pnat list
|||v2:pnat
|||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
|||l:pnat list
|||n:pnat
|||==>member(\x/,nth(v2,v1))=>member(x,v0::v1)
|||SELECTED METHOD at depth 3: equal(v4,right)
||||nthmem([1,2,1,3])
||||x:pnat
||||v0:pnat
||||v1:pnat list
||||v2:pnat
||||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
||||l:pnat list
||||n:pnat
||||==>member(\v0/,nth(v2,v1))=>member(v0,v0::v1)
||||SELECTED METHOD at depth 4: eval_def([2],member2)
|||||nthmem([1,1,2,1,3])
|||||x:pnat
|||||v0:pnat
|||||v1:pnat list
|||||v2:pnat
|||||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
|||||l:pnat list
|||||n:pnat
|||||==>member(\v0/,nth(v2,v1))=>{true}
|||||TERMINATING METHOD at depth 5: elementary(...)
|||nthmem([1,1,3])
|||v4:x=v0 in pnat=>void
|||x:pnat
|||v0:pnat
|||v1:pnat list
|||v2:pnat
|||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
|||l:pnat list
|||n:pnat
|||==>member(\x/,nth(v2,v1))=>member(\x/,``v0::{v1}''<out>)
|||SELECTED METHOD at depth 3: wave([2],[member3,equ(left)])
||||nthmem([1,1,1,3])
||||v4:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||v1:pnat list
||||v2:pnat
||||v3:ih(x:pnat=>member(x,nth(v2,v1))=>member(x,v1))
||||l:pnat list
||||n:pnat
||||==>member(\x/,nth(v2,v1))=>member(\x/,v1)
||||TERMINATING METHOD at depth 4: fertilize(strong(v3))
|nthmem([2])
|l:pnat list
|n:pnat
|v0:pnat
|==>x:pnat=>member(x,nth(0,l))=>member(x,l)
|SELECTED METHOD at depth 1: eval_def([2,1],nth1)
||nthmem([1,2])
||l:pnat list
||n:pnat
||v0:pnat
||==>x:pnat=>member(x,l)=>member(x,l)
||TERMINATING METHOD at depth 2: elementary(...)
|nthmem([1])
|l:pnat list
|n:pnat
|v0:pnat list
|==>x:pnat=>member(x,nth(n,nil))=>member(x,nil)
|SELECTED METHOD at depth 1: eval_def([2],member1)
||nthmem([1,1])
||l:pnat list
||n:pnat
||v0:pnat list
||==>x:pnat=>member(x,nth(n,nil))=>void
||SELECTED METHOD at depth 2: eval_def([2,1],nth2)
|||nthmem([1,1,1])
|||l:pnat list
|||n:pnat
|||v0:pnat list
|||==>x:pnat=>member(x,nil)=>void
|||SELECTED METHOD at depth 3: eval_def([1],member1)
||||nthmem([1,1,1,1])
||||l:pnat list
||||n:pnat
||||v0:pnat list
||||==>x:pnat=>void=>void
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for nthmem

------------------------------------------------------------
nthmem:

[x:pnat,n:pnat,l:pnat list]

|- member(x,nth(n,l))=>member(x,l)

induction([s(v2),v0::v1],[n:pnat,l:pnat list]) then 
  [eval_def([2],member1) then 
     eval_def([2,1],nth2) then 
       eval_def([1],member1) then 
         elementary(...),
   eval_def([2,1],nth1) then 
     elementary(...),
   wave([2,1],[nth3,equ(left)]) then 
     casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
       [wave([2],[member3,equ(left)]) then 
          fertilize(strong(v3)),
        equal(v4,right) then 
          eval_def([2],member2) then 
            elementary(...)
       ]
  ]


PLANNING for nthmem COMPLETE. 

deleting theorem record for nth...done
deleting synth(nth)...done
deleting def(nth)...done
deleting theorem record for nth1...done
deleting wave record for nth1...done
deleting wave record for nth1...done
deleting func_defeqn record for nth1...done
deleting wave(nth1)...done
deleting theorem record for nth2...done
deleting wave record for nth2...done
deleting wave record for nth2...done
deleting func_defeqn record for nth2...done
deleting wave(nth2)...done
deleting theorem record for nth3...done
deleting wave record for nth3...done
deleting wave record for nth3...done
deleting func_defeqn record for nth3...done
deleting wave(nth3)...done
deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for nthmem...done
deleting thm(nthmem)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(subset)...done
loading eqn(subset1)...done
loading eqn(subset2)...done
loading eqn(subset3)...done
 adding wave-rules for subset1:done
 adding wave-rules for subset2:done
 adding wave-rules for subset3:..done
 adding defeqn-record for subset1...done 
 adding defeqn-record for subset2...done 
 adding defeqn-record for subset3...done 
loading lemma(decmember)...done
loading synth(union)...done
loading synth(union)...done
loading def(union)...done
loading eqn(union1)...done
loading eqn(union2)...done
loading eqn(union3)...done
loading eqn(union4)...done
 adding wave-rules for union1:..done
 adding wave-rules for union2:..done
 adding wave-rules for union3:..done
 adding wave-rules for union4:..............................done
 adding defeqn-record for union1...done 
 adding defeqn-record for union2...done 
 adding defeqn-record for union3...done 
 adding defeqn-record for union4...done 
loading thm(subsetunion)...done
subsetunion([])
==>a:pnat list=>b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|subsetunion([2])
|v0:pnat
|a:pnat list
|v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
|==>b:pnat list=>subset(``v0::{a}''<out>,\b/)=>union(``v0::{a}''<out>,\b/)=\b/in pnat list

>>>>> INVOKING casesplit CRITIC <<<<<

||subsetunion([2,2])
||v2:member(v0,b)=>void
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
||==>subset(v0::a,b)=>union(``v0::{a}''<out>,\b/)=\b/in pnat list
||SELECTED METHOD at depth 2: eval_def([1],subset2)
|||subsetunion([1,2,2])
|||v2:member(v0,b)=>void
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
|||==>void=>union(``v0::{a}''<out>,\b/)=\b/in pnat list
|||TERMINATING METHOD at depth 3: elementary(...)
||subsetunion([1,2])
||v2:member(v0,b)
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
||==>subset(``v0::{a}''<out>,\b/)=>union(``v0::{a}''<out>,\b/)=\b/in pnat list
||SELECTED METHOD at depth 2: wave([1],[subset3,equ(left)])
|||subsetunion([1,1,2])
|||v2:member(v0,b)
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
|||==>subset(a,\b/)=>union(``v0::{a}''<out>,\b/)=\b/in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,2],[union3,equ(left)])
||||subsetunion([1,1,1,2])
||||v2:member(v0,b)
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(b:pnat list=>subset(a,b)=>union(a,b)=b in pnat list)
||||==>subset(a,\b/)=>union(a,\b/)=\b/in pnat list
||||TERMINATING METHOD at depth 4: fertilize(strong(v1))
|subsetunion([1])
|a:pnat list
|==>b:pnat list=>subset(nil,b)=>union(nil,b)=b in pnat list
|SELECTED METHOD at depth 1: normal(imply_intro(v0))
||subsetunion([1,1])
||v0:subset(nil,b)
||b:pnat list
||a:pnat list
||==>union(nil,b)=b in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1],union1)
|||subsetunion([1,1,1])
|||v0:subset(nil,b)
|||b:pnat list
|||a:pnat list
|||==>b=b in pnat list
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for subsetunion

------------------------------------------------------------
subsetunion:

[a:pnat list,b:pnat list]

|- subset(a,b)=>union(a,b)=b in pnat list

induction([v0::a],[a:pnat list]) then 
  [normal(imply_intro(v0)) then 
     eval_def([1,1],union1) then 
       elementary(...),
   casesplit([[[member(v0,b)]],[[member(v0,b)=>void]]]) then 
     [wave([1],[subset3,equ(left)]) then 
        wave([1,1,2],[union3,equ(left)]) then 
          fertilize(strong(v1)),
      eval_def([1],subset2) then 
        elementary(...)
     ]
  ]


PLANNING for subsetunion COMPLETE. 

CLaM WARNING: synth(subset) not present, so cannot be deleted
deleting def(subset)...done
deleting theorem record for subset3...done
deleting wave record for subset3...done
deleting wave record for subset3...done
deleting func_defeqn record for subset3...done
deleting wave(subset3)...done
deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for union...done
deleting synth(union)...done
deleting def(union)...done
deleting theorem record for union1...done
deleting wave record for union1...done
deleting wave record for union1...done
deleting func_defeqn record for union1...done
deleting wave(union1)...done
deleting theorem record for union2...done
deleting wave record for union2...done
deleting wave record for union2...done
deleting func_defeqn record for union2...done
deleting wave(union2)...done
deleting theorem record for union3...done
deleting wave record for union3...done
deleting wave record for union3...done
deleting func_defeqn record for union3...done
deleting wave(union3)...done
deleting theorem record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting func_defeqn record for union4...done
deleting wave(union4)...done
deleting theorem record for subsetunion...done
deleting thm(subsetunion)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(subset)...done
loading eqn(subset1)...done
loading eqn(subset2)...done
loading eqn(subset3)...done
 adding wave-rules for subset1:done
 adding wave-rules for subset2:done
 adding wave-rules for subset3:..done
 adding defeqn-record for subset1...done 
 adding defeqn-record for subset2...done 
 adding defeqn-record for subset3...done 
loading synth(intersect)...done
loading synth(intersect)...done
loading def(intersect)...done
loading eqn(intersect1)...done
loading eqn(intersect2)...done
loading eqn(intersect3)...done
loading eqn(intersect4)...done
 adding wave-rules for intersect1:..done
 adding wave-rules for intersect2:..done
 adding wave-rules for intersect3:..............................done
 adding wave-rules for intersect4:..done
 adding defeqn-record for intersect1...done 
 adding defeqn-record for intersect2...done 
 adding defeqn-record for intersect3...done 
 adding defeqn-record for intersect4...done 
loading thm(cnc_cons1)...done
 adding wave-rules for cnc_cons1:done
 adding cancel-record for cnc_cons1...done
loading thm(subsetintersect)...done
subsetintersect([])
==>a:pnat list=>b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|subsetintersect([2])
|v0:pnat
|a:pnat list
|v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
|==>b:pnat list=>subset(``v0::{a}''<out>,\b/)=>intersect(``v0::{a}''<out>,\b/)=``v0::{a}''<out>in pnat list

>>>>> INVOKING casesplit CRITIC <<<<<

||subsetintersect([2,2])
||v2:member(v0,b)=>void
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
||==>subset(v0::a,b)=>intersect(``v0::{a}''<out>,\b/)=``v0::{a}''<out>in pnat list
||SELECTED METHOD at depth 2: eval_def([1],subset2)
|||subsetintersect([1,2,2])
|||v2:member(v0,b)=>void
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
|||==>void=>intersect(``v0::{a}''<out>,\b/)=``v0::{a}''<out>in pnat list
|||TERMINATING METHOD at depth 3: elementary(...)
||subsetintersect([1,2])
||v2:member(v0,b)
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
||==>subset(``v0::{a}''<out>,\b/)=>intersect(``v0::{a}''<out>,\b/)=``v0::{a}''<out>in pnat list
||SELECTED METHOD at depth 2: wave([1],[subset3,equ(left)])
|||subsetintersect([1,1,2])
|||v2:member(v0,b)
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
|||==>subset(a,\b/)=>intersect(``v0::{a}''<out>,\b/)=``v0::{a}''<out>in pnat list
|||SELECTED METHOD at depth 3: wave([1,1,2],[intersect3,equ(left)])
||||subsetintersect([1,1,1,2])
||||v2:member(v0,b)
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
||||==>subset(a,\b/)=>``v0::{intersect(a,\b/)}''<out> =``v0::{a}''<out>in pnat list
||||SELECTED METHOD at depth 4: fertilize(weak(v1))
|||||subsetintersect([1,1,1,1,2])
|||||v2:member(v0,b)
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(b:pnat list=>subset(a,b)=>intersect(a,b)=a in pnat list)
|||||==>v0::a=v0::a in pnat list
|||||TERMINATING METHOD at depth 5: elementary(...)
|subsetintersect([1])
|a:pnat list
|==>b:pnat list=>subset(nil,b)=>intersect(nil,b)=nil in pnat list
|SELECTED METHOD at depth 1: normal(imply_intro(v0))
||subsetintersect([1,1])
||v0:subset(nil,b)
||b:pnat list
||a:pnat list
||==>intersect(nil,b)=nil in pnat list
||SELECTED METHOD at depth 2: eval_def([1,1],intersect1)
|||subsetintersect([1,1,1])
|||v0:subset(nil,b)
|||b:pnat list
|||a:pnat list
|||==>nil=nil in pnat list
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for subsetintersect

------------------------------------------------------------
subsetintersect:

[a:pnat list,b:pnat list]

|- subset(a,b)=>intersect(a,b)=a in pnat list

induction([v0::a],[a:pnat list]) then 
  [normal(imply_intro(v0)) then 
     eval_def([1,1],intersect1) then 
       elementary(...),
   casesplit([[[member(v0,b)]],[[member(v0,b)=>void]]]) then 
     [wave([1],[subset3,equ(left)]) then 
        wave([1,1,2],[intersect3,equ(left)]) then 
          fertilize(weak(v1)) then 
            elementary(...),
      eval_def([1],subset2) then 
        elementary(...)
     ]
  ]


PLANNING for subsetintersect COMPLETE. 

CLaM WARNING: synth(subset) not present, so cannot be deleted
deleting def(subset)...done
deleting theorem record for subset3...done
deleting wave record for subset3...done
deleting wave record for subset3...done
deleting func_defeqn record for subset3...done
deleting wave(subset3)...done
deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for intersect...done
deleting synth(intersect)...done
deleting def(intersect)...done
deleting theorem record for intersect1...done
deleting wave record for intersect1...done
deleting wave record for intersect1...done
deleting func_defeqn record for intersect1...done
deleting wave(intersect1)...done
deleting theorem record for intersect2...done
deleting wave record for intersect2...done
deleting wave record for intersect2...done
deleting func_defeqn record for intersect2...done
deleting wave(intersect2)...done
deleting theorem record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting func_defeqn record for intersect3...done
deleting wave(intersect3)...done
deleting theorem record for intersect4...done
deleting wave record for intersect4...done
deleting wave record for intersect4...done
deleting func_defeqn record for intersect4...done
deleting wave(intersect4)...done
deleting theorem record for subsetintersect...done
deleting thm(subsetintersect)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading synth(union)...done
loading synth(union)...done
loading def(union)...done
loading eqn(union1)...done
loading eqn(union2)...done
loading eqn(union3)...done
loading eqn(union4)...done
 adding wave-rules for union1:..done
 adding wave-rules for union2:..done
 adding wave-rules for union3:..done
 adding wave-rules for union4:..............................done
 adding defeqn-record for union1...done 
 adding defeqn-record for union2...done 
 adding defeqn-record for union3...done 
 adding defeqn-record for union4...done 
loading thm(memunion1)...done
memunion1([])
==>x:pnat=>a:pnat list=>b:pnat list=>member(x,a)=>member(x,union(a,b))
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|memunion1([2])
|v0:pnat
|a:pnat list
|v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|==>x:pnat=>b:pnat list=>member(\x/,``v0::{a}''<out>)=>member(\x/,union(``v0::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||memunion1([2,2])
||v2:x=v0 in pnat
||x:pnat
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||==>b:pnat list=>member(x,v0::a)=>member(\x/,union(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: equal(v2,right)
|||memunion1([1,2,2])
|||x:pnat
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||==>b:pnat list=>member(v0,v0::a)=>member(\v0/,union(``v0::{a}''<out>,\b/))
|||SELECTED METHOD at depth 3: eval_def([1],member2)
||||memunion1([1,1,2,2])
||||x:pnat
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||==>b:pnat list=>{true}=>member(\v0/,union(``v0::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

|||||memunion1([2,1,1,2,2])
|||||v2:member(v0,b)
|||||b:pnat list
|||||x:pnat
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||==>{true}=>member(\v0/,union(``v0::{a}''<out>,\b/))
|||||SELECTED METHOD at depth 5: wave([2,2],[union3,equ(left)])
||||||memunion1([1,2,1,1,2,2])
||||||v2:member(v0,b)
||||||b:pnat list
||||||x:pnat
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||==>{true}=>member(\v0/,union(a,\b/))
||||||SELECTED METHOD at depth 6: induction([v3::a],[a:pnat list])
|||||||memunion1([2,1,2,1,1,2,2])
|||||||v3:pnat
|||||||a:pnat list
|||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
|||||||v2:member(v0,b)
|||||||b:pnat list
|||||||x:pnat
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||==>{true}=>member(\v0/,union(``v3::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||||||||memunion1([2,2,1,2,1,1,2,2])
||||||||v5:member(v3,b)
||||||||v3:pnat
||||||||a:pnat list
||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
||||||||v2:member(v0,b)
||||||||b:pnat list
||||||||x:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||==>{true}=>member(\v0/,union(``v3::{a}''<out>,\b/))
||||||||SELECTED METHOD at depth 8: wave([2,2],[union3,equ(left)])
|||||||||memunion1([1,2,2,1,2,1,1,2,2])
|||||||||v5:member(v3,b)
|||||||||v3:pnat
|||||||||a:pnat list
|||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
|||||||||v2:member(v0,b)
|||||||||b:pnat list
|||||||||x:pnat
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||||==>{true}=>member(\v0/,union(a,\b/))
|||||||||TERMINATING METHOD at depth 9: fertilize(strong(v4))
||||||||memunion1([1,2,1,2,1,1,2,2])
||||||||v5:member(v3,b)=>void
||||||||v3:pnat
||||||||a:pnat list
||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
||||||||v2:member(v0,b)
||||||||b:pnat list
||||||||x:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||==>{true}=>member(\v0/,union(``v3::{a}''<out>,\b/))
||||||||SELECTED METHOD at depth 8: wave([2,2],[union4,equ(left)])
|||||||||memunion1([1,1,2,1,2,1,1,2,2])
|||||||||v5:member(v3,b)=>void
|||||||||v3:pnat
|||||||||a:pnat list
|||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
|||||||||v2:member(v0,b)
|||||||||b:pnat list
|||||||||x:pnat
|||||||||v0:pnat
|||||||||a:pnat list
|||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||||==>{true}=>member(\v0/,``v3::{union(a,\b/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||||||memunion1([2,1,1,2,1,2,1,1,2,2])
||||||||||v6:v0=v3 in pnat
||||||||||v5:member(v3,b)=>void
||||||||||v3:pnat
||||||||||a:pnat list
||||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
||||||||||v2:member(v0,b)
||||||||||b:pnat list
||||||||||x:pnat
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||||==>{true}=>member(v0,v3::union(a,b))
||||||||||SELECTED METHOD at depth 10: equal(v6,left)
|||||||||||memunion1([1,2,1,1,2,1,2,1,1,2,2])
|||||||||||v5:member(v3,b)=>void
|||||||||||v3:pnat
|||||||||||a:pnat list
|||||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
|||||||||||v2:member(v0,b)
|||||||||||b:pnat list
|||||||||||x:pnat
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||||||==>{true}=>member(v0,v0::union(a,b))
|||||||||||SELECTED METHOD at depth 11: eval_def([2],member2)
||||||||||||memunion1([1,1,2,1,1,2,1,2,1,1,2,2])
||||||||||||v5:member(v3,b)=>void
||||||||||||v3:pnat
||||||||||||a:pnat list
||||||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
||||||||||||v2:member(v0,b)
||||||||||||b:pnat list
||||||||||||x:pnat
||||||||||||v0:pnat
||||||||||||a:pnat list
||||||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||||||==>{true}=>{true}
||||||||||||TERMINATING METHOD at depth 12: elementary(...)
||||||||||memunion1([1,1,1,2,1,2,1,1,2,2])
||||||||||v6:v0=v3 in pnat=>void
||||||||||v5:member(v3,b)=>void
||||||||||v3:pnat
||||||||||a:pnat list
||||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
||||||||||v2:member(v0,b)
||||||||||b:pnat list
||||||||||x:pnat
||||||||||v0:pnat
||||||||||a:pnat list
||||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||||==>{true}=>member(\v0/,``v3::{union(a,\b/)}''<out>)
||||||||||SELECTED METHOD at depth 10: wave([2],[member3,equ(left)])
|||||||||||memunion1([1,1,1,1,2,1,2,1,1,2,2])
|||||||||||v6:v0=v3 in pnat=>void
|||||||||||v5:member(v3,b)=>void
|||||||||||v3:pnat
|||||||||||a:pnat list
|||||||||||v4:ih({true}=>member(\v0/,union(a,\b/)))
|||||||||||v2:member(v0,b)
|||||||||||b:pnat list
|||||||||||x:pnat
|||||||||||v0:pnat
|||||||||||a:pnat list
|||||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||||||==>{true}=>member(\v0/,union(a,\b/))
|||||||||||TERMINATING METHOD at depth 11: fertilize(strong(v4))
|||||||memunion1([1,1,2,1,1,2,2])
|||||||a:pnat list
|||||||v2:member(v0,b)
|||||||b:pnat list
|||||||x:pnat
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||==>{true}=>member(\v0/,union(nil,\b/))
|||||||SELECTED METHOD at depth 7: eval_def([2,2],union1)
||||||||memunion1([1,1,1,2,1,1,2,2])
||||||||a:pnat list
||||||||v2:member(v0,b)
||||||||b:pnat list
||||||||x:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||==>{true}=>member(\v0/,\b/)
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||memunion1([1,1,1,2,2])
|||||v2:member(v0,b)=>void
|||||b:pnat list
|||||x:pnat
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||==>{true}=>member(\v0/,union(``v0::{a}''<out>,\b/))
|||||SELECTED METHOD at depth 5: wave([2,2],[union4,equ(left)])
||||||memunion1([1,1,1,1,2,2])
||||||v2:member(v0,b)=>void
||||||b:pnat list
||||||x:pnat
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||==>{true}=>member(\v0/,``v0::{union(a,\b/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||||||memunion1([2,1,1,1,1,2,2])
|||||||v3:v0=v0 in pnat
|||||||v2:member(v0,b)=>void
|||||||b:pnat list
|||||||x:pnat
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||==>{true}=>member(v0,v0::union(a,b))
|||||||SELECTED METHOD at depth 7: eval_def([2],member2)
||||||||memunion1([1,2,1,1,1,1,2,2])
||||||||v3:v0=v0 in pnat
||||||||v2:member(v0,b)=>void
||||||||b:pnat list
||||||||x:pnat
||||||||v0:pnat
||||||||a:pnat list
||||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||||==>{true}=>{true}
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||||memunion1([1,1,1,1,1,2,2])
|||||||v3:v0=v0 in pnat=>void
|||||||v2:member(v0,b)=>void
|||||||b:pnat list
|||||||x:pnat
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||||==>{true}=>member(\v0/,``v0::{union(a,\b/)}''<out>)
|||||||TERMINATING METHOD at depth 7: elementary(...)
||memunion1([1,2])
||v2:x=v0 in pnat=>void
||x:pnat
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||==>b:pnat list=>member(\x/,``v0::{a}''<out>)=>member(\x/,union(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: wave([1],[member3,equ(left)])
|||memunion1([1,1,2])
|||v2:x=v0 in pnat=>void
|||x:pnat
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||==>b:pnat list=>member(\x/,a)=>member(\x/,union(``v0::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||||memunion1([2,1,1,2])
||||v3:member(v0,b)
||||b:pnat list
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||==>member(\x/,a)=>member(\x/,union(``v0::{a}''<out>,\b/))
||||SELECTED METHOD at depth 4: wave([2,2],[union3,equ(left)])
|||||memunion1([1,2,1,1,2])
|||||v3:member(v0,b)
|||||b:pnat list
|||||v2:x=v0 in pnat=>void
|||||x:pnat
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||==>member(\x/,a)=>member(\x/,union(a,\b/))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
||||memunion1([1,1,1,2])
||||v3:member(v0,b)=>void
||||b:pnat list
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||==>member(\x/,a)=>member(\x/,union(``v0::{a}''<out>,\b/))
||||SELECTED METHOD at depth 4: wave([2,2],[union4,equ(left)])
|||||memunion1([1,1,1,1,2])
|||||v3:member(v0,b)=>void
|||||b:pnat list
|||||v2:x=v0 in pnat=>void
|||||x:pnat
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
|||||==>member(\x/,a)=>member(\x/,``v0::{union(a,\b/)}''<out>)
|||||SELECTED METHOD at depth 5: wave([2],[member3,equ(left)])
||||||memunion1([1,1,1,1,1,2])
||||||v3:member(v0,b)=>void
||||||b:pnat list
||||||v2:x=v0 in pnat=>void
||||||x:pnat
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(x:pnat=>b:pnat list=>member(x,a)=>member(x,union(a,b)))
||||||==>member(\x/,a)=>member(\x/,union(a,\b/))
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
|memunion1([1])
|a:pnat list
|==>x:pnat=>b:pnat list=>member(x,nil)=>member(x,union(nil,b))
|SELECTED METHOD at depth 1: eval_def([1],member1)
||memunion1([1,1])
||a:pnat list
||==>x:pnat=>b:pnat list=>void=>member(x,union(nil,b))
||TERMINATING METHOD at depth 2: elementary(...)
Planning complete for memunion1

------------------------------------------------------------
memunion1:

[x:pnat,a:pnat list,b:pnat list]

|- member(x,a)=>member(x,union(a,b))

induction([v0::a],[a:pnat list]) then 
  [eval_def([1],member1) then 
     elementary(...),
   casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
     [wave([1],[member3,equ(left)]) then 
        casesplit([[[member(v0,b)=>void],[member(v0,b)]],[]]) then 
          [wave([2,2],[union4,equ(left)]) then 
             wave([2],[member3,equ(left)]) then 
               fertilize(strong(v1)),
           wave([2,2],[union3,equ(left)]) then 
             fertilize(strong(v1))
          ],
      equal(v2,right) then 
        eval_def([1],member2) then 
          casesplit([[[member(v0,b)=>void],[member(v0,b)]],[]]) then 
            [wave([2,2],[union4,equ(left)]) then 
               casesplit([[[v0=v0 in pnat=>void]],[[v0=v0 in pnat]]]) then 
                 [elementary(...),
                  eval_def([2],member2) then 
                    elementary(...)
                 ],
             wave([2,2],[union3,equ(left)]) then 
               induction([v3::a],[a:pnat list]) then 
                 [eval_def([2,2],union1) then 
                    elementary(...),
                  casesplit([[[member(v3,b)=>void],[member(v3,b)]],[]]) then 
                    [wave([2,2],[union4,equ(left)]) then 
                       casesplit([[[v0=v3 in pnat=>void]],[[v0=v3 in pnat]]]) then 
                         [wave([2],[member3,equ(left)]) then 
                            fertilize(strong(v4)),
                          equal(v6,left) then 
                            eval_def([2],member2) then 
                              elementary(...)
                         ],
                     wave([2,2],[union3,equ(left)]) then 
                       fertilize(strong(v4))
                    ]
                 ]
            ]
     ]
  ]


PLANNING for memunion1 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for union...done
deleting synth(union)...done
deleting def(union)...done
deleting theorem record for union1...done
deleting wave record for union1...done
deleting wave record for union1...done
deleting func_defeqn record for union1...done
deleting wave(union1)...done
deleting theorem record for union2...done
deleting wave record for union2...done
deleting wave record for union2...done
deleting func_defeqn record for union2...done
deleting wave(union2)...done
deleting theorem record for union3...done
deleting wave record for union3...done
deleting wave record for union3...done
deleting func_defeqn record for union3...done
deleting wave(union3)...done
deleting theorem record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting func_defeqn record for union4...done
deleting wave(union4)...done
deleting theorem record for memunion1...done
deleting thm(memunion1)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading synth(union)...done
loading synth(union)...done
loading def(union)...done
loading eqn(union1)...done
loading eqn(union2)...done
loading eqn(union3)...done
loading eqn(union4)...done
 adding wave-rules for union1:..done
 adding wave-rules for union2:..done
 adding wave-rules for union3:..done
 adding wave-rules for union4:..............................done
 adding defeqn-record for union1...done 
 adding defeqn-record for union2...done 
 adding defeqn-record for union3...done 
 adding defeqn-record for union4...done 
loading thm(memunion2)...done
memunion2([])
==>x:pnat=>a:pnat list=>b:pnat list=>member(x,b)=>member(x,union(a,b))
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|memunion2([2])
|v0:pnat
|a:pnat list
|v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
|==>x:pnat=>b:pnat list=>member(\x/,\b/)=>member(\x/,union(``v0::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||memunion2([2,2])
||v2:member(v0,b)
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
||==>x:pnat=>member(\x/,\b/)=>member(\x/,union(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: wave([2,2],[union3,equ(left)])
|||memunion2([1,2,2])
|||v2:member(v0,b)
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
|||==>x:pnat=>member(\x/,\b/)=>member(\x/,union(a,\b/))
|||TERMINATING METHOD at depth 3: fertilize(strong(v1))
||memunion2([1,2])
||v2:member(v0,b)=>void
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
||==>x:pnat=>member(\x/,\b/)=>member(\x/,union(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: wave([2,2],[union4,equ(left)])
|||memunion2([1,1,2])
|||v2:member(v0,b)=>void
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
|||==>x:pnat=>member(\x/,\b/)=>member(\x/,``v0::{union(a,\b/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||memunion2([2,1,1,2])
||||v3:x=v0 in pnat
||||x:pnat
||||v2:member(v0,b)=>void
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
||||==>member(\x/,\b/)=>member(x,v0::union(a,b))
||||SELECTED METHOD at depth 4: equal(v3,right)
|||||memunion2([1,2,1,1,2])
|||||x:pnat
|||||v2:member(v0,b)=>void
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
|||||==>member(\v0/,\b/)=>member(v0,v0::union(a,b))
|||||TERMINATING METHOD at depth 5: elementary(...)
||||memunion2([1,1,1,2])
||||v3:x=v0 in pnat=>void
||||x:pnat
||||v2:member(v0,b)=>void
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
||||==>member(\x/,\b/)=>member(\x/,``v0::{union(a,\b/)}''<out>)
||||SELECTED METHOD at depth 4: wave([2],[member3,equ(left)])
|||||memunion2([1,1,1,1,2])
|||||v3:x=v0 in pnat=>void
|||||x:pnat
|||||v2:member(v0,b)=>void
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=>member(x,b)=>member(x,union(a,b)))
|||||==>member(\x/,\b/)=>member(\x/,union(a,\b/))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memunion2([1])
|a:pnat list
|==>x:pnat=>b:pnat list=>member(x,b)=>member(x,union(nil,b))
|SELECTED METHOD at depth 1: eval_def([2,2],union1)
||memunion2([1,1])
||a:pnat list
||==>x:pnat=>b:pnat list=>member(x,b)=>member(x,b)
||TERMINATING METHOD at depth 2: elementary(...)
Planning complete for memunion2

------------------------------------------------------------
memunion2:

[x:pnat,a:pnat list,b:pnat list]

|- member(x,b)=>member(x,union(a,b))

induction([v0::a],[a:pnat list]) then 
  [eval_def([2,2],union1) then 
     elementary(...),
   casesplit([[[member(v0,b)=>void],[member(v0,b)]],[]]) then 
     [wave([2,2],[union4,equ(left)]) then 
        casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
          [wave([2],[member3,equ(left)]) then 
             fertilize(strong(v1)),
           equal(v3,right) then 
             elementary(...)
          ],
      wave([2,2],[union3,equ(left)]) then 
        fertilize(strong(v1))
     ]
  ]


PLANNING for memunion2 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for union...done
deleting synth(union)...done
deleting def(union)...done
deleting theorem record for union1...done
deleting wave record for union1...done
deleting wave record for union1...done
deleting func_defeqn record for union1...done
deleting wave(union1)...done
deleting theorem record for union2...done
deleting wave record for union2...done
deleting wave record for union2...done
deleting func_defeqn record for union2...done
deleting wave(union2)...done
deleting theorem record for union3...done
deleting wave record for union3...done
deleting wave record for union3...done
deleting func_defeqn record for union3...done
deleting wave(union3)...done
deleting theorem record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting wave record for union4...done
deleting func_defeqn record for union4...done
deleting wave(union4)...done
deleting theorem record for memunion2...done
deleting thm(memunion2)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading synth(intersect)...done
loading synth(intersect)...done
loading def(intersect)...done
loading eqn(intersect1)...done
loading eqn(intersect2)...done
loading eqn(intersect3)...done
loading eqn(intersect4)...done
 adding wave-rules for intersect1:..done
 adding wave-rules for intersect2:..done
 adding wave-rules for intersect3:..............................done
 adding wave-rules for intersect4:..done
 adding defeqn-record for intersect1...done 
 adding defeqn-record for intersect2...done 
 adding defeqn-record for intersect3...done 
 adding defeqn-record for intersect4...done 
loading thm(memintersect)...done
memintersect([])
==>x:pnat=>a:pnat list=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b))
SELECTED METHOD at depth 0: induction([v0::a],[a:pnat list])
|memintersect([2])
|v0:pnat
|a:pnat list
|v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|==>x:pnat=>b:pnat list=> (member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,intersect(``v0::{a}''<out>,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||memintersect([2,2])
||v2:member(v0,b)
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||==>x:pnat=> (member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,intersect(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: wave([2,2],[intersect3,equ(left)])
|||memintersect([1,2,2])
|||v2:member(v0,b)
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||==>x:pnat=> (member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,``v0::{intersect(a,\b/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||memintersect([2,1,2,2])
||||v3:x=v0 in pnat
||||x:pnat
||||v2:member(v0,b)
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||==>(member(x,v0::a)#member(\x/,\b/))=>member(\x/,``v0::{intersect(a,\b/)}''<out>)
||||SELECTED METHOD at depth 4: equal(v3,right)
|||||memintersect([1,2,1,2,2])
|||||x:pnat
|||||v2:member(v0,b)
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||==>(member(v0,v0::a)#member(\v0/,\b/))=>member(\v0/,``v0::{intersect(a,\b/)}''<out>)
|||||SELECTED METHOD at depth 5: eval_def([1,1],member2)
||||||memintersect([1,1,2,1,2,2])
||||||x:pnat
||||||v2:member(v0,b)
||||||b:pnat list
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||||==>({true}#member(\v0/,\b/))=>member(\v0/,``v0::{intersect(a,\b/)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||||||memintersect([2,1,1,2,1,2,2])
|||||||v3:v0=v0 in pnat
|||||||x:pnat
|||||||v2:member(v0,b)
|||||||b:pnat list
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||||==>({true}#member(\v0/,\b/))=>member(v0,v0::intersect(a,b))
|||||||SELECTED METHOD at depth 7: eval_def([2],member2)
||||||||memintersect([1,2,1,1,2,1,2,2])
||||||||v3:v0=v0 in pnat
||||||||x:pnat
||||||||v2:member(v0,b)
||||||||b:pnat list
||||||||v0:pnat
||||||||a:pnat list
||||||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||||||==>({true}#member(\v0/,\b/))=>{true}
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||||memintersect([1,1,1,2,1,2,2])
|||||||v3:v0=v0 in pnat=>void
|||||||x:pnat
|||||||v2:member(v0,b)
|||||||b:pnat list
|||||||v0:pnat
|||||||a:pnat list
|||||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||||==>({true}#member(\v0/,\b/))=>member(\v0/,``v0::{intersect(a,\b/)}''<out>)
|||||||TERMINATING METHOD at depth 7: elementary(...)
||||memintersect([1,1,2,2])
||||v3:x=v0 in pnat=>void
||||x:pnat
||||v2:member(v0,b)
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||==>(member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,``v0::{intersect(a,\b/)}''<out>)
||||SELECTED METHOD at depth 4: wave([1,1],[member3,equ(left)])
|||||memintersect([1,1,1,2,2])
|||||v3:x=v0 in pnat=>void
|||||x:pnat
|||||v2:member(v0,b)
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||==>(member(\x/,a)#member(\x/,\b/))=>member(\x/,``v0::{intersect(a,\b/)}''<out>)
|||||SELECTED METHOD at depth 5: wave([2],[member3,equ(left)])
||||||memintersect([1,1,1,1,2,2])
||||||v3:x=v0 in pnat=>void
||||||x:pnat
||||||v2:member(v0,b)
||||||b:pnat list
||||||v0:pnat
||||||a:pnat list
||||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||||==>(member(\x/,a)#member(\x/,\b/))=>member(\x/,intersect(a,\b/))
||||||TERMINATING METHOD at depth 6: fertilize(strong(v1))
||memintersect([1,2])
||v2:member(v0,b)=>void
||b:pnat list
||v0:pnat
||a:pnat list
||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||==>x:pnat=> (member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,intersect(``v0::{a}''<out>,\b/))
||SELECTED METHOD at depth 2: wave([2,2],[intersect4,equ(left)])
|||memintersect([1,1,2])
|||v2:member(v0,b)=>void
|||b:pnat list
|||v0:pnat
|||a:pnat list
|||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||==>x:pnat=> (member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,intersect(a,\b/))

>>>>> INVOKING casesplit CRITIC <<<<<

||||memintersect([2,1,1,2])
||||v3:x=v0 in pnat
||||x:pnat
||||v2:member(v0,b)=>void
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||==>(member(x,v0::a)#member(\x/,\b/))=>member(\x/,intersect(a,\b/))
||||SELECTED METHOD at depth 4: equal(v3,right)
|||||memintersect([1,2,1,1,2])
|||||x:pnat
|||||v2:member(v0,b)=>void
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||==>(member(v0,v0::a)#member(\v0/,\b/))=>member(\v0/,intersect(a,\b/))
|||||TERMINATING METHOD at depth 5: elementary(...)
||||memintersect([1,1,1,2])
||||v3:x=v0 in pnat=>void
||||x:pnat
||||v2:member(v0,b)=>void
||||b:pnat list
||||v0:pnat
||||a:pnat list
||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
||||==>(member(\x/,``v0::{a}''<out>)#member(\x/,\b/))=>member(\x/,intersect(a,\b/))
||||SELECTED METHOD at depth 4: wave([1,1],[member3,equ(left)])
|||||memintersect([1,1,1,1,2])
|||||v3:x=v0 in pnat=>void
|||||x:pnat
|||||v2:member(v0,b)=>void
|||||b:pnat list
|||||v0:pnat
|||||a:pnat list
|||||v1:ih(x:pnat=>b:pnat list=> (member(x,a)#member(x,b))=>member(x,intersect(a,b)))
|||||==>(member(\x/,a)#member(\x/,\b/))=>member(\x/,intersect(a,\b/))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memintersect([1])
|a:pnat list
|==>x:pnat=>b:pnat list=> (member(x,nil)#member(x,b))=>member(x,intersect(nil,b))
|SELECTED METHOD at depth 1: eval_def([2,2],intersect1)
||memintersect([1,1])
||a:pnat list
||==>x:pnat=>b:pnat list=> (member(x,nil)#member(x,b))=>member(x,nil)
||TERMINATING METHOD at depth 2: elementary(...)
Planning complete for memintersect

------------------------------------------------------------
memintersect:

[x:pnat,a:pnat list,b:pnat list]

|- (member(x,a)#member(x,b))=>member(x,intersect(a,b))

induction([v0::a],[a:pnat list]) then 
  [eval_def([2,2],intersect1) then 
     elementary(...),
   casesplit([[[member(v0,b)=>void],[member(v0,b)]],[]]) then 
     [wave([2,2],[intersect4,equ(left)]) then 
        casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
          [wave([1,1],[member3,equ(left)]) then 
             fertilize(strong(v1)),
           equal(v3,right) then 
             elementary(...)
          ],
      wave([2,2],[intersect3,equ(left)]) then 
        casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
          [wave([1,1],[member3,equ(left)]) then 
             wave([2],[member3,equ(left)]) then 
               fertilize(strong(v1)),
           equal(v3,right) then 
             eval_def([1,1],member2) then 
               casesplit([[[v0=v0 in pnat=>void]],[[v0=v0 in pnat]]]) then 
                 [elementary(...),
                  eval_def([2],member2) then 
                    elementary(...)
                 ]
          ]
     ]
  ]


PLANNING for memintersect COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
deleting theorem record for intersect...done
deleting synth(intersect)...done
deleting def(intersect)...done
deleting theorem record for intersect1...done
deleting wave record for intersect1...done
deleting wave record for intersect1...done
deleting func_defeqn record for intersect1...done
deleting wave(intersect1)...done
deleting theorem record for intersect2...done
deleting wave record for intersect2...done
deleting wave record for intersect2...done
deleting func_defeqn record for intersect2...done
deleting wave(intersect2)...done
deleting theorem record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting wave record for intersect3...done
deleting func_defeqn record for intersect3...done
deleting wave(intersect3)...done
deleting theorem record for intersect4...done
deleting wave record for intersect4...done
deleting wave record for intersect4...done
deleting func_defeqn record for intersect4...done
deleting wave(intersect4)...done
deleting theorem record for memintersect...done
deleting thm(memintersect)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading lemma(decless2)...done
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading thm(memins)...done
memins([])
==>x:pnat=>y:pnat list=>member(x,insert(x,y))
SELECTED METHOD at depth 0: induction([v0::y],[y:pnat list])
|memins([2])
|v0:pnat
|y:pnat list
|v1:ih(x:pnat=>member(x,insert(x,y)))
|==>x:pnat=>member(\x/,insert(\x/,``v0::{y}''<out>))

>>>>> INVOKING casesplit CRITIC <<<<<

||memins([2,2])
||v2:x<v0
||x:pnat
||v0:pnat
||y:pnat list
||v1:ih(x:pnat=>member(x,insert(x,y)))
||==>member(\x/,insert(x,v0::y))
||SELECTED METHOD at depth 2: eval_def([2],insert2)
|||memins([1,2,2])
|||v2:x<v0
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>member(x,insert(x,y)))
|||==>member(\x/,x::v0::y)
|||SELECTED METHOD at depth 3: eval_def([],member2)
||||memins([1,1,2,2])
||||v2:x<v0
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>member(x,insert(x,y)))
||||==>{true}
||||TERMINATING METHOD at depth 4: elementary(...)
||memins([1,2])
||v2:x<v0=>void
||x:pnat
||v0:pnat
||y:pnat list
||v1:ih(x:pnat=>member(x,insert(x,y)))
||==>member(\x/,insert(\x/,``v0::{y}''<out>))
||SELECTED METHOD at depth 2: wave([2],[insert3,equ(left)])
|||memins([1,1,2])
|||v2:x<v0=>void
|||x:pnat
|||v0:pnat
|||y:pnat list
|||v1:ih(x:pnat=>member(x,insert(x,y)))
|||==>member(\x/,``v0::{insert(\x/,y)}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

||||memins([2,1,1,2])
||||v3:x=v0 in pnat
||||v2:x<v0=>void
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>member(x,insert(x,y)))
||||==>member(x,v0::insert(x,y))
||||SELECTED METHOD at depth 4: equal(v3,right)
|||||memins([1,2,1,1,2])
|||||v2:x<v0=>void
|||||x:pnat
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat=>member(x,insert(x,y)))
|||||==>member(v0,v0::insert(v0,y))
|||||SELECTED METHOD at depth 5: eval_def([],member2)
||||||memins([1,1,2,1,1,2])
||||||v2:x<v0=>void
||||||x:pnat
||||||v0:pnat
||||||y:pnat list
||||||v1:ih(x:pnat=>member(x,insert(x,y)))
||||||==>{true}
||||||TERMINATING METHOD at depth 6: elementary(...)
||||memins([1,1,1,2])
||||v3:x=v0 in pnat=>void
||||v2:x<v0=>void
||||x:pnat
||||v0:pnat
||||y:pnat list
||||v1:ih(x:pnat=>member(x,insert(x,y)))
||||==>member(\x/,``v0::{insert(\x/,y)}''<out>)
||||SELECTED METHOD at depth 4: wave([],[member3,equ(left)])
|||||memins([1,1,1,1,2])
|||||v3:x=v0 in pnat=>void
|||||v2:x<v0=>void
|||||x:pnat
|||||v0:pnat
|||||y:pnat list
|||||v1:ih(x:pnat=>member(x,insert(x,y)))
|||||==>member(\x/,insert(\x/,y))
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memins([1])
|y:pnat list
|==>x:pnat=>member(x,insert(x,nil))
|SELECTED METHOD at depth 1: eval_def([2],insert1)
||memins([1,1])
||y:pnat list
||==>x:pnat=>member(x,x::nil)
||SELECTED METHOD at depth 2: eval_def([],member2)
|||memins([1,1,1])
|||y:pnat list
|||==>x:pnat=>{true}
|||TERMINATING METHOD at depth 3: elementary(...)
Planning complete for memins

------------------------------------------------------------
memins:

[x:pnat,y:pnat list]

|- member(x,insert(x,y))

induction([v0::y],[y:pnat list]) then 
  [eval_def([2],insert1) then 
     eval_def([],member2) then 
       elementary(...),
   casesplit([[[x<v0=>void]],[[x<v0]]]) then 
     [wave([2],[insert3,equ(left)]) then 
        casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
          [wave([],[member3,equ(left)]) then 
             fertilize(strong(v1)),
           equal(v3,right) then 
             eval_def([],member2) then 
               elementary(...)
          ],
      eval_def([2],insert2) then 
        eval_def([],member2) then 
          elementary(...)
     ]
  ]


PLANNING for memins COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
deleting theorem record for memins...done
deleting thm(memins)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading thm(meminsert1)...done
meminsert1([])
==>a:pnat=>b:pnat=>l:pnat list=>a=b in pnat=>member(a,insert(b,l))={true}in u(1)
SELECTED METHOD at depth 0: normal(imply_intro(v0))
|meminsert1([1])
|v0:a=b in pnat
|a:pnat
|b:pnat
|l:pnat list
|==>member(a,insert(b,l))={true}in u(1)
|SELECTED METHOD at depth 1: equal(v0,left)
||meminsert1([1,1])
||a:pnat
||b:pnat
||l:pnat list
||==>member(a,insert(a,l))={true}in u(1)
||SELECTED METHOD at depth 2: induction([v0::l],[l:pnat list])
|||meminsert1([2,1,1])
|||v0:pnat
|||l:pnat list
|||v1:ih(member(a,insert(a,l))={true}in u(1))
|||a:pnat
|||b:pnat
|||l:pnat list
|||==>member(a,insert(a,``v0::{l}''<out>))={true}in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

||||meminsert1([2,2,1,1])
||||v2:a<v0
||||v0:pnat
||||l:pnat list
||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,insert(a,v0::l))={true}in u(1)
||||SELECTED METHOD at depth 4: eval_def([2,1,1],insert2)
|||||meminsert1([1,2,2,1,1])
|||||v2:a<v0
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(member(a,insert(a,l))={true}in u(1))
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,a::v0::l)={true}in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],member2)
||||||meminsert1([1,1,2,2,1,1])
||||||v2:a<v0
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>{true}={true}in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
||||meminsert1([1,2,1,1])
||||v2:a<v0=>void
||||v0:pnat
||||l:pnat list
||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,insert(a,``v0::{l}''<out>))={true}in u(1)
||||SELECTED METHOD at depth 4: wave([2,1,1],[insert3,equ(left)])
|||||meminsert1([1,1,2,1,1])
|||||v2:a<v0=>void
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(member(a,insert(a,l))={true}in u(1))
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,``v0::{insert(a,l)}''<out>)={true}in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||meminsert1([2,1,1,2,1,1])
||||||v3:a=v0 in pnat
||||||v2:a<v0=>void
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,v0::insert(a,l))={true}in u(1)
||||||SELECTED METHOD at depth 6: equal(v3,left)
|||||||meminsert1([1,2,1,1,2,1,1])
|||||||v2:a<v0=>void
|||||||v0:pnat
|||||||l:pnat list
|||||||v1:ih(member(a,insert(a,l))={true}in u(1))
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,a::insert(a,l))={true}in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1],member2)
||||||||meminsert1([1,1,2,1,1,2,1,1])
||||||||v2:a<v0=>void
||||||||v0:pnat
||||||||l:pnat list
||||||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||||||a:pnat
||||||||b:pnat
||||||||l:pnat list
||||||||==>{true}={true}in u(1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
||||||meminsert1([1,1,1,2,1,1])
||||||v3:a=v0 in pnat=>void
||||||v2:a<v0=>void
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(member(a,insert(a,l))={true}in u(1))
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,``v0::{insert(a,l)}''<out>)={true}in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[member3,equ(left)])
|||||||meminsert1([1,1,1,1,2,1,1])
|||||||v3:a=v0 in pnat=>void
|||||||v2:a<v0=>void
|||||||v0:pnat
|||||||l:pnat list
|||||||v1:ih(member(a,insert(a,l))={true}in u(1))
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,insert(a,l))={true}in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v1))
|||meminsert1([1,1,1])
|||l:pnat list
|||a:pnat
|||b:pnat
|||l:pnat list
|||==>member(a,insert(a,nil))={true}in u(1)
|||SELECTED METHOD at depth 3: eval_def([2,1,1],insert1)
||||meminsert1([1,1,1,1])
||||l:pnat list
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,a::nil)={true}in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1],member2)
|||||meminsert1([1,1,1,1,1])
|||||l:pnat list
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>{true}={true}in u(1)
|||||TERMINATING METHOD at depth 5: elementary(...)
Planning complete for meminsert1

------------------------------------------------------------
meminsert1:

[a:pnat,b:pnat,l:pnat list]

|- a=b in pnat=>member(a,insert(b,l))={true}in u(1)

normal(imply_intro(v0)) then 
  equal(v0,left) then 
    induction([v0::l],[l:pnat list]) then 
      [eval_def([2,1,1],insert1) then 
         eval_def([1,1],member2) then 
           elementary(...),
       casesplit([[[a<v0=>void]],[[a<v0]]]) then 
         [wave([2,1,1],[insert3,equ(left)]) then 
            casesplit([[[a=v0 in pnat=>void]],[[a=v0 in pnat]]]) then 
              [wave([1,1],[member3,equ(left)]) then 
                 fertilize(strong(v1)),
               equal(v3,left) then 
                 eval_def([1,1],member2) then 
                   elementary(...)
              ],
          eval_def([2,1,1],insert2) then 
            eval_def([1,1],member2) then 
              elementary(...)
         ]
      ]


PLANNING for meminsert1 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
deleting theorem record for meminsert1...done
deleting thm(meminsert1)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading thm(meminsert2)...done
meminsert2([])
==>a:pnat=>b:pnat=>l:pnat list=> (a=b in pnat=>void)=>member(a,insert(b,l))=member(a,l)in u(1)
SELECTED METHOD at depth 0: normal(imply_intro(v0))
|meminsert2([1])
|v0:a=b in pnat=>void
|a:pnat
|b:pnat
|l:pnat list
|==>member(a,insert(b,l))=member(a,l)in u(1)
|SELECTED METHOD at depth 1: induction([v1::l],[l:pnat list])
||meminsert2([2,1])
||v1:pnat
||l:pnat list
||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||v0:a=b in pnat=>void
||a:pnat
||b:pnat
||l:pnat list
||==>member(a,insert(b,``v1::{l}''<out>))=member(a,``v1::{l}''<out>)in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

|||meminsert2([2,2,1])
|||v3:a=v1 in pnat
|||v1:pnat
|||l:pnat list
|||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||v0:a=b in pnat=>void
|||a:pnat
|||b:pnat
|||l:pnat list
|||==>member(a,insert(b,``v1::{l}''<out>))=member(a,v1::l)in u(1)
|||SELECTED METHOD at depth 3: equal(v3,left)
||||meminsert2([1,2,2,1])
||||v1:pnat
||||l:pnat list
||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||v0:a=b in pnat=>void
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,insert(b,``a::{l}''<out>))=member(a,a::l)in u(1)
||||SELECTED METHOD at depth 4: eval_def([2,1],member2)
|||||meminsert2([1,1,2,2,1])
|||||v1:pnat
|||||l:pnat list
|||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||v0:a=b in pnat=>void
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,insert(b,``a::{l}''<out>))={true}in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||meminsert2([2,1,1,2,2,1])
||||||v3:b<a
||||||v1:pnat
||||||l:pnat list
||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||v0:a=b in pnat=>void
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,insert(b,a::l))={true}in u(1)
||||||SELECTED METHOD at depth 6: eval_def([2,1,1],insert2)
|||||||meminsert2([1,2,1,1,2,2,1])
|||||||v3:b<a
|||||||v1:pnat
|||||||l:pnat list
|||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||v0:a=b in pnat=>void
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,b::a::l)={true}in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1],member3)
||||||||meminsert2([1,1,2,1,1,2,2,1])
||||||||v3:b<a
||||||||v1:pnat
||||||||l:pnat list
||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||||v0:a=b in pnat=>void
||||||||a:pnat
||||||||b:pnat
||||||||l:pnat list
||||||||==>member(a,a::l)={true}in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],member2)
|||||||||meminsert2([1,1,1,2,1,1,2,2,1])
|||||||||v3:b<a
|||||||||v1:pnat
|||||||||l:pnat list
|||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||||v0:a=b in pnat=>void
|||||||||a:pnat
|||||||||b:pnat
|||||||||l:pnat list
|||||||||==>{true}={true}in u(1)
|||||||||TERMINATING METHOD at depth 9: elementary(...)
||||||meminsert2([1,1,1,2,2,1])
||||||v3:b<a=>void
||||||v1:pnat
||||||l:pnat list
||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||v0:a=b in pnat=>void
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,insert(b,``a::{l}''<out>))={true}in u(1)
||||||SELECTED METHOD at depth 6: wave([2,1,1],[insert3,equ(left)])
|||||||meminsert2([1,1,1,1,2,2,1])
|||||||v3:b<a=>void
|||||||v1:pnat
|||||||l:pnat list
|||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||v0:a=b in pnat=>void
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,``a::{insert(b,l)}''<out>)={true}in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

||||||||meminsert2([2,1,1,1,1,2,2,1])
||||||||v4:a=a in pnat
||||||||v3:b<a=>void
||||||||v1:pnat
||||||||l:pnat list
||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||||v0:a=b in pnat=>void
||||||||a:pnat
||||||||b:pnat
||||||||l:pnat list
||||||||==>member(a,a::insert(b,l))={true}in u(1)
||||||||SELECTED METHOD at depth 8: eval_def([1,1],member2)
|||||||||meminsert2([1,2,1,1,1,1,2,2,1])
|||||||||v4:a=a in pnat
|||||||||v3:b<a=>void
|||||||||v1:pnat
|||||||||l:pnat list
|||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||||v0:a=b in pnat=>void
|||||||||a:pnat
|||||||||b:pnat
|||||||||l:pnat list
|||||||||==>{true}={true}in u(1)
|||||||||TERMINATING METHOD at depth 9: elementary(...)
||||||||meminsert2([1,1,1,1,1,2,2,1])
||||||||v4:a=a in pnat=>void
||||||||v3:b<a=>void
||||||||v1:pnat
||||||||l:pnat list
||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||||v0:a=b in pnat=>void
||||||||a:pnat
||||||||b:pnat
||||||||l:pnat list
||||||||==>member(a,``a::{insert(b,l)}''<out>)={true}in u(1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||meminsert2([1,2,1])
|||v3:a=v1 in pnat=>void
|||v1:pnat
|||l:pnat list
|||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||v0:a=b in pnat=>void
|||a:pnat
|||b:pnat
|||l:pnat list
|||==>member(a,insert(b,``v1::{l}''<out>))=member(a,``v1::{l}''<out>)in u(1)
|||SELECTED METHOD at depth 3: wave([2,1],[member3,equ(left)])
||||meminsert2([1,1,2,1])
||||v3:a=v1 in pnat=>void
||||v1:pnat
||||l:pnat list
||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||v0:a=b in pnat=>void
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,insert(b,``v1::{l}''<out>))=member(a,l)in u(1)

>>>>> INVOKING casesplit CRITIC <<<<<

|||||meminsert2([2,1,1,2,1])
|||||v4:b<v1
|||||v3:a=v1 in pnat=>void
|||||v1:pnat
|||||l:pnat list
|||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||v0:a=b in pnat=>void
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,insert(b,v1::l))=member(a,l)in u(1)
|||||SELECTED METHOD at depth 5: eval_def([2,1,1],insert2)
||||||meminsert2([1,2,1,1,2,1])
||||||v4:b<v1
||||||v3:a=v1 in pnat=>void
||||||v1:pnat
||||||l:pnat list
||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||v0:a=b in pnat=>void
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,b::v1::l)=member(a,l)in u(1)
||||||SELECTED METHOD at depth 6: eval_def([1,1],member3)
|||||||meminsert2([1,1,2,1,1,2,1])
|||||||v4:b<v1
|||||||v3:a=v1 in pnat=>void
|||||||v1:pnat
|||||||l:pnat list
|||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||v0:a=b in pnat=>void
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,v1::l)=member(a,l)in u(1)
|||||||SELECTED METHOD at depth 7: eval_def([1,1],member3)
||||||||meminsert2([1,1,1,2,1,1,2,1])
||||||||v4:b<v1
||||||||v3:a=v1 in pnat=>void
||||||||v1:pnat
||||||||l:pnat list
||||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||||v0:a=b in pnat=>void
||||||||a:pnat
||||||||b:pnat
||||||||l:pnat list
||||||||==>member(a,l)=member(a,l)in u(1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||meminsert2([1,1,1,2,1])
|||||v4:b<v1=>void
|||||v3:a=v1 in pnat=>void
|||||v1:pnat
|||||l:pnat list
|||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||v0:a=b in pnat=>void
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,insert(b,``v1::{l}''<out>))=member(a,l)in u(1)
|||||SELECTED METHOD at depth 5: wave([2,1,1],[insert3,equ(left)])
||||||meminsert2([1,1,1,1,2,1])
||||||v4:b<v1=>void
||||||v3:a=v1 in pnat=>void
||||||v1:pnat
||||||l:pnat list
||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
||||||v0:a=b in pnat=>void
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>member(a,``v1::{insert(b,l)}''<out>)=member(a,l)in u(1)
||||||SELECTED METHOD at depth 6: wave([1,1],[member3,equ(left)])
|||||||meminsert2([1,1,1,1,1,2,1])
|||||||v4:b<v1=>void
|||||||v3:a=v1 in pnat=>void
|||||||v1:pnat
|||||||l:pnat list
|||||||v2:ih(member(a,insert(b,l))=member(a,l)in u(1))
|||||||v0:a=b in pnat=>void
|||||||a:pnat
|||||||b:pnat
|||||||l:pnat list
|||||||==>member(a,insert(b,l))=member(a,l)in u(1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v2))
||meminsert2([1,1])
||l:pnat list
||v0:a=b in pnat=>void
||a:pnat
||b:pnat
||l:pnat list
||==>member(a,insert(b,nil))=member(a,nil)in u(1)
||SELECTED METHOD at depth 2: eval_def([2,1],member1)
|||meminsert2([1,1,1])
|||l:pnat list
|||v0:a=b in pnat=>void
|||a:pnat
|||b:pnat
|||l:pnat list
|||==>member(a,insert(b,nil))=void in u(1)
|||SELECTED METHOD at depth 3: eval_def([2,1,1],insert1)
||||meminsert2([1,1,1,1])
||||l:pnat list
||||v0:a=b in pnat=>void
||||a:pnat
||||b:pnat
||||l:pnat list
||||==>member(a,b::nil)=void in u(1)
||||SELECTED METHOD at depth 4: eval_def([1,1],member3)
|||||meminsert2([1,1,1,1,1])
|||||l:pnat list
|||||v0:a=b in pnat=>void
|||||a:pnat
|||||b:pnat
|||||l:pnat list
|||||==>member(a,nil)=void in u(1)
|||||SELECTED METHOD at depth 5: eval_def([1,1],member1)
||||||meminsert2([1,1,1,1,1,1])
||||||l:pnat list
||||||v0:a=b in pnat=>void
||||||a:pnat
||||||b:pnat
||||||l:pnat list
||||||==>void=void in u(1)
||||||TERMINATING METHOD at depth 6: elementary(...)
Planning complete for meminsert2

------------------------------------------------------------
meminsert2:

[a:pnat,b:pnat,l:pnat list]

|- (a=b in pnat=>void)=>member(a,insert(b,l))=member(a,l)in u(1)

normal(imply_intro(v0)) then 
  induction([v1::l],[l:pnat list]) then 
    [eval_def([2,1],member1) then 
       eval_def([2,1,1],insert1) then 
         eval_def([1,1],member3) then 
           eval_def([1,1],member1) then 
             elementary(...),
     casesplit([[[a=v1 in pnat=>void]],[[a=v1 in pnat]]]) then 
       [wave([2,1],[member3,equ(left)]) then 
          casesplit([[[b<v1=>void]],[[b<v1]]]) then 
            [wave([2,1,1],[insert3,equ(left)]) then 
               wave([1,1],[member3,equ(left)]) then 
                 fertilize(strong(v2)),
             eval_def([2,1,1],insert2) then 
               eval_def([1,1],member3) then 
                 eval_def([1,1],member3) then 
                   elementary(...)
            ],
        equal(v3,left) then 
          eval_def([2,1],member2) then 
            casesplit([[[b<a=>void]],[[b<a]]]) then 
              [wave([2,1,1],[insert3,equ(left)]) then 
                 casesplit([[[a=a in pnat=>void]],[[a=a in pnat]]]) then 
                   [elementary(...),
                    eval_def([1,1],member2) then 
                      elementary(...)
                   ],
               eval_def([2,1,1],insert2) then 
                 eval_def([1,1],member3) then 
                   eval_def([1,1],member2) then 
                     elementary(...)
              ]
       ]
    ]


PLANNING for meminsert2 COMPLETE. 

deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
deleting theorem record for meminsert2...done
deleting thm(meminsert2)...done
loading def(true)...done
loading synth(member)...done
loading def(member)...done
loading eqn(member1)...done
loading eqn(member2)...done
loading eqn(member3)...done
 adding wave-rules for member1:done
 adding wave-rules for member2:done
 adding wave-rules for member3:..done
 adding defeqn-record for member1...done 
 adding defeqn-record for member2...done 
 adding defeqn-record for member3...done 
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading def(sort)...done
loading eqn(sort1)...done
loading eqn(sort2)...done
 adding wave-rules for sort1:..done
 adding wave-rules for sort2:..............done
 adding defeqn-record for sort1...done 
 adding defeqn-record for sort2...done 
loading thm(memsort1)...done
memsort1([])
==>x:pnat=>l:pnat list=>member(x,sort(l))=>member(x,l)
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|memsort1([2])
|v0:pnat
|l:pnat list
|v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
|==>x:pnat=>member(\x/,sort(``v0::{l}''<out>))=>member(\x/,``v0::{l}''<out>)
|SELECTED METHOD at depth 1: wave([2,1],[sort2,equ(left)])
||memsort1([1,2])
||v0:pnat
||l:pnat list
||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
||==>x:pnat=>member(\x/,``insert(v0,{sort(l)})''<out>)=>member(\x/,``v0::{l}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||memsort1([2,1,2])
|||v2:x=v0 in pnat
|||x:pnat
|||v0:pnat
|||l:pnat list
|||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
|||==>member(\x/,``insert(v0,{sort(l)})''<out>)=>member(x,v0::l)
|||SELECTED METHOD at depth 3: equal(v2,right)
||||memsort1([1,2,1,2])
||||x:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
||||==>member(\v0/,``insert(v0,{sort(l)})''<out>)=>member(v0,v0::l)
||||SELECTED METHOD at depth 4: eval_def([2],member2)
|||||memsort1([1,1,2,1,2])
|||||x:pnat
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
|||||==>member(\v0/,``insert(v0,{sort(l)})''<out>)=>{true}
|||||TERMINATING METHOD at depth 5: elementary(...)
|||memsort1([1,1,2])
|||v2:x=v0 in pnat=>void
|||x:pnat
|||v0:pnat
|||l:pnat list
|||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
|||==>member(\x/,``insert(v0,{sort(l)})''<out>)=>member(\x/,``v0::{l}''<out>)
|||SELECTED METHOD at depth 3: wave([2],[member3,equ(left)])
||||memsort1([1,1,1,2])
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
||||==>member(\x/,``insert(v0,{sort(l)})''<out>)=>member(\x/,l)

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,x:pnat]

|- (x=v0 in pnat=>void)=>member(x,insert(v0,v1))=>member(x,v1)

saving thm(lemma1)...done
lemma1([])
==>v0:pnat=>v1:pnat list=>x:pnat=> (x=v0 in pnat=>void)=>member(x,insert(v0,v1))=>member(x,v1)
SELECTED METHOD at depth 0: normal(imply_intro(v2))
|lemma1([1])
|v2:x=v0 in pnat=>void
|v0:pnat
|v1:pnat list
|x:pnat
|==>member(x,insert(v0,v1))=>member(x,v1)
|SELECTED METHOD at depth 1: induction([v3::v1],[v1:pnat list])
||lemma1([2,1])
||v3:pnat
||v1:pnat list
||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||v2:x=v0 in pnat=>void
||v0:pnat
||v1:pnat list
||x:pnat
||==>member(x,insert(v0,``v3::{v1}''<out>))=>member(x,``v3::{v1}''<out>)

>>>>> INVOKING casesplit CRITIC <<<<<

|||lemma1([2,2,1])
|||v5:x=v3 in pnat
|||v3:pnat
|||v1:pnat list
|||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||v2:x=v0 in pnat=>void
|||v0:pnat
|||v1:pnat list
|||x:pnat
|||==>member(x,insert(v0,``v3::{v1}''<out>))=>member(x,v3::v1)
|||SELECTED METHOD at depth 3: equal(v5,right)
||||lemma1([1,2,2,1])
||||v3:pnat
||||v1:pnat list
||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||||v2:x=v0 in pnat=>void
||||v0:pnat
||||v1:pnat list
||||x:pnat
||||==>member(v3,insert(v0,``v3::{v1}''<out>))=>member(v3,v3::v1)
||||SELECTED METHOD at depth 4: eval_def([2],member2)
|||||lemma1([1,1,2,2,1])
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||||v2:x=v0 in pnat=>void
|||||v0:pnat
|||||v1:pnat list
|||||x:pnat
|||||==>member(v3,insert(v0,``v3::{v1}''<out>))=>{true}
|||||TERMINATING METHOD at depth 5: elementary(...)
|||lemma1([1,2,1])
|||v5:x=v3 in pnat=>void
|||v3:pnat
|||v1:pnat list
|||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||v2:x=v0 in pnat=>void
|||v0:pnat
|||v1:pnat list
|||x:pnat
|||==>member(x,insert(v0,``v3::{v1}''<out>))=>member(x,``v3::{v1}''<out>)
|||SELECTED METHOD at depth 3: wave([2],[member3,equ(left)])
||||lemma1([1,1,2,1])
||||v5:x=v3 in pnat=>void
||||v3:pnat
||||v1:pnat list
||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||||v2:x=v0 in pnat=>void
||||v0:pnat
||||v1:pnat list
||||x:pnat
||||==>member(x,insert(v0,``v3::{v1}''<out>))=>member(x,v1)

>>>>> INVOKING casesplit CRITIC <<<<<

|||||lemma1([2,1,1,2,1])
|||||v6:v0<v3
|||||v5:x=v3 in pnat=>void
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||||v2:x=v0 in pnat=>void
|||||v0:pnat
|||||v1:pnat list
|||||x:pnat
|||||==>member(x,insert(v0,v3::v1))=>member(x,v1)
|||||SELECTED METHOD at depth 5: eval_def([2,1],insert2)
||||||lemma1([1,2,1,1,2,1])
||||||v6:v0<v3
||||||v5:x=v3 in pnat=>void
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||||||v2:x=v0 in pnat=>void
||||||v0:pnat
||||||v1:pnat list
||||||x:pnat
||||||==>member(x,v0::v3::v1)=>member(x,v1)
||||||SELECTED METHOD at depth 6: eval_def([1],member3)
|||||||lemma1([1,1,2,1,1,2,1])
|||||||v6:v0<v3
|||||||v5:x=v3 in pnat=>void
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||||||v2:x=v0 in pnat=>void
|||||||v0:pnat
|||||||v1:pnat list
|||||||x:pnat
|||||||==>member(x,v3::v1)=>member(x,v1)
|||||||SELECTED METHOD at depth 7: eval_def([1],member3)
||||||||lemma1([1,1,1,2,1,1,2,1])
||||||||v6:v0<v3
||||||||v5:x=v3 in pnat=>void
||||||||v3:pnat
||||||||v1:pnat list
||||||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||||||||v2:x=v0 in pnat=>void
||||||||v0:pnat
||||||||v1:pnat list
||||||||x:pnat
||||||||==>member(x,v1)=>member(x,v1)
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||lemma1([1,1,1,2,1])
|||||v6:v0<v3=>void
|||||v5:x=v3 in pnat=>void
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||||v2:x=v0 in pnat=>void
|||||v0:pnat
|||||v1:pnat list
|||||x:pnat
|||||==>member(x,insert(v0,``v3::{v1}''<out>))=>member(x,v1)
|||||SELECTED METHOD at depth 5: wave([2,1],[insert3,equ(left)])
||||||lemma1([1,1,1,1,2,1])
||||||v6:v0<v3=>void
||||||v5:x=v3 in pnat=>void
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
||||||v2:x=v0 in pnat=>void
||||||v0:pnat
||||||v1:pnat list
||||||x:pnat
||||||==>member(x,``v3::{insert(v0,v1)}''<out>)=>member(x,v1)
||||||SELECTED METHOD at depth 6: wave([1],[member3,equ(left)])
|||||||lemma1([1,1,1,1,1,2,1])
|||||||v6:v0<v3=>void
|||||||v5:x=v3 in pnat=>void
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(member(x,insert(v0,v1))=>member(x,v1))
|||||||v2:x=v0 in pnat=>void
|||||||v0:pnat
|||||||v1:pnat list
|||||||x:pnat
|||||||==>member(x,insert(v0,v1))=>member(x,v1)
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v4))
||lemma1([1,1])
||v1:pnat list
||v2:x=v0 in pnat=>void
||v0:pnat
||v1:pnat list
||x:pnat
||==>member(x,insert(v0,nil))=>member(x,nil)
||SELECTED METHOD at depth 2: eval_def([2],member1)
|||lemma1([1,1,1])
|||v1:pnat list
|||v2:x=v0 in pnat=>void
|||v0:pnat
|||v1:pnat list
|||x:pnat
|||==>member(x,insert(v0,nil))=>void
|||SELECTED METHOD at depth 3: eval_def([2,1],insert1)
||||lemma1([1,1,1,1])
||||v1:pnat list
||||v2:x=v0 in pnat=>void
||||v0:pnat
||||v1:pnat list
||||x:pnat
||||==>member(x,v0::nil)=>void
||||SELECTED METHOD at depth 4: eval_def([1],member3)
|||||lemma1([1,1,1,1,1])
|||||v1:pnat list
|||||v2:x=v0 in pnat=>void
|||||v0:pnat
|||||v1:pnat list
|||||x:pnat
|||||==>member(x,nil)=>void
|||||SELECTED METHOD at depth 5: eval_def([1],member1)
||||||lemma1([1,1,1,1,1,1])
||||||v1:pnat list
||||||v2:x=v0 in pnat=>void
||||||v0:pnat
||||||v1:pnat list
||||||x:pnat
||||||==>void=>void
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma1:..done
||||memsort1([1,1,1,2])
||||v2:x=v0 in pnat=>void
||||x:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
||||==>member(\x/,``insert(v0,{sort(l)})''<out>)=>member(\x/,l)
||||SELECTED METHOD at depth 4: wave([1],[lemma1,imp(left)])
|||||memsort1([1,1,1,1,2])
|||||v2:x=v0 in pnat=>void
|||||x:pnat
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(x:pnat=>member(x,sort(l))=>member(x,l))
|||||==>member(\x/,sort(l))=>member(\x/,l)
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|memsort1([1])
|l:pnat list
|==>x:pnat=>member(x,sort(nil))=>member(x,nil)
|SELECTED METHOD at depth 1: eval_def([2],member1)
||memsort1([1,1])
||l:pnat list
||==>x:pnat=>member(x,sort(nil))=>void
||SELECTED METHOD at depth 2: eval_def([2,1],sort1)
|||memsort1([1,1,1])
|||l:pnat list
|||==>x:pnat=>member(x,nil)=>void
|||SELECTED METHOD at depth 3: eval_def([1],member1)
||||memsort1([1,1,1,1])
||||l:pnat list
||||==>x:pnat=>void=>void
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for memsort1

------------------------------------------------------------
memsort1:

[x:pnat,l:pnat list]

|- member(x,sort(l))=>member(x,l)

induction([v0::l],[l:pnat list]) then 
  [eval_def([2],member1) then 
     eval_def([2,1],sort1) then 
       eval_def([1],member1) then 
         elementary(...),
   wave([2,1],[sort2,equ(left)]) then 
     casesplit([[[x=v0 in pnat=>void]],[[x=v0 in pnat]]]) then 
       [wave([2],[member3,equ(left)]) then 
          wave([1],[lemma1,imp(left)]) then 
            fertilize(strong(v1)),
        equal(v2,right) then 
          eval_def([2],member2) then 
            elementary(...)
       ]
  ]

------------------------------------------------------------
lemma1:

[v0:pnat,v1:pnat list,x:pnat]

|- (x=v0 in pnat=>void)=>member(x,insert(v0,v1))=>member(x,v1)

normal(imply_intro(v2)) then 
  induction([v3::v1],[v1:pnat list]) then 
    [eval_def([2],member1) then 
       eval_def([2,1],insert1) then 
         eval_def([1],member3) then 
           eval_def([1],member1) then 
             elementary(...),
     casesplit([[[x=v3 in pnat=>void]],[[x=v3 in pnat]]]) then 
       [wave([2],[member3,equ(left)]) then 
          casesplit([[[v0<v3=>void]],[[v0<v3]]]) then 
            [wave([2,1],[insert3,equ(left)]) then 
               wave([1],[member3,equ(left)]) then 
                 fertilize(strong(v4)),
             eval_def([2,1],insert2) then 
               eval_def([1],member3) then 
                 eval_def([1],member3) then 
                   elementary(...)
            ],
        equal(v5,right) then 
          eval_def([2],member2) then 
            elementary(...)
       ]
    ]


PLANNING for memsort1 COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for member...done
deleting synth(member)...done
deleting def(member)...done
deleting theorem record for member3...done
deleting wave record for member3...done
deleting wave record for member3...done
deleting func_defeqn record for member3...done
deleting wave(member3)...done
CLaM WARNING: synth(true) not present, so cannot be deleted
deleting def(true)...done
CLaM WARNING: synth(sort) not present, so cannot be deleted
deleting def(sort)...done
deleting theorem record for sort1...done
deleting wave record for sort1...done
deleting wave record for sort1...done
deleting func_defeqn record for sort1...done
deleting wave(sort1)...done
deleting theorem record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting func_defeqn record for sort2...done
deleting wave(sort2)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
deleting theorem record for memsort1...done
deleting thm(memsort1)...done
loading def(length)...done
loading eqn(length1)...done
loading eqn(length2)...done
 adding wave-rules for length1:done
 adding wave-rules for length2:.......done
 adding defeqn-record for length1...done 
 adding defeqn-record for length2...done 
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading def(sort)...done
loading eqn(sort1)...done
loading eqn(sort2)...done
 adding wave-rules for sort1:..done
 adding wave-rules for sort2:..............done
 adding defeqn-record for sort1...done 
 adding defeqn-record for sort2...done 
loading thm(lensort)...done
lensort([])
==>l:int list=>length(sort(l))=length(l)in pnat
SELECTED METHOD at depth 0: induction([v0::l],[l:int list])
|lensort([2])
|v0:int
|l:int list
|v1:ih(length(sort(l))=length(l)in pnat)
|==>length(sort(``v0::{l}''<out>))=length(``v0::{l}''<out>)in pnat
|SELECTED METHOD at depth 1: wave([2,1],[length2,equ(left)])
||lensort([1,2])
||v0:int
||l:int list
||v1:ih(length(sort(l))=length(l)in pnat)
||==>length(sort(``v0::{l}''<out>))=``s({length(l)})''<out>in pnat
||SELECTED METHOD at depth 2: wave([1,1,1],[sort2,equ(left)])
|||lensort([1,1,2])
|||v0:int
|||l:int list
|||v1:ih(length(sort(l))=length(l)in pnat)
|||==>length(``insert(v0,{sort(l)})''<out>)=``s({length(l)})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[v0:int,v1:int list]

|- length(insert(v0,v1))=s(length(v1))in pnat

saving thm(lemma1)...done
lemma1([])
==>v0:int=>v1:int list=>length(insert(v0,v1))=s(length(v1))in pnat
SELECTED METHOD at depth 0: induction([v2::v1],[v1:int list])
|lemma1([2])
|v2:int
|v1:int list
|v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
|==>v0:int=>length(insert(\v0/,``v2::{v1}''<out>))=s(length(``v2::{v1}''<out>))in pnat
|SELECTED METHOD at depth 1: wave([1,2,1],[length2,equ(left)])
||lemma1([1,2])
||v2:int
||v1:int list
||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||==>v0:int=>length(insert(\v0/,``v2::{v1}''<out>))=s(``s({length(v1)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

||lemma1([1,2])
||v2:int
||v1:int list
||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||==>v0:int=>length(insert(\v0/,``v2::{v1}''<out>))=``s({s(length(v1))})''<out>in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

|||lemma1([2,1,2])
|||v4:v0<v2
|||v0:int
|||v2:int
|||v1:int list
|||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
|||==>length(insert(v0,v2::v1))=``s({s(length(v1))})''<out>in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1,1],insert2)
||||lemma1([1,2,1,2])
||||v4:v0<v2
||||v0:int
||||v2:int
||||v1:int list
||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||||==>length(v0::v2::v1)=``s({s(length(v1))})''<out>in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1],length2)
|||||lemma1([1,1,2,1,2])
|||||v4:v0<v2
|||||v0:int
|||||v2:int
|||||v1:int list
|||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
|||||==>s(length(v2::v1))=``s({s(length(v1))})''<out>in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1,1],length2)
||||||lemma1([1,1,1,2,1,2])
||||||v4:v0<v2
||||||v0:int
||||||v2:int
||||||v1:int list
||||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||||||==>s(s(length(v1)))=``s({s(length(v1))})''<out>in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|||lemma1([1,1,2])
|||v4:v0<v2=>void
|||v0:int
|||v2:int
|||v1:int list
|||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
|||==>length(insert(\v0/,``v2::{v1}''<out>))=``s({s(length(v1))})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1,1],[insert3,equ(left)])
||||lemma1([1,1,1,2])
||||v4:v0<v2=>void
||||v0:int
||||v2:int
||||v1:int list
||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||||==>length(``v2::{insert(\v0/,v1)}''<out>)=``s({s(length(v1))})''<out>in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[length2,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v4:v0<v2=>void
|||||v0:int
|||||v2:int
|||||v1:int list
|||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
|||||==>``s({length(insert(\v0/,v1))})''<out> =``s({s(length(v1))})''<out>in pnat
|||||SELECTED METHOD at depth 5: fertilize(weak(v3))
||||||lemma1([1,1,1,1,1,2])
||||||v4:v0<v2=>void
||||||v0:int
||||||v2:int
||||||v1:int list
||||||v3:ih(v0:int=>length(insert(v0,v1))=s(length(v1))in pnat)
||||||==>s(length(insert(v0,v1)))=s(length(insert(_890782,v1)))in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
|lemma1([1])
|v1:int list
|==>v0:int=>length(insert(v0,nil))=s(length(nil))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],length1)
||lemma1([1,1])
||v1:int list
||==>v0:int=>length(insert(v0,nil))=s(0)in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],insert1)
|||lemma1([1,1,1])
|||v1:int list
|||==>v0:int=>length(v0::nil)=s(0)in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length2)
||||lemma1([1,1,1,1])
||||v1:int list
||||==>v0:int=>s(length(nil))=s(0)in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],length1)
|||||lemma1([1,1,1,1,1])
|||||v1:int list
|||||==>v0:int=>s(0)=s(0)in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:.......done
|||lensort([1,1,2])
|||v0:int
|||l:int list
|||v1:ih(length(sort(l))=length(l)in pnat)
|||==>length(``insert(v0,{sort(l)})''<out>)=``s({length(l)})''<out>in pnat
|||SELECTED METHOD at depth 3: wave([1,1],[lemma1,equ(left)])
||||lensort([1,1,1,2])
||||v0:int
||||l:int list
||||v1:ih(length(sort(l))=length(l)in pnat)
||||==>``s({length(sort(l))})''<out> =``s({length(l)})''<out>in pnat
||||SELECTED METHOD at depth 4: fertilize(weak(v1))
|||||lensort([1,1,1,1,2])
|||||v0:int
|||||l:int list
|||||v1:ih(length(sort(l))=length(l)in pnat)
|||||==>s(length(sort(l)))=s(length(sort(l)))in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
|lensort([1])
|l:int list
|==>length(sort(nil))=length(nil)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],length1)
||lensort([1,1])
||l:int list
||==>length(sort(nil))=0 in pnat
||SELECTED METHOD at depth 2: eval_def([1,1,1],sort1)
|||lensort([1,1,1])
|||l:int list
|||==>length(nil)=0 in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],length1)
||||lensort([1,1,1,1])
||||l:int list
||||==>0=0 in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for lensort

------------------------------------------------------------
lensort:

[l:int list]

|- length(sort(l))=length(l)in pnat

induction([v0::l],[l:int list]) then 
  [eval_def([2,1],length1) then 
     eval_def([1,1,1],sort1) then 
       eval_def([1,1],length1) then 
         elementary(...),
   wave([2,1],[length2,equ(left)]) then 
     wave([1,1,1],[sort2,equ(left)]) then 
       wave([1,1],[lemma1,equ(left)]) then 
         fertilize(weak(v1)) then 
           elementary(...)
  ]

------------------------------------------------------------
lemma1:

[v0:int,v1:int list]

|- length(insert(v0,v1))=s(length(v1))in pnat

induction([v2::v1],[v1:int list]) then 
  [eval_def([1,2,1],length1) then 
     eval_def([1,1,1],insert1) then 
       eval_def([1,1],length2) then 
         eval_def([1,1,1],length1) then 
           elementary(...),
   wave([1,2,1],[length2,equ(left)]) then 
     casesplit([[[v0<v2=>void]],[[v0<v2]]]) then 
       [wave([1,1,1],[insert3,equ(left)]) then 
          wave([1,1],[length2,equ(left)]) then 
            fertilize(weak(v3)) then 
              elementary(...),
        eval_def([1,1,1],insert2) then 
          eval_def([1,1],length2) then 
            eval_def([1,1,1],length2) then 
              elementary(...)
       ]
  ]


PLANNING for lensort COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
CLaM WARNING: synth(length) not present, so cannot be deleted
deleting def(length)...done
deleting theorem record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting wave record for length2...done
deleting func_defeqn record for length2...done
deleting wave(length2)...done
CLaM WARNING: synth(sort) not present, so cannot be deleted
deleting def(sort)...done
deleting theorem record for sort1...done
deleting wave record for sort1...done
deleting wave record for sort1...done
deleting func_defeqn record for sort1...done
deleting wave(sort1)...done
deleting theorem record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting func_defeqn record for sort2...done
deleting wave(sort2)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
deleting theorem record for lensort...done
deleting thm(lensort)...done
loading def(insert)...done
loading eqn(insert1)...done
loading eqn(insert2)...done
loading eqn(insert3)...done
 adding wave-rules for insert1:......done
 adding wave-rules for insert2:..........................done
 adding wave-rules for insert3:..............................done
 adding defeqn-record for insert1...done 
 adding defeqn-record for insert2...done 
 adding defeqn-record for insert3...done 
loading def(sort)...done
loading eqn(sort1)...done
loading eqn(sort2)...done
 adding wave-rules for sort1:..done
 adding wave-rules for sort2:..............done
 adding defeqn-record for sort1...done 
 adding defeqn-record for sort2...done 
loading def(count)...done
loading eqn(count1)...done
loading eqn(count2)...done
loading eqn(count3)...done
 adding wave-rules for count1:done
 adding wave-rules for count2:..............done
 adding wave-rules for count3:..done
 adding defeqn-record for count1...done 
 adding defeqn-record for count2...done 
 adding defeqn-record for count3...done 
loading thm(cnc_s)...done
 adding wave-rules for cnc_s:done
 adding cancel-record for cnc_s...done
loading thm(countsort)...done
countsort([])
==>a:pnat=>l:pnat list=>count(a,sort(l))=count(a,l)in pnat
SELECTED METHOD at depth 0: induction([v0::l],[l:pnat list])
|countsort([2])
|v0:pnat
|l:pnat list
|v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|==>a:pnat=>count(\a/,sort(``v0::{l}''<out>))=count(\a/,``v0::{l}''<out>)in pnat
|SELECTED METHOD at depth 1: wave([2,1,1],[sort2,equ(left)])
||countsort([1,2])
||v0:pnat
||l:pnat list
||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
||==>a:pnat=>count(\a/,``insert(v0,{sort(l)})''<out>)=count(\a/,``v0::{l}''<out>)in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

|||countsort([2,1,2])
|||v2:a=v0 in pnat
|||a:pnat
|||v0:pnat
|||l:pnat list
|||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||==>count(\a/,``insert(v0,{sort(l)})''<out>)=count(\a/,``v0::{l}''<out>)in pnat
|||SELECTED METHOD at depth 3: equal(v2,left)
||||countsort([1,2,1,2])
||||a:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
||||==>count(\a/,``insert(\a/,{sort(l)})''<out>)=count(\a/,``\a/ ::{l}''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[count2,equ(left)])
|||||countsort([1,1,2,1,2])
|||||a:pnat
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||||==>count(\a/,``insert(\a/,{sort(l)})''<out>)=``s({count(\a/,l)})''<out>in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma1:

[a:pnat,v0:pnat list]

|- count(a,insert(a,v0))=s(count(a,v0))in pnat

saving thm(lemma1)...done
lemma1([])
==>a:pnat=>v0:pnat list=>count(a,insert(a,v0))=s(count(a,v0))in pnat
SELECTED METHOD at depth 0: induction([v1::v0],[v0:pnat list])
|lemma1([2])
|v1:pnat
|v0:pnat list
|v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|==>a:pnat=>count(\a/,insert(\a/,``v1::{v0}''<out>))=s(count(\a/,``v1::{v0}''<out>))in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

||lemma1([2,2])
||v3:a=v1 in pnat
||a:pnat
||v1:pnat
||v0:pnat list
||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||==>count(\a/,insert(\a/,``v1::{v0}''<out>))=s(count(\a/,``v1::{v0}''<out>))in pnat
||SELECTED METHOD at depth 2: equal(v3,left)
|||lemma1([1,2,2])
|||a:pnat
|||v1:pnat
|||v0:pnat list
|||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||==>count(\a/,insert(\a/,``\a/ ::{v0}''<out>))=s(count(\a/,``\a/ ::{v0}''<out>))in pnat
|||SELECTED METHOD at depth 3: wave([1,2,1],[count2,equ(left)])
||||lemma1([1,1,2,2])
||||a:pnat
||||v1:pnat
||||v0:pnat list
||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||==>count(\a/,insert(\a/,``\a/ ::{v0}''<out>))=s(``s({count(\a/,v0)})''<out>)in pnat

>>>>> INVOKING meta-ripple-position CRITIC <<<<<

||||lemma1([1,1,2,2])
||||a:pnat
||||v1:pnat
||||v0:pnat list
||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||==>count(\a/,insert(\a/,``\a/ ::{v0}''<out>))=``s({s(count(\a/,v0))})''<out>in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

|||||lemma1([2,1,1,2,2])
|||||v3:a<a
|||||a:pnat
|||||v1:pnat
|||||v0:pnat list
|||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||==>count(\a/,insert(a,a::v0))=``s({s(count(\a/,v0))})''<out>in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1,1],insert2)
||||||lemma1([1,2,1,1,2,2])
||||||v3:a<a
||||||a:pnat
||||||v1:pnat
||||||v0:pnat list
||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||==>count(\a/,a::a::v0)=``s({s(count(\a/,v0))})''<out>in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1],count2)
|||||||lemma1([1,1,2,1,1,2,2])
|||||||v3:a<a
|||||||a:pnat
|||||||v1:pnat
|||||||v0:pnat list
|||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||||==>s(count(\a/,a::v0))=``s({s(count(\a/,v0))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1,1],count2)
||||||||lemma1([1,1,1,2,1,1,2,2])
||||||||v3:a<a
||||||||a:pnat
||||||||v1:pnat
||||||||v0:pnat list
||||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||||==>s(s(count(\a/,v0)))=``s({s(count(\a/,v0))})''<out>in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||lemma1([1,1,1,2,2])
|||||v3:a<a=>void
|||||a:pnat
|||||v1:pnat
|||||v0:pnat list
|||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||==>count(\a/,insert(\a/,``\a/ ::{v0}''<out>))=``s({s(count(\a/,v0))})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([2,1,1],[insert3,equ(left)])
||||||lemma1([1,1,1,1,2,2])
||||||v3:a<a=>void
||||||a:pnat
||||||v1:pnat
||||||v0:pnat list
||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||==>count(\a/,``\a/ ::{insert(\a/,v0)}''<out>)=``s({s(count(\a/,v0))})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([1,1],[count2,equ(left)])
|||||||lemma1([1,1,1,1,1,2,2])
|||||||v3:a<a=>void
|||||||a:pnat
|||||||v1:pnat
|||||||v0:pnat list
|||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||||==>``s({count(\a/,insert(\a/,v0))})''<out> =``s({s(count(\a/,v0))})''<out>in pnat
|||||||SELECTED METHOD at depth 7: fertilize(weak(v2))
||||||||lemma1([1,1,1,1,1,1,2,2])
||||||||v3:a<a=>void
||||||||a:pnat
||||||||v1:pnat
||||||||v0:pnat list
||||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||||==>s(count(a,insert(a,v0)))=s(count(a,insert(a,v0)))in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
||lemma1([1,2])
||v3:a=v1 in pnat=>void
||a:pnat
||v1:pnat
||v0:pnat list
||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||==>count(\a/,insert(\a/,``v1::{v0}''<out>))=s(count(\a/,``v1::{v0}''<out>))in pnat
||SELECTED METHOD at depth 2: wave([1,2,1],[count3,equ(left)])
|||lemma1([1,1,2])
|||v3:a=v1 in pnat=>void
|||a:pnat
|||v1:pnat
|||v0:pnat list
|||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||==>count(\a/,insert(\a/,``v1::{v0}''<out>))=s(count(\a/,v0))in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

||||lemma1([2,1,1,2])
||||v4:a<v1
||||v3:a=v1 in pnat=>void
||||a:pnat
||||v1:pnat
||||v0:pnat list
||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||==>count(\a/,insert(a,v1::v0))=s(count(\a/,v0))in pnat
||||SELECTED METHOD at depth 4: eval_def([2,1,1],insert2)
|||||lemma1([1,2,1,1,2])
|||||v4:a<v1
|||||v3:a=v1 in pnat=>void
|||||a:pnat
|||||v1:pnat
|||||v0:pnat list
|||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||==>count(\a/,a::v1::v0)=s(count(\a/,v0))in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],count2)
||||||lemma1([1,1,2,1,1,2])
||||||v4:a<v1
||||||v3:a=v1 in pnat=>void
||||||a:pnat
||||||v1:pnat
||||||v0:pnat list
||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||==>s(count(\a/,v1::v0))=s(count(\a/,v0))in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1,1],count3)
|||||||lemma1([1,1,1,2,1,1,2])
|||||||v4:a<v1
|||||||v3:a=v1 in pnat=>void
|||||||a:pnat
|||||||v1:pnat
|||||||v0:pnat list
|||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||||==>s(count(\a/,v0))=s(count(\a/,v0))in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
||||lemma1([1,1,1,2])
||||v4:a<v1=>void
||||v3:a=v1 in pnat=>void
||||a:pnat
||||v1:pnat
||||v0:pnat list
||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||==>count(\a/,insert(\a/,``v1::{v0}''<out>))=s(count(\a/,v0))in pnat
||||SELECTED METHOD at depth 4: wave([2,1,1],[insert3,equ(left)])
|||||lemma1([1,1,1,1,2])
|||||v4:a<v1=>void
|||||v3:a=v1 in pnat=>void
|||||a:pnat
|||||v1:pnat
|||||v0:pnat list
|||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
|||||==>count(\a/,``v1::{insert(\a/,v0)}''<out>)=s(count(\a/,v0))in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[count3,equ(left)])
||||||lemma1([1,1,1,1,1,2])
||||||v4:a<v1=>void
||||||v3:a=v1 in pnat=>void
||||||a:pnat
||||||v1:pnat
||||||v0:pnat list
||||||v2:ih(a:pnat=>count(a,insert(a,v0))=s(count(a,v0))in pnat)
||||||==>count(\a/,insert(\a/,v0))=s(count(\a/,v0))in pnat
||||||TERMINATING METHOD at depth 6: fertilize(strong(v2))
|lemma1([1])
|v0:pnat list
|==>a:pnat=>count(a,insert(a,nil))=s(count(a,nil))in pnat
|SELECTED METHOD at depth 1: eval_def([1,2,1],count1)
||lemma1([1,1])
||v0:pnat list
||==>a:pnat=>count(a,insert(a,nil))=s(0)in pnat
||SELECTED METHOD at depth 2: eval_def([2,1,1],insert1)
|||lemma1([1,1,1])
|||v0:pnat list
|||==>a:pnat=>count(a,a::nil)=s(0)in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],count2)
||||lemma1([1,1,1,1])
||||v0:pnat list
||||==>a:pnat=>s(count(a,nil))=s(0)in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1,1],count1)
|||||lemma1([1,1,1,1,1])
|||||v0:pnat list
|||||==>a:pnat=>s(0)=s(0)in pnat
|||||TERMINATING METHOD at depth 5: elementary(...)
 adding wave-rules for lemma1:..........................done
|||||countsort([1,1,2,1,2])
|||||a:pnat
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||||==>count(\a/,``insert(\a/,{sort(l)})''<out>)=``s({count(\a/,l)})''<out>in pnat
|||||SELECTED METHOD at depth 5: wave([1,1],[lemma1,equ(left)])
||||||countsort([1,1,1,2,1,2])
||||||a:pnat
||||||v0:pnat
||||||l:pnat list
||||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
||||||==>``s({count(\a/,sort(l))})''<out> =``s({count(\a/,l)})''<out>in pnat
||||||SELECTED METHOD at depth 6: fertilize(weak(v1))
|||||||countsort([1,1,1,1,2,1,2])
|||||||a:pnat
|||||||v0:pnat
|||||||l:pnat list
|||||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||||||==>s(count(a,sort(l)))=s(count(a,sort(l)))in pnat
|||||||TERMINATING METHOD at depth 7: elementary(...)
|||countsort([1,1,2])
|||v2:a=v0 in pnat=>void
|||a:pnat
|||v0:pnat
|||l:pnat list
|||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||==>count(\a/,``insert(v0,{sort(l)})''<out>)=count(\a/,``v0::{l}''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[count3,equ(left)])
||||countsort([1,1,1,2])
||||v2:a=v0 in pnat=>void
||||a:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
||||==>count(\a/,``insert(v0,{sort(l)})''<out>)=count(\a/,l)in pnat

>>>>> INVOKING lemma-calculation CRITIC <<<<<

------------------------------------------------------------
lemma2:

[a:pnat,v0:pnat,v1:pnat list]

|- (a=v0 in pnat=>void)=>count(a,insert(v0,v1))=count(a,v1)in pnat

saving thm(lemma2)...done
lemma2([])
==>a:pnat=>v0:pnat=>v1:pnat list=> (a=v0 in pnat=>void)=>count(a,insert(v0,v1))=count(a,v1)in pnat
SELECTED METHOD at depth 0: normal(imply_intro(v2))
|lemma2([1])
|v2:a=v0 in pnat=>void
|a:pnat
|v0:pnat
|v1:pnat list
|==>count(a,insert(v0,v1))=count(a,v1)in pnat
|SELECTED METHOD at depth 1: induction([v3::v1],[v1:pnat list])
||lemma2([2,1])
||v3:pnat
||v1:pnat list
||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||v2:a=v0 in pnat=>void
||a:pnat
||v0:pnat
||v1:pnat list
||==>count(a,insert(v0,``v3::{v1}''<out>))=count(a,``v3::{v1}''<out>)in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

|||lemma2([2,2,1])
|||v5:a=v3 in pnat
|||v3:pnat
|||v1:pnat list
|||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||v2:a=v0 in pnat=>void
|||a:pnat
|||v0:pnat
|||v1:pnat list
|||==>count(a,insert(v0,``v3::{v1}''<out>))=count(a,``v3::{v1}''<out>)in pnat
|||SELECTED METHOD at depth 3: equal(v5,left)
||||lemma2([1,2,2,1])
||||v3:pnat
||||v1:pnat list
||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||v2:a=v0 in pnat=>void
||||a:pnat
||||v0:pnat
||||v1:pnat list
||||==>count(a,insert(v0,``a::{v1}''<out>))=count(a,``a::{v1}''<out>)in pnat
||||SELECTED METHOD at depth 4: wave([2,1],[count2,equ(left)])
|||||lemma2([1,1,2,2,1])
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||v2:a=v0 in pnat=>void
|||||a:pnat
|||||v0:pnat
|||||v1:pnat list
|||||==>count(a,insert(v0,``a::{v1}''<out>))=``s({count(a,v1)})''<out>in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

||||||lemma2([2,1,1,2,2,1])
||||||v5:v0<a
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||v2:a=v0 in pnat=>void
||||||a:pnat
||||||v0:pnat
||||||v1:pnat list
||||||==>count(a,insert(v0,a::v1))=``s({count(a,v1)})''<out>in pnat
||||||SELECTED METHOD at depth 6: eval_def([2,1,1],insert2)
|||||||lemma2([1,2,1,1,2,2,1])
|||||||v5:v0<a
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||v2:a=v0 in pnat=>void
|||||||a:pnat
|||||||v0:pnat
|||||||v1:pnat list
|||||||==>count(a,v0::a::v1)=``s({count(a,v1)})''<out>in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1],count3)
||||||||lemma2([1,1,2,1,1,2,2,1])
||||||||v5:v0<a
||||||||v3:pnat
||||||||v1:pnat list
||||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||||v2:a=v0 in pnat=>void
||||||||a:pnat
||||||||v0:pnat
||||||||v1:pnat list
||||||||==>count(a,a::v1)=``s({count(a,v1)})''<out>in pnat
||||||||SELECTED METHOD at depth 8: eval_def([1,1],count2)
|||||||||lemma2([1,1,1,2,1,1,2,2,1])
|||||||||v5:v0<a
|||||||||v3:pnat
|||||||||v1:pnat list
|||||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||||v2:a=v0 in pnat=>void
|||||||||a:pnat
|||||||||v0:pnat
|||||||||v1:pnat list
|||||||||==>s(count(a,v1))=``s({count(a,v1)})''<out>in pnat
|||||||||TERMINATING METHOD at depth 9: elementary(...)
||||||lemma2([1,1,1,2,2,1])
||||||v5:v0<a=>void
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||v2:a=v0 in pnat=>void
||||||a:pnat
||||||v0:pnat
||||||v1:pnat list
||||||==>count(a,insert(v0,``a::{v1}''<out>))=``s({count(a,v1)})''<out>in pnat
||||||SELECTED METHOD at depth 6: wave([2,1,1],[insert3,equ(left)])
|||||||lemma2([1,1,1,1,2,2,1])
|||||||v5:v0<a=>void
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||v2:a=v0 in pnat=>void
|||||||a:pnat
|||||||v0:pnat
|||||||v1:pnat list
|||||||==>count(a,``a::{insert(v0,v1)}''<out>)=``s({count(a,v1)})''<out>in pnat
|||||||SELECTED METHOD at depth 7: wave([1,1],[count2,equ(left)])
||||||||lemma2([1,1,1,1,1,2,2,1])
||||||||v5:v0<a=>void
||||||||v3:pnat
||||||||v1:pnat list
||||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||||v2:a=v0 in pnat=>void
||||||||a:pnat
||||||||v0:pnat
||||||||v1:pnat list
||||||||==>``s({count(a,insert(v0,v1))})''<out> =``s({count(a,v1)})''<out>in pnat
||||||||SELECTED METHOD at depth 8: fertilize(weak(v4))
|||||||||lemma2([1,1,1,1,1,1,2,2,1])
|||||||||v5:v0<a=>void
|||||||||v3:pnat
|||||||||v1:pnat list
|||||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||||v2:a=v0 in pnat=>void
|||||||||a:pnat
|||||||||v0:pnat
|||||||||v1:pnat list
|||||||||==>s(count(a,insert(v0,v1)))=s(count(a,insert(v0,v1)))in pnat
|||||||||TERMINATING METHOD at depth 9: elementary(...)
|||lemma2([1,2,1])
|||v5:a=v3 in pnat=>void
|||v3:pnat
|||v1:pnat list
|||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||v2:a=v0 in pnat=>void
|||a:pnat
|||v0:pnat
|||v1:pnat list
|||==>count(a,insert(v0,``v3::{v1}''<out>))=count(a,``v3::{v1}''<out>)in pnat
|||SELECTED METHOD at depth 3: wave([2,1],[count3,equ(left)])
||||lemma2([1,1,2,1])
||||v5:a=v3 in pnat=>void
||||v3:pnat
||||v1:pnat list
||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||v2:a=v0 in pnat=>void
||||a:pnat
||||v0:pnat
||||v1:pnat list
||||==>count(a,insert(v0,``v3::{v1}''<out>))=count(a,v1)in pnat

>>>>> INVOKING casesplit CRITIC <<<<<

|||||lemma2([2,1,1,2,1])
|||||v6:v0<v3
|||||v5:a=v3 in pnat=>void
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||v2:a=v0 in pnat=>void
|||||a:pnat
|||||v0:pnat
|||||v1:pnat list
|||||==>count(a,insert(v0,v3::v1))=count(a,v1)in pnat
|||||SELECTED METHOD at depth 5: eval_def([2,1,1],insert2)
||||||lemma2([1,2,1,1,2,1])
||||||v6:v0<v3
||||||v5:a=v3 in pnat=>void
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||v2:a=v0 in pnat=>void
||||||a:pnat
||||||v0:pnat
||||||v1:pnat list
||||||==>count(a,v0::v3::v1)=count(a,v1)in pnat
||||||SELECTED METHOD at depth 6: eval_def([1,1],count3)
|||||||lemma2([1,1,2,1,1,2,1])
|||||||v6:v0<v3
|||||||v5:a=v3 in pnat=>void
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||v2:a=v0 in pnat=>void
|||||||a:pnat
|||||||v0:pnat
|||||||v1:pnat list
|||||||==>count(a,v3::v1)=count(a,v1)in pnat
|||||||SELECTED METHOD at depth 7: eval_def([1,1],count3)
||||||||lemma2([1,1,1,2,1,1,2,1])
||||||||v6:v0<v3
||||||||v5:a=v3 in pnat=>void
||||||||v3:pnat
||||||||v1:pnat list
||||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||||v2:a=v0 in pnat=>void
||||||||a:pnat
||||||||v0:pnat
||||||||v1:pnat list
||||||||==>count(a,v1)=count(a,v1)in pnat
||||||||TERMINATING METHOD at depth 8: elementary(...)
|||||lemma2([1,1,1,2,1])
|||||v6:v0<v3=>void
|||||v5:a=v3 in pnat=>void
|||||v3:pnat
|||||v1:pnat list
|||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||v2:a=v0 in pnat=>void
|||||a:pnat
|||||v0:pnat
|||||v1:pnat list
|||||==>count(a,insert(v0,``v3::{v1}''<out>))=count(a,v1)in pnat
|||||SELECTED METHOD at depth 5: wave([2,1,1],[insert3,equ(left)])
||||||lemma2([1,1,1,1,2,1])
||||||v6:v0<v3=>void
||||||v5:a=v3 in pnat=>void
||||||v3:pnat
||||||v1:pnat list
||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
||||||v2:a=v0 in pnat=>void
||||||a:pnat
||||||v0:pnat
||||||v1:pnat list
||||||==>count(a,``v3::{insert(v0,v1)}''<out>)=count(a,v1)in pnat
||||||SELECTED METHOD at depth 6: wave([1,1],[count3,equ(left)])
|||||||lemma2([1,1,1,1,1,2,1])
|||||||v6:v0<v3=>void
|||||||v5:a=v3 in pnat=>void
|||||||v3:pnat
|||||||v1:pnat list
|||||||v4:ih(count(a,insert(v0,v1))=count(a,v1)in pnat)
|||||||v2:a=v0 in pnat=>void
|||||||a:pnat
|||||||v0:pnat
|||||||v1:pnat list
|||||||==>count(a,insert(v0,v1))=count(a,v1)in pnat
|||||||TERMINATING METHOD at depth 7: fertilize(strong(v4))
||lemma2([1,1])
||v1:pnat list
||v2:a=v0 in pnat=>void
||a:pnat
||v0:pnat
||v1:pnat list
||==>count(a,insert(v0,nil))=count(a,nil)in pnat
||SELECTED METHOD at depth 2: eval_def([2,1],count1)
|||lemma2([1,1,1])
|||v1:pnat list
|||v2:a=v0 in pnat=>void
|||a:pnat
|||v0:pnat
|||v1:pnat list
|||==>count(a,insert(v0,nil))=0 in pnat
|||SELECTED METHOD at depth 3: eval_def([2,1,1],insert1)
||||lemma2([1,1,1,1])
||||v1:pnat list
||||v2:a=v0 in pnat=>void
||||a:pnat
||||v0:pnat
||||v1:pnat list
||||==>count(a,v0::nil)=0 in pnat
||||SELECTED METHOD at depth 4: eval_def([1,1],count3)
|||||lemma2([1,1,1,1,1])
|||||v1:pnat list
|||||v2:a=v0 in pnat=>void
|||||a:pnat
|||||v0:pnat
|||||v1:pnat list
|||||==>count(a,nil)=0 in pnat
|||||SELECTED METHOD at depth 5: eval_def([1,1],count1)
||||||lemma2([1,1,1,1,1,1])
||||||v1:pnat list
||||||v2:a=v0 in pnat=>void
||||||a:pnat
||||||v0:pnat
||||||v1:pnat list
||||||==>0=0 in pnat
||||||TERMINATING METHOD at depth 6: elementary(...)
 adding wave-rules for lemma2:..done
||||countsort([1,1,1,2])
||||v2:a=v0 in pnat=>void
||||a:pnat
||||v0:pnat
||||l:pnat list
||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
||||==>count(\a/,``insert(v0,{sort(l)})''<out>)=count(\a/,l)in pnat
||||SELECTED METHOD at depth 4: wave([1,1],[lemma2,equ(left)])
|||||countsort([1,1,1,1,2])
|||||v2:a=v0 in pnat=>void
|||||a:pnat
|||||v0:pnat
|||||l:pnat list
|||||v1:ih(a:pnat=>count(a,sort(l))=count(a,l)in pnat)
|||||==>count(\a/,sort(l))=count(\a/,l)in pnat
|||||TERMINATING METHOD at depth 5: fertilize(strong(v1))
|countsort([1])
|l:pnat list
|==>a:pnat=>count(a,sort(nil))=count(a,nil)in pnat
|SELECTED METHOD at depth 1: eval_def([2,1],count1)
||countsort([1,1])
||l:pnat list
||==>a:pnat=>count(a,sort(nil))=0 in pnat
||SELECTED METHOD at depth 2: eval_def([2,1,1],sort1)
|||countsort([1,1,1])
|||l:pnat list
|||==>a:pnat=>count(a,nil)=0 in pnat
|||SELECTED METHOD at depth 3: eval_def([1,1],count1)
||||countsort([1,1,1,1])
||||l:pnat list
||||==>a:pnat=>0=0 in pnat
||||TERMINATING METHOD at depth 4: elementary(...)
Planning complete for countsort

------------------------------------------------------------
countsort:

[a:pnat,l:pnat list]

|- count(a,sort(l))=count(a,l)in pnat

induction([v0::l],[l:pnat list]) then 
  [eval_def([2,1],count1) then 
     eval_def([2,1,1],sort1) then 
       eval_def([1,1],count1) then 
         elementary(...),
   wave([2,1,1],[sort2,equ(left)]) then 
     casesplit([[[a=v0 in pnat=>void],[a=v0 in pnat]],[]]) then 
       [wave([2,1],[count3,equ(left)]) then 
          wave([1,1],[lemma2,equ(left)]) then 
            fertilize(strong(v1)),
        equal(v2,left) then 
          wave([2,1],[count2,equ(left)]) then 
            wave([1,1],[lemma1,equ(left)]) then 
              fertilize(weak(v1)) then 
                elementary(...)
       ]
  ]

------------------------------------------------------------
lemma1:

[a:pnat,v0:pnat list]

|- count(a,insert(a,v0))=s(count(a,v0))in pnat

induction([v1::v0],[v0:pnat list]) then 
  [eval_def([1,2,1],count1) then 
     eval_def([2,1,1],insert1) then 
       eval_def([1,1],count2) then 
         eval_def([1,1,1],count1) then 
           elementary(...),
   casesplit([[[a=v1 in pnat=>void],[a=v1 in pnat]],[]]) then 
     [wave([1,2,1],[count3,equ(left)]) then 
        casesplit([[[a<v1=>void]],[[a<v1]]]) then 
          [wave([2,1,1],[insert3,equ(left)]) then 
             wave([1,1],[count3,equ(left)]) then 
               fertilize(strong(v2)),
           eval_def([2,1,1],insert2) then 
             eval_def([1,1],count2) then 
               eval_def([1,1,1],count3) then 
                 elementary(...)
          ],
      equal(v3,left) then 
        wave([1,2,1],[count2,equ(left)]) then 
          casesplit([[[a<a=>void]],[[a<a]]]) then 
            [wave([2,1,1],[insert3,equ(left)]) then 
               wave([1,1],[count2,equ(left)]) then 
                 fertilize(weak(v2)) then 
                   elementary(...),
             eval_def([2,1,1],insert2) then 
               eval_def([1,1],count2) then 
                 eval_def([1,1,1],count2) then 
                   elementary(...)
            ]
     ]
  ]

------------------------------------------------------------
lemma2:

[a:pnat,v0:pnat,v1:pnat list]

|- (a=v0 in pnat=>void)=>count(a,insert(v0,v1))=count(a,v1)in pnat

normal(imply_intro(v2)) then 
  induction([v3::v1],[v1:pnat list]) then 
    [eval_def([2,1],count1) then 
       eval_def([2,1,1],insert1) then 
         eval_def([1,1],count3) then 
           eval_def([1,1],count1) then 
             elementary(...),
     casesplit([[[a=v3 in pnat=>void],[a=v3 in pnat]],[]]) then 
       [wave([2,1],[count3,equ(left)]) then 
          casesplit([[[v0<v3=>void]],[[v0<v3]]]) then 
            [wave([2,1,1],[insert3,equ(left)]) then 
               wave([1,1],[count3,equ(left)]) then 
                 fertilize(strong(v4)),
             eval_def([2,1,1],insert2) then 
               eval_def([1,1],count3) then 
                 eval_def([1,1],count3) then 
                   elementary(...)
            ],
        equal(v5,left) then 
          wave([2,1],[count2,equ(left)]) then 
            casesplit([[[v0<a=>void]],[[v0<a]]]) then 
              [wave([2,1,1],[insert3,equ(left)]) then 
                 wave([1,1],[count2,equ(left)]) then 
                   fertilize(weak(v4)) then 
                     elementary(...),
               eval_def([2,1,1],insert2) then 
                 eval_def([1,1],count3) then 
                   eval_def([1,1],count2) then 
                     elementary(...)
              ]
       ]
    ]


PLANNING for countsort COMPLETE. 

deleting theorem record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting wave record for lemma1...done
deleting thm(lemma1)...done
deleting theorem record for lemma2...done
deleting wave record for lemma2...done
deleting wave record for lemma2...done
deleting thm(lemma2)...done
CLaM WARNING: synth(sort) not present, so cannot be deleted
deleting def(sort)...done
deleting theorem record for sort1...done
deleting wave record for sort1...done
deleting wave record for sort1...done
deleting func_defeqn record for sort1...done
deleting wave(sort1)...done
deleting theorem record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting wave record for sort2...done
deleting func_defeqn record for sort2...done
deleting wave(sort2)...done
CLaM WARNING: synth(insert) not present, so cannot be deleted
deleting def(insert)...done
deleting theorem record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting wave record for insert1...done
deleting func_defeqn record for insert1...done
deleting wave(insert1)...done
deleting theorem record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting wave record for insert2...done
deleting func_defeqn record for insert2...done
deleting wave(insert2)...done
deleting theorem record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting wave record for insert3...done
deleting func_defeqn record for insert3...done
deleting wave(insert3)...done
CLaM WARNING: synth(count) not present, so cannot be deleted
deleting def(count)...done
deleting theorem record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting wave record for count2...done
deleting func_defeqn record for count2...done
deleting wave(count2)...done
deleting theorem record for count3...done
deleting wave record for count3...done
deleting wave record for count3...done
deleting func_defeqn record for count3...done
deleting wave(count3)...done
deleting theorem record for countsort...done
deleting thm(countsort)...done

Benchmarking run complete.

Planning failures = 0

-------------
Planning successes = 47

doubleplus
lenapp
lenplus
lendouble
lenrev
lenrevapp
lenqrevapp
revrev
revapp1
revqrev
halfplus1
evenplus1
revapp4
revapp2
revapp3
evenlenapp1
rotlenapp
evenlenapp2
halflenapp1
evenplus2
evenlenapp3
halfplus2
revqrevnil1
revflatqrev
revqrevnil2
revrevnil1
qrevqrevnil1
rotlen
facqfac
timesmult
expqexp
facout
memapp1
memapp2
memapp3
nthmem
subsetunion
subsetintersect
memunion1
memunion2
memintersect
memins
meminsert1
meminsert2
memsort1
lensort
countsort
-------------

yes
| ?- 