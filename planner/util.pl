/*
 * General utilities for the proof planner.
 * First planner-specific utilities, then more general utilities
 * Most of them too boring for comment.
 */

/*
 * All operator declarations of the whole system are done righ at top of
 * file, even though their definitions only follow later (or are
 * somewhere else alltoghether). This is to allow them to be used before
 * they are defined:
 */
:- op(1100,     xfy,    [v, orelse]).
:- op(990,      yfx,    [andpossibly]).
:- op(860,      fx,     [thereis, forall]).
:- op(850,      fx,     on_backtracking).
:- op(850,      fx,     on_backtracking2).
:- op(850,      fx,     [tryto]).
:- op(825,      xfy,    [:=>]).
:- op(505,      fx,     make).
        % following some postfix operators for the object-level logic a
        % la "list". Don't know where else to put the operator
        % declarations, so just put it here... 
:- op( 200,     xf,     [nestedlist,tree]).

        % definition(?L<==>?R) L is defined as R. First checks all local
        % definitions, then all global definitions. Almost like Jane's
        % get_definition/2, but more general, since L can be mode ?
        %
        % ALSO: works for L=F/N. This is useful since we often only
        % know the functor F of the definition, and not its arity. In
        % such a case we would end up writing in the calling code:
        %   definition(L<==>R), functorp(L,F,N)
        % which causes endless bactracking over definition/1.
        %
        % NOTE: Currently remove the code for local defs since this only costs
        % time and nobody uses them anymore. 
% definition(L<==>R) :- hypothesis(L<==>R).
definition(F/N<==>R) :-
    atomic(F), !,
    cdef(F) =: (L<==>R),
    (functor(L,F,N) orelse (N=0,L={F})).
definition(L<==>R) :- cdef(_) =: (L<==>R).

        % Very simple pretty-printer for plans.
        % Second argument is indentation from left margin.
        % Only the first clause is for human consumption.
        % Second clause allows printing of partial plans of the kind
        % generated by breadth-first planning (useful for debugging).
        % Third clause stripts of bogus [...]'s around single element lists.
        % Fourth clause deals with "then [....]" constructs.
        %  The trickery-pokery with the no_indent(Indent) term is to not indent
        %  the first line of the first element of the list after the "then",
        %  because that indentation is already done before printing the '['.
        % Fifth clause deals with "then" constructs without lists
        % Sixth clause deals with atomic plans
        % 
        % print_plan_list/2 just iterates print_plan over a list. Notice
        % that we don't terminate on [] but on [H], to avoid printing a ','
        % after the last element of the list.
print_plan(Plan) :- print_plan(Plan,0),nl.
print_plan(Plan,I) :- var(Plan), !, Plan='_', print_plan(Plan,I).
print_plan(P1 then Var, I) :- var(Var), !, print_plan(P1,I).
print_plan(P1 then [P2],I) :- !,print_plan(P1 then P2,I).
print_plan(P1 then [P2|P2s],I) :- !,
    print_plan(P1,I), (I=no_indent(II) orelse I=II),
    write(' then '), nl, J is II+2+1, tab(J-1),write('['),
    print_plan(P2,no_indent(J)), write(','),nl,
    print_plan_list(P2s,J), tab(J-1),write(']').
print_plan(P1 then P2,I) :- !,
    print_plan(P1,I), (I=no_indent(II) orelse I=II),
    write(' then '), nl,
    J is II+2, print_plan(P2,J).
print_plan(P,no_indent(_)) :- !,print(P).       % use print/1 to allow user
print_plan(P,I) :- !,tab(I), print(P).          % to portray.
print_plan_list([H],I) :- !, print_plan(H,I),nl.
print_plan_list([H|T],I) :-
    print_plan(H,I), write(','), nl, print_plan_list(T,I).

        % print_plan/0 prints the plan of the current proof tree under
        % the current node.
print_plan :- get_plan(P), print_plan(P).
get_plan(R then Rs) :- refinement(R), findall(R1, (down,get_plan(R1)),
Rs), Rs\=[],!.
get_plan(R) :- refinement(R).

        % print_dplan/0 prints the last plan constructed using dplan
        % print_idplan/0 prints the last plan constructed using dplan
        % print_bplan/0 prints the last plan constructed using dplan
print_dplan :- dplan=:P, print_plan(P).
print_idplan :- idplan=:P, print_plan(P).
print_bplan :- bplan=:P, print_plan(P).

print_plans:-
    cthm=:Thm,
    print_plans(Thm).

print_plans_list([]).
print_plans_list([Thm|Thms]):-
    print_plans(Thm),
    print_plans_list(Thms).
print_plans(ThmName):-
    recorded(ThmName, plans(Tactic, SubPlanNames), _),
    theorem(ThmName,Thm),
    print_conjecture(Thm, ThmName),
    print_plan(Tactic),nl,
    reverse(SubPlanNames,RSubPlanNames),
    print_plans_list(RSubPlanNames).

print_conjecture([]==>G, ThmName):-
    print_conj(G, ThmName).
print_conjecture(Thm, ThmName):-
    Thm \= (_ ==> _),
    print_conj(Thm, ThmName).

print_conj(Thm, ThmName):-
    matrix(Binds,Mat,Thm),
    writef('%r\n',['-',60]),
    writef('%t:\n\n',[ThmName]),
    writef('%t\n\n|- %t\n\n',[Binds,Mat]).
    

format_plan_list([]):-
    writef('%r\n',['-',60]).
format_plan_list([Plan|Plans]):-
    Plan=..[Name,Tactic],
    theorem(Name,Thm),
    matrix(Binds,Mat,Thm),
    writef('%r\n',['-',60]),
    writef('%t:\n\n',[Name]),
    writef('%t |- %t\n\n',[Binds,Mat]),
    print_plan(Tactic),nl,
    format_plan_list(Plans).

count_chars([],0).
count_chars([H|T],N):-
    cnt_chars(H,N1),
    count_chars(T,N2),
    N is N1 + N2.

print_nllist(L) :- print_nllist(L,0,'|').
print_nllist([],_,_).
print_nllist([H|T],C,Ch) :-
    writef('%r%t\n',[Ch,C,H]),
    print_nllist(T,C,Ch).

	% toggle_formats/1 iterates over a list of modifications
	% to portray clauses.
toggle_formats([]).
toggle_formats([H|T]):-
	toggle_format(H),
	toggle_formats(T).
	
	% toggle_format/1 in effect rotates the order of the
	% portray clauses for the method Name with arity Arity.
toggle_format(Name/Arity) :-
        same_length(_,MArgs,Arity),
        Mthd =.. [Name|MArgs],
        retract((portray(Mthd):- Body)),
        assertz((portray(Mthd):- Body)).

        % Portray clauses for pretty printing come in a few flavours:
        % [1] few clauses suppress longwinded arguments to methods and
        %     methodicals.
        %     Portray/1 needs to be dynamic so we can assert extra clauses
        %     at runtime for iterated methods. For each iterator it/1 there
        %     will be portray-clauses:
        %         portray(it(L)) :- (var(L);L==[]), !, write(it(L)).
        %         portray(it(_)) :- write(it('[...]')).
        % [2] Pretty print wave-fronts
        % [3] (optional) pretty print defined Oyster terms.
        % [4] (optional) pretty print for method predicates.
:- dynamic portray/1.
        % [1]: methods etc:
portray(base_case(_I)) :-  write('base_case([...])').
portray(base_case(I)) :-  write('base_case('),
			  print(I),
			  write(')').

portray(step_case(_I)) :-  write('step_case([...])').
portray(step_case(I)) :-  write('step_case('),
			  print(I),
			  write(')').

portray(ripple_and_cancel(_Ms)) :- write('ripple_and_cancel([...])').
portray(ripple_and_cancel(Ms)) :- write('ripple_and_cancel('),
				  print(Ms),
				  write(')').

%portray(tautology(I)) :- var(I),!, write(tautology(I)).
portray(tautology(_)) :- write('tautology(...)').
portray(tautology(T)) :- write(tautology(T)).

portray(elementary(_)) :- write('elementary(...)').
portray(elementary(T)) :- write(elementary(T)).

portray(sym_eval(_I)) :-  write('sym_eval(...)').
portray(sym_eval(I)) :-  write(sym_eval(I)).

portray(normalize(L)) :- length(L,N),writef('normalize([%r])',['.',N]).
portray(normalize(L)) :- write(normalize(L)).

portray(fertilize(T,_)) :- write(fertilize(T,'[...]')).
portray(fertilize(T,Ms)) :- write('fertilize('),
			    write(T),write(','),
			    print(Ms),
			    write(')').

portray(fertilize_then_ripple(P)) :- print(P).
portray(fertilize_then_ripple(P)) :- write('fertilize_then_ripple('),
				     print(P),
				     write(')').

portray(fertilize_left_or_right(_,L)) :- write('fertilize('),
					 print(L),
					 write(')').
portray(fertilize_left_or_right(D,L)) :- write('fertilize_left_or_right('),
					 write(D),write(','),
					 print(L),
					 write(',').

portray(weak_fertilize(Dir,L)) :-
    length(L,N),writef('weak_fertilize(%t,[%r])',[Dir,'.',N]).
portray(weak_fertilize(Dir,L)) :- write(weak_fertilize(Dir,L)).

portray(ripple(_)) :- write('ripple(...)').
portray(ripple(Ms)) :- write('ripple('),print(Ms),write(')').

portray(ind_strat(induction(S,V) then _)) :- write(ind_strat(S,V)).
portray(ind_strat(induction(S,V) then CaseTacs)) :- 
			write(induction(S,V)),write('then'),print(CaseTacs). 

portray(ind_strat_I(induction_I(S,V) then _)) :- write(ind_strat_I(S,V)).
portray(ind_strat_II(induction_II(S,V) then _)) :- write(ind_strat_II(S,V)).

portray('$VAR'(N)) :- N1 is 64 + (N mod 26), name(C,[N1]),write(C).

% portray(ih:[ihmarker(Tag,_),X]) :- var(Tag),!,print(ih:['RAW',X]).
% portray(ih:[ihmarker(notraw(Tag),_),X]) :- var(Tag),!,print(ih:['NOTRAW',X]).
% portray(ih:[ihmarker(_,_),X]) :- print(ih:['USED',X]).

        % [2] wave-fronts: Wave-fronts are enclosed in double quotes
        % ``....''. The wave-arguments (subterms in the wave-fronts
        % which are not part of the wave-front), are enclosed in braces
        % {...}. This corresponds to AlanBs underline notation: The
        % terms in double quotes are underlined, except the bits in
        % braces.  Thus, the step-clause for plus would be printed as:
        % plus(``s({x})'',y):=>``s({plus(x,y)})''
portray('@wave_var@'(Term)) :- write('{'),print(Term),write('}').
portray('@wave_front@'(Type,Dir,Term)):- var(Type),
                                         write('"'),
                                         print(Term),
                                         write('"'),
                                         write('<'),
                                         write(Dir),
                                         write('>').
portray('@wave_front@'(soft,Dir,Term)):- write('"'),
                                         print(Term),
                                         write('"'),
                                         write('<'),
                                         write(Dir),
                                         write('>').
portray('@wave_front@'(hard,Dir,Term)):- write('``'),
                                         print(Term),
                                         write(''''''),
					 write('<'),
				         write(Dir),
					 write('>').
portray('@sink@'(Term)) :- write('\\'),print(Term),write('/').


        % [3] (optional) pretty print some defined terms in the
        % object-level logic: 
% portray(plus(X,Y))   :- make_term(plus(X,Y),T),    print(T).
% portray(minus(X,Y))  :- make_term(minus(X,Y),T),   print(T).
% portray(times(X,Y))  :- make_term(times(X,Y),T),   print(T).
portray(leq(X,Y))    :- make_term(leq(X,Y),T),     print(T).
portray(geq(X,Y))    :- make_term(geq(X,Y),T),     print(T).
portray(less(X,Y))   :- make_term(less(X,Y),T),    print(T).
portray(greater(X,Y)):- make_term(greater(X,Y),T), print(T).
% portray(exp(X,Y))    :- make_term(exp(X,Y),T),     print(T).

        % [4] method predicates
        %
portray(wave_at(_,Pos,Term)):- 
    write('wave_at(...,'),
    print(Pos),
    write(','),
    print(Term),
    write(')').
portray(trivial(_==>C)):- 
    write('trivial([...]==>'),
    print(C),
    write(')').
portray(wave_front_at(_,Pos,Term)):-
    write('wave_front_at(...,'),
    print(Pos),
    write(','),
    print(Term),
    write(')').


make_term(X,X) :- var(X),!.
make_term(plus(X,Y),XX+YY)   :- !, make_term(X,XX),make_term(Y,YY).
make_term(minus(X,Y),XX-YY)  :- !, make_term(X,XX),make_term(Y,YY).
make_term(times(X,Y),XX*YY)  :- !, make_term(X,XX),make_term(Y,YY).
make_term(leq(X,Y),XX=<YY)   :- !, make_term(X,XX),make_term(Y,YY).
make_term(geq(X,Y),XX>=YY)   :- !, make_term(X,XX),make_term(Y,YY).
make_term(less(X,Y),XX<YY)   :- !, make_term(X,XX),make_term(Y,YY).
make_term(greater(X,Y),XX>YY):- !, make_term(X,XX),make_term(Y,YY).
make_term(exp(X,Y),XX^YY)    :- !, make_term(X,XX),make_term(Y,YY).
make_term(X,X).


        % Simple utility for use in debugging tools etc.
        % Heavily relying on Oyster pretty-printing predicates.
print_seq(H==>G) :- write_hyp(0,1,_,H),write('==> '), writeterm(3,G).

        % Rudiments of a tracer for planners. A global tracing level is
        % set. Level 0 means no tracing. Higher numbers mean more and
        % more tracing.
        % - trace_plan(?Old,?New) inquires for current or sets new
        %   tracing level. 
        % - plantraced(+N,+Pred) execute Pred if current level >N
        %   (notice that plantraced never fails, so as not to interfere
        %    with embedding code).
trace_plan(Old,New) :- 
    \+ ((var(Old);integer(Old)),(var(New);integer(New))),
    writef('CLaM ERROR: Arguments must be integers or variables\n'),!,fail.
trace_plan(Old,New) :-
    var(Old),!,
    (recorded(plantrace,plantrace(Old),_) orelse Old=0),
    trace_plan(Old,New).
trace_plan(Old,New) :-
    var(New),!,
    (recorded(plantrace,plantrace(Old),_) orelse Old=0),
    New=Old.
trace_plan(Old,New) :-
    (recorded(plantrace,plantrace(Old),_) orelse Old=0),
    (Old=New
     orelse
     ((Old=0->OldOff=' (off)';OldOff=''),(New=0->NewOff=' (off)';NewOff=''),
      writef('[The plantracer switched from level %t%t to level %t%t]\n',
             [Old,OldOff,New,NewOff]),
      uniq_recorda(plantrace,plantrace(New),_))
    ).
plantraced(N,Pred) :- \+var(N),trace_plan(M,M),M>=N,call(Pred),!.
plantraced(_,_).

        % apply_plan(+P) executes plan P. If every method has a tactic
        % which is defined as a Prolog procedure, then the constructed
        % plans could be fed to the Oyster apply/1 predicate for
        % execution. However, if this is not the case, or if we don't
        % want the collapsed proof tree, with the plan as a single
        % refinement, than we can use this apply_plan/1 predicate.
        % apply_check_plan/1 is as apply_plan/1, but also has built-in
        % error-checking: it checks if 
        % the goal resulting from applying the tactic is indeed the goal
        % that the method specified. This is expensive (since it means
        % computing the Effects of a method), but worth while during
        % development stage. We also catch application-failure.
        %
        % apply_[..]plan picks up the plan from the global variable [..]plan
        % and executes it.
apply_dplan :- dplan=:P, apply_plan(P).
apply_idplan :- idplan=:P, apply_plan(P).
apply_bplan :- bplan=:P, apply_plan(P).
apply_gdfplan :- gdfplan=:P, apply_plan(P).
apply_plan :- dplan=:P, apply_plan(P).
apply_plan(P) :- var(P), !, fail.
apply_plan(P) :- apply_plan(P,nocheck,0).
apply_plan_check(P) :- apply_plan(P,check,0).
apply_plan(P then [P1|Ps],Check,D) :- 
    plantraced(1,writef('applying tactic at depth %t: %t\n',[D,P])),
    (method(P,_,_,_,_,T)->true),
    apply(T), !,
    (Check=nocheck
     orelse
     (applicable(P,_,Effects),
      map_list(Effects,(_==>E):=>EE,wave_fronts(EE,_,E),Es),
      % findall(E, (member(_==>E1,Effects),wave_fronts(E,_,E1)),Es),
      findall(G,(down,goal(G)),Gs),!,
      (Gs\=Es
      -> (pos(Pos),
          writef('CLaM ERROR: Error at position %t:\n', [Pos]),
          writef('method %t gives unexpected results:\n',[P]),
          writef('Expected results are: '), nl, prlist(Es),
          writef('Actual  results  are: '), nl, prlist(Gs), fail)
      ; true
      )
     )
    ),
    D1 is D+1,
    apply_plan_list([P1|Ps],1,Check,D1),!.
apply_plan(P,_,D) :- \+ functorp(P,then,2),
    plantraced(1,writef('applying tactic at depth %t: %t\n',[D,P])),
    (method(P,_,_,_,_,T)->true),
    apply(T), !.
apply_plan(PP,_,_) :-
    (functorp(PP,then,2) -> PP = (P then _) ; P=PP),
    pos(Pos),
    writef('CLaM ERROR: Error at position %t:\n', [Pos]),
     write('            method '),write(P),write(' failed to apply'),nl,
    !,fail.
apply_plan_list([P1|Ps],N,Check,D) :- !,
    down(N), apply_plan(P1,Check,D), !, up, M is N+1, !,
    apply_plan_list(Ps,M,Check,D),!.
apply_plan_list([],_,_,_) :- !.

	% erase_example/1 deletes all objects which the
	% theorem Thm depends upon.
erase_example(Thm):- delete_lemmas,
                     clean_up_for(thm(Thm)),
		     lib_delete(thm(Thm)),!.
clean_up_for(Obj):- needs(Obj,Dependents),
	            lib_erase(Dependents),!.
lib_erase([]).
lib_erase([H|T]):-
		erase_object(H),
		lib_erase(T).
erase_object(def(Def)):-
                definition(Def/_<==>_),
		lib_delete(def(Def)),
		lib_delete_wave_rules(Def),
                %% lib_delete_un_defeqns(Def),
		clean_up_for(def(Def)).
erase_object(red(Red)):-
                reduction_rule(_,Red:_,_),
		lib_delete(red(Red)).
erase_object(wave([])).
erase_object(wave([WH|WT])):-
                wave_rule(WH,_,_),
		lib_delete(wave(WH)),
		erase_object(wave(WT)).
erase_object(wave([_|WT])):-
		erase_object(wave(WT)).
erase_object(wave(H)):-
		wave_rule(H,_,_),
		lib_delete(wave(H)),
		clean_up_for(thm(H)).

erase_object(un_defeqn([])).
erase_object(un_defeqn([H|T])):-
                func_defeqn(_, H:_),
                lib_delete(un_defeqn(H)),
                clean_up_for(thm(H)),
                erase_object(un_defeqn(T)).

erase_object(scheme(Sch)):-
		theorem(Sch,_,_),
		lib_delete(scheme(Sch)),
		clean_up_for(thm(Sch)).
erase_object(thm(Thm)):-
		theorem(Thm,_,_),
		lib_delete(thm(Thm)).
erase_object(mthd(Mthd/_)):-
		lib_present(mthd(Mthd/_)),
		lib_delete(mthd(Mthd/_)).
erase_object(_).

lib_delete_wave_rules(D):-
    lib_dir(Dir),
    findall(Rn,( between(1,20,N),
                 concat_atom([D,N],Rn),
                 lib_fname(Dir,Rn,'eqn',File),
                 file_exists(File)),
            RnList),
    erase_object(wave(RnList)).

lib_delete_un_defeqns(D):-
    findall(Rn,( between(1,20,N),
                 concat_atom([D,N],Rn),
                 func_defeqn(_, Rn:_)),
            RnList),
    erase_object(un_defeqn(RnList)).

plan_for(Thm):-
	plan(Thm).
plan_all:- plan_all(_),
           writef('\nBenchmarking run complete.\n\n'),
           report_results. 
plan_all(Type):-
        % load_ind_plan(4),
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
        findall(Thm,(example(Type,Thm,Status),var(Status)),Thms),
        benchmark_plan(plan,Thms,noapply).
plan_from(First):- plan_from(_,First).
plan_from(Type,First):-
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
    	findall(Thm,(example(Type,Thm,Status),var(Status)),Thms),
    	append(_,[First|Rest],Thms),
    	benchmark_plan(plan,[First|Rest],noapply).
plan_to(Last):- plan_to(_,Last).
plan_to(Type,Last):-
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
    	findall(Thm,(example(Type,Thm,Status),var(Status)),AllThms),
    	append(From,[Last|_],AllThms),
	append(From,[Last],Thms),
    	benchmark_plan(plan,Thms,noapply).
prove_all:- prove_all(_).
prove_all(Type):-
        load_ind_plan(4),
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
        findall(Thm,(example(Type,Thm,Status),var(Status)),Thms),
        benchmark_plan(plan,Thms,apply).
prove_from(First):- prove_from(_,First).
prove_from(Type,First):-
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
    	findall(Thm,(example(Type,Thm,Status),var(Status)),Thms),
    	append(_,[First|Rest],Thms),
    	benchmark_plan(plan,[First|Rest],apply).
prove_to(Last):- prove_to(_,Last).
prove_to(Type,Last):-
	lib_dir(Dir),
	concat_atom([Dir,'/','examples.pl'],File),
	file_exists(File),
	consult(File),
    	findall(Thm,(example(Type,Thm,Status),var(Status)),AllThms),
    	append(From,[Last|_],AllThms),
	append(From,[Last],Thms),
    	benchmark_plan(plan,Thms,apply).


report_results :- 
	report_failures,
	report_successes.

report_failures:-
        findall(Thm, failure(plan,Thm), ThmList),
        length(ThmList, N),
	writef('Planning failures = %t\n\n', [N]),
        print_list(ThmList).
report_successes:-
        findall(Thm, success(plan,Thm), ThmList),
        length(ThmList, N),
        writef('Planning successes = %t\n\n', [N]),
        print_list(ThmList).

        % benchmark_plan(+Planner,+ListofThms) generates plans for all
        % Thms using Planner.
        % - If ListofThms is a list of theorem, generates plans for all
        %   theorems specified in the list
        % - If ListofThms is the atom 'needs', we take all theorems
        %   specified as thm(_) in the needs/2 database.
        % - If ListofThms is any other atom, it is taken to be a
        %   directory, and Planner is run on all previously proven
        %   theorems in files *.thm in that directory.
        % 
        % benchmark_plan_apply/2 is as benchmark_plan/2, but also
        % applies the plan.
        %
        % - First map all apply/non-apply cases into benchmark_plan/3.
        % - If ListofThms is 'needs', then find all thm(_)'s from the
        %   needs/2 database and try again.
        % - If ListofThms is any other atom, then find all *.thm files
        %   in Dir and try again.
        % - If theorem spec is (Dir,Thm), run benchmark and recurse.  
        % - If theorem spec is just Thm, take Dir to be lib_dir/1, then run
        %   benchmark and recurse. 
        % 
        % To do a single benchmark, first clean out database (dubious,
        % but otherwise things get horribly clogged up), then lib_load
        % Thm from Dir, select theorem, check if indeed provable, run
        % planner, report result, and possibly apply plan.
benchmark_plan(Planner,from(First)) :- !,
    findall(Thm,(needs(thm(Thm),_),nonvar(Thm)),Thms),
    append(_,[First|Rest],Thms),
    benchmark_plan(Planner,[First|Rest],noapply).
benchmark_plan(Planner,Thms)       :- benchmark_plan(Planner,Thms,noapply).
benchmark_plan_apply(Planner,Thms) :- benchmark_plan(Planner,Thms,apply).
benchmark_plan(_,[],_)             :- !, writef('benchmark completed\n').
benchmark_plan(Planner,needs,Apply) :- !,
    findall(Thm,(needs(thm(Thm),_),nonvar(Thm)),Thms),
    benchmark_plan(Planner,Thms,Apply).
benchmark_plan(Planner,needs(Name),Apply) :- !,
    findall(Thm,(needs(thm(Thm),_),nonvar(Thm)),Thms),
    append( _, [Name|RThms], Thms ),
    benchmark_plan(Planner,RThms,Apply).
benchmark_plan(Planner,[(Dir,Thm)|Thms],Apply) :- !,
    do_one_benchmark(Planner,Thm,Dir,Apply),
    benchmark_plan(Planner,Thms,Apply).
benchmark_plan(Planner,Thms,Apply) :-
    % We use a failure driven loop here to avoid building up a gigantic stack in
    % long benchmark runs on non-smart Prolog's.
    member( Thm, Thms ),
    ( atom(Thm), Thm1 = Thm, lib_dir(Dir) ;
      ( Thm1, Dir ) = Thm
    ),
    do_one_benchmark(Planner,Thm1,Dir,Apply),
    fail.
benchmark_plan(_,_,_).   

:- dynamic success/2.
:- dynamic failure/2.

do_one_benchmark(Planner,Thm,_Dir,_Apply) :-
      Command =.. [Planner,Thm], 
      !,
      ( call(Command) 
        -> ( writef('\nPLANNING for %t COMPLETE. %f', [Thm] ),nl,nl,
	     assert(success(plan,Thm)),! )
        ;  ( writef('\nCLaM WARNING benchmark failed while constructing '),
             writef('plan on %t\n', [Thm]),
	     assert(failure(plan,Thm)))),
      erase_example(Thm),
      delete_lemmas,!.

        % quantify(?TypedVarList,?T1,?T2): T2 is the same as T1, exept
        % that it is wrapped with universal quantifications of the
        % variables mentioned in TypedVarList (a list with elements Var:Type).
        % Due to generous mode, this can be used both to quantify T1 and
        % to dequantify T2. Notice that T2 can also be partially
        % dequantified. For full dequantification, use matrix/3.
quantify([],T1,T1).
quantify([V:T|VsTs],T1,V:T=>T2) :- quantify(VsTs,T1, T2).

        % untype(?ListofTypedVars, ?ListofVars, ?ListofTypes) strips the types
        % of a list of variables, and collects the types and the vars in
        % separate lists.
        % untype(?ListofTypedVars, ?ListofVars) is as untype/3 but does not
        % return the ListofTypes. Maintained only for backward
        % compatibility. 
untype(Vars,Vs) :- untype(Vars,Vs,_).
untype([],[],[]).
untype([V:T|VsTs],[V|Vs],[T|Ts]) :- untype(VsTs,Vs,Ts).

        % decolon_preconds( ?PreConds, ?DeCPreCOnds ) turns each
        % element of PreConds Var:Term into Wit-Term and leaves the
        % rest unchanged.   This mind-pummelingly useful when you
        % want to replace variables a list of pre-conditions for a
        % lemma, a replace_universal_vars (etc) will not touch
        % V in terms of the form V:T.
decolon_preconds( [(A:B)|R], [A-B|DR] ) :-
     !,
     decolon_preconds(R,DR).
decolon_preconds( [H|R], [H|DR] ) :-
     decolon_preconds(R,DR).
decolon_preconds( [], [] ).


        % make_ground(+Term) succeeds when Term is ground. If Term is not
        % ground it will be made so by unifying all Prolog variables in
        % it with atomic terms of the form v0,v1,... We make sure that
        % these newly provided terms do not already appear in Term.
        % 
        % First clause checks if Term is already ground. Second clause
        % collects all atomic sub-terms of Term, which are used by
        % ground/2 to check while traversing Term that newly provided
        % vars do not already occur.
make_ground(Term) :-
    ground(Term),!.
make_ground(Term) :-
    findall(Atom,(exp_at(Term,[P1|_],Atom),P1\=0,atomic(Atom)),Atoms),
    ground(Term,Atoms).
make_ground(Term,Vars) :-
    findall(Atom,(exp_at(Term,[P1|_],Atom),P1\=0,atomic(Atom)),Atoms),
    ground(Term,Atoms,Vars).
ground(Term,Vars,Vars) :-
    numbervars(Term,0,0),!.
ground(Term,Atoms,Vars) :-
    exp_at(Term,_,Var), var(Var),
    genvar(Var),\+ member(Var,Atoms), !,
    ground(Term,[Var|Atoms],Vars).
ground(Term,_) :-
    numbervars(Term,0,0),!.
ground(Term,Atoms) :-
    exp_at(Term,_,Var), var(Var),
    genvar(Var),\+ member(Var,Atoms), !,
    ground(Term,[Var|Atoms]).

        % instantiation(T1,T2) tests if T2 is an instantiation of T1.
        % alpha_variant(T1,T2) tests if T1 and T2 are alphabetic variants.
        % 
        % See that great masterwork, my thesis, page 92 for formal
        % definitions and page 100 for implementation.
instantiation(T1,T2) :- \+ \+ (make_ground(T1),T1=T2).
alpha_variant(T1,T2) :- instantiation(T1,T2), instantiation(T2,T1).


logic_functors( LF ) :- oyster_functors( LF ).

        % oyster_type(?Type,?ConstructorList,?BaseElemList) is a reflection of
        % Oysters types: Type is a type with constructors as 
        % in ConstructorList and base elements as in BaseElemList.
        %
        % This is of course not complete and should be expanded as and
        % when needed.
        %
        % (Maybe we should even allow the use of this inside methods (in
        % which case it should move to method-pred.pl)).
/* 
 * The following clause is required to integrate Clam 
 * with Andrew Stevens shell mechanism.
 *
 * oyster_type( T, Constrs, BaseConstrs ) :-
 *   tuple( shell, [T,GndCnsts|_]),
 *   base_step_constrs( GndCnsts, T, Constrs, BaseConstrs ).
 *
 */
oyster_type(pnat,[s(_)],[0]).
oyster_type(_ list,[(_::_)],[nil]).
oyster_type(_ tree,[tree(_,_)],[leaf(_)]). 

base_step_constrs( [Con|RCons], T, [MCon|RSteps], Bases ) :-
    def_appl(Functor,Args,Con),
    member( _:T, Args ),
    !,
    same_length( Args,MArgs,_),
    def_appl(Functor,MArgs,MCon),
    base_step_constrs( RCons, T, RSteps, Bases ).
base_step_constrs( [Con|RCons], T, Steps, [MCon|RBases] ) :-
    cdef_appl(Functor,Args,Con),
    same_length( Args,MArgs,_),
    cdef_appl(Functor,MArgs,MCon),
    base_step_constrs( RCons, T, Steps, RBases ).
base_step_constrs( [], _, [], [] ).


% Conversion between nat and pnat
%
%
nat2pnat(0,0).
nat2pnat(N,s(M)) :- NN is N-1, nat2pnat(NN,M).
pnat2nat(0,0).
pnat2nat(s(X),M) :- pnat2nat(X,MM),M is MM+1.
    

        % Find out run-time of a predicate.
runtime(P,T) :- statistics(runtime,_), call(P), statistics(runtime,[_,T]).
        % Take average T of run-time of a predicate P over N number of runs.
runtime(P,N,T) :- runtime1(P,N,Ts), write(Ts),nl,average(Ts,T),!.
runtime1(_,0,[]).
runtime1(P,N,[T1|Ts]) :-
    N>0, copy(P,P1),runtime(P1,T1), N1 is N-1, runtime1(P,N1,Ts).

        % sum(+NumList,?Sum): Sum is the sum of the elements in NumList.
sum([], 0).
sum([N|Ns], S) :- sum(Ns, T), S is T+N.

        % average(+NumList,?Average): Average is the average of the
        % elements in NumList.
average(L,A) :- sum(L,S), length(L,N), A is S/N.

        %   between(+Lower, +Upper, ?Number)
        %   is true when Lower, Upper, and Number are integers,
        %   and Lower =< Number =< Upper.  If Lower and Upper are given,
        %   Number can be tested or enumerated.  If either Lower or Upper
        %   is absent, there is not enough information to find it, and an
        %   error will be reported.
        %
        % This predicate is lifted from the Quintus library between,
        % since it contains syntax errors and redefines repeat (sigh...).
between(Lower, Upper, Point) :-
        integer(Lower),
        integer(Upper),
        (   integer(Point), !,          %  These cuts must be cuts;
            Lower =< Point, Point =< Upper
        ;   var(Point), !,              %  they can't be arrows.
            Lower =< Upper,
            between1(Lower, Upper, Point)
        ).
between(Lower, Upper, Point) :-
        Goal = between(Lower,Upper,Point),
        must_be_integer(Lower, 1, Goal),
        must_be_integer(Upper, 2, Goal),
        must_be_integer(Point, 3, Goal).

        %%  between1(Lower, Upper, Point)
        %   enumerates values of Point satisfying Lower =< Point =< Upper,
        %   where it is already known that Lower =< Upper and Point was a
        %   variable.  A purer version of this is left as a comment.
between1(L, L, L) :- !.
between1(L, _, L).              % between1(L, U, L) :- L =< U.
between1(L, U, N) :-            % between1(L, U, N) :- L < U,
        M is L+1,               %       M is L+1,
        between1(M, U, N).      %       between1(M, U, N).

        % partition_(?List, ?N, ?PreN, ?Nth, ?PostN): splits List up in 3 parts:
        % elements 0 to N-1, the Nth element, and elements N+1 to end.
        % Fail if N>=length(List).
        % Notice that all arguments can be uninstantiated (at the cost
        % of tail-recursion....who said more "declarative" algorithms are
        % also more efficient? Richard O'Keefe, where are you when we
        % could prove you wrong?)
partition_([H|T], 0, [], H, T).
partition_([H|T], N, [H|Pre], Nth, Post) :-
    partition_(T, M, Pre, Nth, Post),
    N is M+1.

        % remove_pred(Spec) and remove_pred(Name,Arity) are exactly as
        % abolish/[1;2]. This is mainly to allow us to redefine this
        % under SICStus to shut up SICStus abolish/[1;2] spurious messages
        % (sigh...)
remove_pred(Spec) :- \+ dialect(sic), !, abolish(Spec).
remove_pred([]) :- !.
remove_pred([H|T]) :- !, remove_pred(H), remove_pred(T).
remove_pred(P/A) :- current_predicate(P,F),functor(F,P,A),!,abolish(P,A).
remove_pred(P) :- atom(P), current_predicate(P,_),!,abolish(P),fail.
remove_pred(_).
remove_pred(Name,Arity) :- \+ dialect(sic), !, abolish(Name,Arity).
remove_pred(Name,A) :- remove_pred(Name/A).

        % skeleton(+Term,?Skeleton) Skeleton is a term of same functor
        % and arity as Term, but with all Terms arguments replaced by
        % unique Prolog variables.
skeleton(Term,Skeleton) :- functor(Term,F,N),functor(Skeleton,F,N).

        % Trivial utility to execute conjunctions represented as lists.
        % Note: now defined in planner.pl
% call_conjunction([]) :- !.
% call_conjunction(L) :- list2conj(L,C),!,call(C).
        % Coded slightly weird to allow bi-directional use:
% list2conj([H,Ht|T],(H,T1)) :- !,list2conj([Ht|T],T1).
% list2conj([H],H).

print_multi_list([]):-nl.
print_multi_list([H|T]):-
    print_list(H),
    print_multi_list(T).
print_list([]):- writef('-------------\n').
print_list([H|T]):-
    print(H),nl,
    print_list(T).

        % tryto +G: will try to perform G but will succeed anyway if G
        % fails. Can be used to backtrack through all solutions for G
        % and succeed at the end anyway.
tryto G :- G.
tryto _.

        % on_backtracking +G will not do anything on first execution,
        % but will execute G on backtracking, and then fail (thereby not
        % affecting the behaviour of the calling program).
on_backtracking _.
on_backtracking G :- G, !, fail.


        % on_backtracking2 +G will not do anything on first execution,
        % but will execute G on backtracking, and then fail (thereby not
        % affecting the behaviour of the calling program).
on_backtracking2 _.
on_backtracking2 G :- G. 


        % Simple routine for yes/no (y/n) prompting. Only gets activated
        % if trace-level is high enough (>=N).
        % Second clause is to force success when tracing level is too low.
yn(N,Prompt) :-
    trace_plan(M,M), M>=N, !,
    print(Prompt), writef('%f'),
    get(121), get0(_). % 121 = y and read away <cr>
yn(_,_).

        % max(+List,?Max) Max is maximum element of List. uses general
        % ordering on terms for comparing elements.
        % min(+List,?Min) similar for minimum.
max([H|T],M) :- max(T,H,M).
max([],S,S).
max([H|T],S,M) :- H@>S,  max(T,H,M).
max([H|T],S,M) :- H@=<S, max(T,S,M).

min([H|T],M) :- min(T,H,M).
min([],S,S).
min([H|T],S,M) :- H@<S,  min(T,H,M).
min([H|T],S,M) :- H@>=S, min(T,S,M).

        % genint(?N,+Delta), generates integers N with interval Delta.
        % This is a generalisation of genint/1 from Oyster which fixes
        % Delta=1. 
genint(0,_).
genint(N,Delta) :- genint(M,Delta), N is M+Delta.

del( [H|T], H, T ).
del( [H|T], HH, [H|R] ) :-
    del( T, HH, R ).


        % zip(?Pairs,?L1,?L2) Pairs is a list consisting of pairs of
        % elements from L1 and L2. L1 and L2 must be of equal length.
        % Can of course be used for zipping as well as unzipping to
        % lists. 
zip([],[],[]).
zip([H1-H2|Ps],[H1|T1],[H2|T2]) :- zip(Ps,T1,T2).

        % functorp(+Term,?F,?A) Term has functor F of arity A.
        % The difference between this and the built-in functor/3 is that
        % Term has to be given. In other words, this can only be used to
        % >*test*< if Term is F/A, and not to >*construct*< a term of F/A.
functorp(Term,_,_) :- var(Term),!,fail.
functorp(Term,Functor,Arity) :- functor(Term,Functor,Arity).

/*
 * The following predicates implement a "make" predicate: when files are
 * (re)consulted used (re)load, the system will store a time-stamp to
 * record the time when the file was loaded. The make/0 predicate will
 * compare the load-time time-stamp of each loaded file with the current
 * modification date of the file, and if the later is newer, reload the
 * file.
 * NOTE: this only works for files that have been loaded using the
 * (re)load/1 predicates (and not for files that have just been
 * (re)consulted.
 *
 * load/1, reload/1 and time_stamp/1 are defined in boot.pl
 */

        % make -Flag: make -i reloads files (interpreted) (the default).
        %             make -c recompiles files
        %             make -n finds out which files are to be reloaded,
        %                     but doesn't actually remake them.
        %             make    is shorthand for make -i.
        % Long live failure driven loops!
'make' :- make -i.
make -n :-
    recorded(time_stamp,(File,WhenLoaded),_),
    file_property(File,modify_time,WhenModified),
    WhenModified @> WhenLoaded,
    write(File),nl,
    fail.
make Flag :-
    (Flag == -i ; Flag == -c), 
    recorded(time_stamp,(File,WhenLoaded),_),
    file_property(File,modify_time,WhenModified),
    WhenModified @> WhenLoaded,
    (Flag = -i
     -> reload(File)
     ;  (/* Flag = -c, */ loadc(File))
    ),
    fail.
make _ .


/*
 * Follow a couple of random predicates making live with Oyster a bit
 * more bearable:
 */

        % d/0 is a compacter version of display/0. Only shows goals of
        % current node and children, plus status of children. Forgets
        % about hyps.
d :- goal, fail.
d :- write('by '),refinement, fail.
d :- down, status, goal, fail.
d.

        % snap/{0,1} are compacter versions of snapshot/{0,1}. They
        % print the proof under the current node (as snapshot/{0,1}),
        % but only print goals and refinements, and don't mention
        % hypotheses (unlike snapshot/{0,1}). This makes for a better
        % overview of the proof tree. 
snap :- snap(user).
snap(File) :- tell(File), snap(File,0), told.
snap(File,I) :-
    tab(I), goal,
    tab(I), write('by '), refinement,
    I1 is I+4,
    down, snap(File,I1), fail.
snap(_,_).

        % search(Pred) does a depth first search for the first node
        % below the current one where Pred is true.
search(Pred) :- call(Pred).
search(Pred) :- down, search(Pred).


/* Y can be instantiated to X with a non-cyclic substitution */
matches(X, Y) :-
     \+ \+ (numbervars(X,0,_), X=Y).

